---
description: Release notes writing rules for Cursor
alwaysApply: false
---
---
description: Cursor release notes guidelines
type: always
---
# Cursor Release Notes Rules

You are an AI assistant specialized in generating **release notes** for the Velt project.  
When producing release notes, you must strictly reference and align with the official changelog files.

## Core Rules

### Source of Truth
- The canonical sources for release notes are the individual changelog files:  
  - `blocknote-changelog.mdx`  
  - `codemirror-changelog.mdx`  
  - `crdt-core-changelog.mdx`  
  - `lexical-changelog.mdx`  
  - `reactflow-changelog.mdx`  
  - `sdk-changelog.mdx`  
  - `tiptap-changelog.mdx`  
  - `upgrade-guide.mdx` (for migration details)  
- Always consult the relevant file(s) when drafting or updating release notes.  
- Treat that section as the **canonical source** for features, changes, and instructions.  
- Do **not** introduce details outside of these changelogs unless explicitly instructed.  
- Preserve the order, versioning, and dates exactly as written in the source files.  
- Never mention **client names** (e.g., “Heygen”). Use generic phrasing instead (“host app”, “optimized Single Editor Mode”, etc.).

### Writing Style
- Use clear, concise, and professional language.  
- Write in second person (“you”) when providing guidance.  
- Maintain active voice and present tense.  
- Keep headings descriptive and keyword-rich for scanability.  
- Always explain **what the feature/bug fix does, why it matters, and what users can do with it**.  
- Provide examples of where a feature is useful (e.g., referencing tools like Linear for custom lists).
- Rephrase bug fixes and improvements in user-friendly terms, focusing on the issue resolved and the benefit.
- Replace vague or internal categories with **user-facing terms**:  
  - “Cloud Functions” → **Access Control**  
  - “Recorder / Player” → **Recorder**  
  - “Comments / Wireframes” → **UI Customization**  
- When describing **roles** (Editor/Viewer), always define:  
  - What the role does (Editor = can view + edit, Viewer = view only).  
  - Why this matters (security, collaboration, access control).  
  - How users can apply this (via APIs, setup, key concepts page).  

### Content Structure
- Lead with the most important/breaking changes first.  
- Group updates under sections:  
  - **New Features**  
  - **Improvements**  
  - **Bug Fixes**  
- Do **not** introduce new section names such as "Updates" or "Changes".  
- Each subsection must use the **feature name** as the heading (never `[**Update**]` or similar).  
- Release notes must **always** follow this three-part structure.  
- Always order subsections as: **New Features → Improvements → Bug Fixes**.  
- Never duplicate section headings (e.g., no two “Improvements” in the same version).  
- Keep category naming consistent across all releases.  
- For features with **multiple parts**, split them into separate bullet points (e.g., “Link callback” vs “Slack-style link pasting”).  
- Internal/debug-only changes should be described generically (e.g., “Added additional debugging logs for Single Editor Mode”).  

### Code and Examples
- Always put **React** first in `<Tabs>` code blocks.  
- Ensure codeblock names are **consistent** across all release notes (`React / Next.js`, `Other Frameworks`).  
- Whenever functionality is exposed via **hooks, APIs, or props**, document them **together in the same tab**, separated into clear subsections (see existing examples).  
- Include runnable code snippets only if referenced in the source lines.  
- Wrap code in fenced blocks with correct language identifiers.  
- Add short explanatory comments if the code may be unclear.  
- If an API is deprecated or changed in the latest version, **do not include the old code block** in release notes to avoid confusion.  
- If an API is documented under **Customize Behavior**, always add at least one line explaining **what it does and why to use it**.  
- **Always create a code example section with tabs for both React and Other Frameworks**:  
  - Use `<Tabs>` with `<Tab title="React / Next.js">` and `<Tab title="Other Frameworks">`.  
  - If an “Other Frameworks” example is not explicitly provided, **assume an HTML implementation using the React example as the base**.  
- Place **code blocks immediately after their relevant description** — never combine unrelated samples.  
- In **React tabs**, include both **hook and API method examples** in the same tab, separated by comments.  
- Add parent wireframe wrapper (`<VeltWireframe>`) when showing wireframe examples.  
- When introducing new UI elements (e.g., “Edited” chip), explicitly note that **wireframes were added for customization** and show the parent context (`<VeltCommentDialogWireframe.Composer>`, etc.).  

### User-Centered Approach
- Focus on what the user needs to do during upgrades.  
- Highlight action items and expected outcomes.  
- Use warnings to call out migration blockers or destructive actions.  
- Always explain the **why** for major features (e.g., heartbeat fallback = presence detection, grouped lists = better UX like Linear).  
- Clarify defaults (e.g., `accessRole` defaults to `"editor"`).  
- Frame internal implementation changes in user terms (avoid exposing raw service names).  

## Component Usage
- **<Update>**: Wrap the entire release note for each version.  
- **<Warning>**: Breaking changes and required migrations.  
- **<Check>**: Confirmation of fixes or completed upgrades.  
- **<Steps>**: Sequential upgrade instructions.  
- **<CodeGroup>**: Alternative examples in multiple languages.  
- **<Tabs>**: Always React / Next.js first, Other Frameworks second.  

---

## CRDT vs SDK Updates
- Never mix **Core SDK updates** into **CRDT updates**.  
- If relevant, you may add a short **summary note** in CRDT release notes referencing the SDK, but always use the CRDT library’s version number.  

---

## Wireframes
- Whenever a new **wireframe** is added, always update it under the **UI Customization** section.  
- Add **parent wireframe tags** (`<VeltWireframe>`) around examples.  
- Explicitly mention when **new wireframes** are added (e.g., “New wireframes added to customize the ‘Edited’ chip”).  

---

## Types, APIs, and Hooks
- Always add **all type definitions** to the **Data Models** page (never inline in docs).  
- Always add relevant **hooks and methods** to their dedicated **hooks** and **API** pages.  
- If a type or API is extended, always get the **latest definition from engineering** and update the **data model / API / hook page** accordingly.  
- Link all main documentation pages to the **Data Models** page instead of duplicating types inline.  
- Always update **users, permissions, generate_token** APIs with role/accessRole details when changes occur.  
- Clarify allowed values and defaults explicitly:  
  - `accessRole`: `"viewer"` | `"editor"`. Default: `"editor"`.  
  - Mention that `accessRole` can only be set via REST APIs (not frontend methods).  
- For grouped list features:  
  - Use “Grouped lists” instead of “Added group support”.  
  - Clarify difference between flat list vs grouped list.  
  - In AutocompleteGroup docs, state it applies only to grouped lists.  

---

## Repo-wide Reference Scan (naming alignment across docs)

When a feature name, API, prop, or config key changes in the release notes, you must **scan and align the entire documentation codebase** to keep terminology consistent.

### Scan Scope (Include)
Search these documentation paths and formats:  
- `release-notes/**`  
- `docs/**`, `guide/**`, `handbook/**`, `content/**`, `pages/**`  
- `ui-customization/**`, `realtime-collaboration/**`, `api-reference/**`  
- `**/*.md`, `**/*.mdx`, `**/*.markdown`  
- Example/snippet sources: `examples/**`, `snippets/**`, `demo/**`  
- Component docs that render UI examples:  
  `**/*.tsx`, `**/*.jsx`, `**/*.ts`, `**/*.js` (only if used to render docs)  

### Scan Scope (Exclude)
Avoid bulk renames in:  
- Build artifacts, caches, and lockfiles:  
  `node_modules/**`, `.next/**`, `dist/**`, `build/**`, `out/**`, `**/*.map`  
- Binary/media:  
  `**/*.{png,jpg,jpeg,gif,svg,mp4,webm,mp3,ttf,woff,woff2}`  

### Safe Search Patterns
- Prefer **word boundaries** to avoid partial matches:  
  - `\bOldFeatureName\b`  
  - `\bold_feature_name\b`  
- Consider common variants:  
  - Case: `OldFeatureName`, `oldFeatureName`, `old-feature-name`, `old_feature_name`  
  - Plurals and adjectival forms: `OldFeatureNames`, `OldFeatureName-based`  
- Disambiguate generic terms with **nearby qualifiers** when needed.  

### Suggested Grep Commands (Non-Destructive)

```bash
# Preview matches (ripgrep recommended)
rg -n --hidden --glob '!node_modules' --glob '!dist' --glob '!build' \
  --glob '!**/*.map' --glob '!**/*.{png,jpg,jpeg,gif,svg,mp4,webm,mp3,ttf,woff,woff2}' \
  -e '\bOldFeatureName\b' \
  release-notes docs ui-customization realtime-collaboration api-reference pages examples snippets


# Refactor & Alignment Policy

## Change Map

| From (exact)       | To (exact)         | Notes / Constraints                        |
|--------------------|--------------------|--------------------------------------------|
| `OldFeatureName`   | `NewFeatureName`   | Keep PascalCase in headings & components   |
| `oldFeatureName`   | `newFeatureName`   | Keep camelCase in code snippets            |
| `old-feature-name` | `new-feature-name` | Keep kebab-case in URLs/anchors            |
| `old_feature_name` | `new_feature_name` | Keep snake_case in config keys             |

---

## Respect Casing by Context
- **Headings & components:** PascalCase  
- **Code identifiers:** camelCase  
- **URLs/anchors:** kebab-case  
- **Config keys / env vars:** snake_case or ALL_CAPS as appropriate  

---

## Do Not Edit
- Historical release notes predating the change unless the change is purely terminology and not altering history.  
- External quoted code or API responses.  

---

## Post-Scan Checklist
- Update cross-links and anchors if the slug changes (e.g., `#old-feature-name` → `#new-feature-name`).  
- Validate `<Tabs>`, `<Steps>`, `<CodeGroup>` blocks still compile and render.  
- Ensure screenshots/captions referencing old names are either updated or left with a clarifying note.  
- Run docs build/lint to catch broken links and import/anchor mismatches.  
- Replace outdated identifiers consistently (e.g., `annotationId` → `recorderId`).  
- For link features, ensure event subscriptions (`linkClicked`) are documented under **child of event subscription**, not inline.  

---

## Output
When you propose release notes that rename or deprecate things, include a short section:

- **Renamed/Aligned terms:** list the change map you applied.  
- **Files touched (summary):** top 5–10 doc paths (or provide a count if large).  
- **Follow-ups:** screenshots to update, external references to notify.  

---

## Quality Assurance Checklist
- Verify all references come from the **first 500 lines of `release-notes/version-4/changelog.mdx`**.  
- Ensure correct Mintlify component syntax.  
- Maintain consistent formatting and terminology.  
- Validate code examples and headings.  
- Confirm repo-wide alignment completed (search done, change map applied, links verified).  
- Ensure **New Features → Improvements → Bug Fixes** order is respected.  
- Validate categories (no duplicates, no non-standard labels).  
- Confirm each feature explains **what, why, how**.  
- Verify wireframe examples include parent tags.  
- Check React examples always include both hook + API.  
- Confirm accessRole/API updates are linked to **key concepts** and **setup** docs.  
