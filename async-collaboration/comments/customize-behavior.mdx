---
title : "Customize Behavior"
---

# Threads
#### addCommentAnnotation

- Adds a new comment annotation.
- Params: [AddCommentAnnotationRequest](/api-reference/sdk/models/data-models#addcommentannotationrequest)
- Returns: [AddCommentAnnotationEvent](/api-reference/sdk/models/data-models#addcommentannotationevent)

<Tabs>
<Tab title="React / Next.js">
```jsx
const commentAnnotation = {
  comments: [
    {
      commentText: 'This is a comment',
      commentHtml: '<p>This is a comment</p>',
    }
  ]
};
const addCommentAnnotationRequest = {
  annotation: commentAnnotation
};

// Hook
const { addCommentAnnotation } = useAddCommentAnnotation();
const addCommentAnnotationEventData = await addCommentAnnotation(addCommentAnnotationRequest);

// API Method
const commentElement = client.getCommentElement();
const addCommentAnnotationEventData = await commentElement.addCommentAnnotation(addCommentAnnotationRequest);
```
</Tab>

<Tab title="Other Frameworks">
```js
const commentAnnotation = {
  comments: [
    {
      commentText: 'This is a comment',
      commentHtml: '<p>This is a comment</p>',
    }
  ]
};
const addCommentAnnotationRequest = {
  annotation: commentAnnotation
};

const commentElement = Velt.getCommentElement();
const addCommentAnnotationEventData = await commentElement.addCommentAnnotation(addCommentAnnotationRequest);
```
</Tab>
</Tabs>

#### addCommentOnSelectedText

![](/images/addCommentOnSelectedText.png)


By default, when you highlight over any text in `textMode` a Comment Tool button will appear. Clicking the button will add a comment on the highlighted text.

If you want to trigger the comment using an API method call instead of clicking the button, you can do the following:

<Tabs>
<Tab title="React / Next.js">

```jsx
const commentElement = client.getCommentElement();
// to add comment on selected text
commentElement.addCommentOnSelectedText();
```
</Tab>

<Tab title="Other Frameworks">
```jsx
const commentElement = Velt.getCommentElement();
// to add comment on selected text
commentElement.addCommentOnSelectedText();
```
</Tab>


</Tabs>

#### addCommentOnElement

![](/images/addCommentOnElement.png)

Adds a Comment on a specific element by ID.

To add a comment on a specific element through an API method, use the `addCommentOnElement()` method and pass in an object with the schema shows in the example:

**Example 1: Add comment with targetElementId only:**

<Tabs>
<Tab title="React / Next.js">

```jsx
const element = {
  "targetElement": {
    "elementId": "element_id",  // optional (pass elementId if you want to add comment on a specific element)
    "targetText": "target_text", // optional (pass targetText if you want to add comment on a specific text)
    "occurrence": 1, // optional (default: 1) This is relevant for text comment. By default, we will attach comment to the first occurence of the target text in your document. You can change this to attach your comment on a more specific text.
  	"selectAllContent": true, // Set to `true` if you want to select all the text content of the target element.
  },
  "commentData": [
    {
      "commentText": "This is awesome! Well done.", // To set plain text content
      "commentHtml": "This <span style=\"color: green; background-color: aliceblue; display: inline-block; padding: 4px; border-radius: 4px;\">is test</span> comment.", // To set HTML formatted content
      "replaceContentText": "This is new comment", // provide this replaceContentText to replace current text with
      "replaceContentHtml": "<span>This is <b>new</b> comment.</span>", // If replacement text contains html formatted text, then provide it here
    }
  ],
  "status": "open", // optional (default: open)
}

const commentElement = client.getCommentElement();
commentElement.addCommentOnElement(element);
```
</Tab>

<Tab title="Other Frameworks">

```jsx
const element = {
  "targetElement": {
    "elementId": "element_id", // optional (pass elementId if you want to add comment on a specific element)
    "targetText": "target_text", // optional (pass targetText if you want to add comment on a specific text)
    "occurrence": 1, // optional (default: 1) This is relevant for text comment. By default, we will attach comment to the first occurence of the target text in your document. You can change this to attach your comment on a more specific text.
  	"selectAllContent": true, // Set to `true` if you want to select all the text content of the target element.
  },
  "commentData": [
    {
      "commentText": "This is awesome! Well done.", // To set plain text content
      "commentHtml": "This <span style=\"color: green; background-color: aliceblue; display: inline-block; padding: 4px; border-radius: 4px;\">is test</span> comment.", // To set HTML formatted content
      "replaceContentText": "This is new comment", // provide this replaceContentText to replace current text with
      "replaceContentHtml": "<span>This is <b>new</b> comment.</span>", // If replacement text contains html formatted text, then provide it here
    }
  ],
  "status": "open", // optional (default: open)
}

const commentElement = Velt.getCommentElement();
commentElement.addCommentOnElement(element);
```
</Tab>
</Tabs>

#### addManualComment
- This feature is particularly useful for complex UIs where you need precise control over the placement of Comment Pins.
- Using this you can manually set the position of Comment Annotations.
- Handle click events on your canvas/document and use the this method to create a comment with custom metadata.

<Tabs>
<Tab title="React / Next.js">

```jsx
const context = {
  position: {x: 200, y: 100},
};
const commentElement = client.getCommentElement();
const config: ManualCommentAnnotationConfig = {
	context: context, // your context here
};
commentElement.addManualComment(config);
```

</Tab>

<Tab title="Other Frameworks">
```jsx
const context = {
  position: {x: 200, y: 100},
};
const commentElement = Velt.getCommentElement();
const config: ManualCommentAnnotationConfig = {
	context: context, // your context here
};
commentElement.addManualComment(config);
```
</Tab>
</Tabs>


#### Comment and Reply Placeholders
Customize the placeholder text shown in the Comments dialog inputs to match your product voice and guide first-time users.

<Tabs>
<Tab title="React / Next.js">
```jsx
// Using props on VeltComments
<VeltComments commentPlaceholder="Text Comment" replyPlaceholder="Text Reply" />
```
</Tab>

<Tab title="Other Frameworks">
```html
<velt-comments comment-placeholder="test comment placeholder" reply-placeholder="test reply placeholder"></velt-comments>
```
</Tab>
</Tabs>

#### deleteCommentAnnotation

- Deletes a comment annotation
- Params: [DeleteCommentAnnotationRequest](/api-reference/sdk/models/data-models#deletecommentannotationrequest)
- Returns: [DeleteCommentAnnotationEvent](/api-reference/sdk/models/data-models#deletecommentannotationevent)

<Tabs>
<Tab title="React / Next.js">
```jsx
const deleteCommentAnnotationRequest = {
  annotationId: 'ANNOTATION_ID'
};

// Hook
const { deleteCommentAnnotation } = useDeleteCommentAnnotation();
const deleteCommentAnnotationEvent = await deleteCommentAnnotation(deleteCommentAnnotationRequest);

// API Method
const commentElement = client.getCommentElement();
const deleteCommentAnnotationEvent = await commentElement.deleteCommentAnnotation(deleteCommentAnnotationRequest);
```
</Tab>

<Tab title="Other Frameworks">
```js
const deleteCommentAnnotationRequest = {
  annotationId: 'ANNOTATION_ID'
};

const commentElement = Velt.getCommentElement();
const deleteCommentAnnotationEvent = await commentElement.deleteCommentAnnotation(deleteCommentAnnotationRequest);
```
</Tab>
</Tabs>





#### deleteSelectedComment
To delete a comment using an API method, use the `deleteSelectedComment()` method.

<Tabs>
<Tab title="React / Next.js">
```jsx
if (client) {
  const commentElement = client.getCommentElement();
  commentElement.deleteSelectedComment();
}
```
</Tab>

<Tab title="Other Frameworks">
```jsx
if (Velt) {
  const commentElement = Velt.getCommentElement();
  commentElement.deleteSelectedComment();
}
```

</Tab>


</Tabs>

#### getCommentAnnotationsCount
- Get the total and unread comment annotations count of all the comment annotations across specified Organization, Folder, Document and Multiple Documents levels.
- If you don't specify any query, it will return data from the folder/documents specified in the `setDocuments` method.
- You can specify 30 documents at a time.
- Set `aggregateDocuments` to `true` to aggregate comment counts across all documents set in the `setDocuments` method, returning a single combined count instead of per-document counts.
- **Params:** (optional) [CommentRequestQuery](/api-reference/sdk/models/data-models#commentrequestquery)
- **Returns:** [GetCommentAnnotationsCountResponse](/api-reference/sdk/models/data-models#getcommentannotationscountresponse)

<Info>
  Avaiable on SDK version 4.0.0 and above.
</Info>

<Tabs>
<Tab title="React / Next.js">

<CodeGroup>
```jsx Organization Level
const { data } = useCommentAnnotationsCount({ organizationId: 'org1' });

useEffect(() => {
  if (data) {
    console.log('Comment annotations count for org1:', data);
  }
}, [data]);
```

```jsx Folder Level
const { data } = useCommentAnnotationsCount({
  organizationId: 'org1',
  folderId: 'folder2',
  allDocuments: true
});

useEffect(() => {
  if (data) {
    console.log('Comment annotations count for folder2:', data);
  }
}, [data]);
```

```jsx Document Level (Default)
const { data } = useCommentAnnotationsCount();

useEffect(() => {
  if (data) {
    console.log('Comment annotations count:', data);
  }
}, [data]);
```

```jsx Multiple Documents
const { data } = useCommentAnnotationsCount({
  documentIds: ['doc1', 'doc2', 'doc3']
});

useEffect(() => {
  if (data) {
    console.log('Comment annotations count for multiple documents:', data);
  }
}, [data]);
```

```jsx Aggregate Documents
const { data } = useCommentAnnotationsCount({ aggregateDocuments: true });

useEffect(() => {
  if (data) {
    console.log('Aggregated comment annotations count:', data);
  }
}, [data]);
```

```jsx Aggregate Multiple Documents
const { data } = useCommentAnnotationsCount({ 
  documentIds: ['doc1', 'doc2', 'doc3'],
  aggregateDocuments: true 
});

useEffect(() => {
  if (data) {
    console.log('Aggregated comment annotations count for multiple documents:', data);
  }
}, [data]);
```

```jsx Filter out Ghost Comments
const { data } = useCommentAnnotationsCount({ filterGhostComments: true });

useEffect(() => {
  if (data) {
    console.log('Filtered comment annotations count:', data);
  }
}, [data]);
```
</CodeGroup>

**Using API:**
<CodeGroup>
```jsx Organization Level
const commentElement = client.getCommentElement();
commentElement.getCommentAnnotationsCount({ organizationId: 'org1' }).subscribe((response) => {
  console.log('getCommentAnnotationsCount with organizationId', response.data);
});
```

```jsx Folder Level
const commentElement = client.getCommentElement();
commentElement.getCommentAnnotationsCount({
  organizationId: 'org1',
  folderId: 'folder2',
  allDocuments: true
}).subscribe((response) => {
  console.log('getCommentAnnotationsCount with organizationId and folderId and allDocuments', response.data);
});
```

```jsx Document Level (Default)
const commentElement = client.getCommentElement();
commentElement.getCommentAnnotationsCount().subscribe((response) => {
  console.log('getCommentAnnotationsCount', response.data);
});
```

```jsx Multiple Documents
const commentElement = client.getCommentElement();
commentElement.getCommentAnnotationsCount({
  documentIds: ['doc1', 'doc2', 'doc3']
}).subscribe((response) => {
  console.log('getCommentAnnotationsCount for multiple documents', response.data);
});
```

```jsx Aggregate Documents
const commentElement = client.getCommentElement();
commentElement.getCommentAnnotationsCount({ aggregateDocuments: true }).subscribe((response) => {
  console.log('getCommentAnnotationsCount with aggregateDocuments', response.data);
});
```

```jsx Aggregate Multiple Documents
const commentElement = client.getCommentElement();
commentElement.getCommentAnnotationsCount({ 
  documentIds: ['doc1', 'doc2', 'doc3'],
  aggregateDocuments: true 
}).subscribe((response) => {
  console.log('getCommentAnnotationsCount for aggregated multiple documents', response.data);
});
```

```jsx Filter out Ghost Comments
const commentElement = client.getCommentElement();
commentElement.getCommentAnnotationsCount({ filterGhostComments: true }).subscribe((response) => {
  console.log('getCommentAnnotationsCount with filterGhostComments', response.data);
});
```
</CodeGroup>

</Tab>

<Tab title="Other Frameworks">
<CodeGroup>
```js Organization Level
const commentElement = Velt.getCommentElement();
commentElement.getCommentAnnotationsCount({ organizationId: 'org1' }).subscribe((response) => {
  console.log('getCommentAnnotationsCount with organizationId', response.data);
});
```

```js Folder Level
const commentElement = Velt.getCommentElement();
commentElement.getCommentAnnotationsCount({
  organizationId: 'org1',
  folderId: 'folder2',
  allDocuments: true
}).subscribe((response) => {
  console.log('getCommentAnnotationsCount with organizationId and folderId and allDocuments', response.data);
});
```

```js Document Level (Default)
const commentElement = Velt.getCommentElement();
commentElement.getCommentAnnotationsCount().subscribe((response) => {
  console.log('getCommentAnnotationsCount', response.data);
});
```

```js Multiple Documents
const commentElement = Velt.getCommentElement();
commentElement.getCommentAnnotationsCount({
  documentIds: ['doc1', 'doc2', 'doc3']
}).subscribe((response) => {
  console.log('getCommentAnnotationsCount for multiple documents', response.data);
});
```

```js Aggregate Documents
const commentElement = Velt.getCommentElement();
commentElement.getCommentAnnotationsCount({ aggregateDocuments: true }).subscribe((response) => {
  console.log('getCommentAnnotationsCount with aggregateDocuments', response.data);
});
```

```js Filter Ghost Comments
const commentElement = Velt.getCommentElement();
commentElement.getCommentAnnotationsCount({ filterGhostComments: true }).subscribe((response) => {
  console.log('getCommentAnnotationsCount with filterGhostComments', response.data);
});
```
</CodeGroup>
</Tab>
</Tabs>


#### getUnreadCommentAnnotationCountByLocationId
- Get the number of `CommentAnnotations` with at least 1 unread Comment by Location Id.

<Tabs>
<Tab title="React / Next.js">

**Using Hooks:**
```jsx
const count = useUnreadCommentAnnotationCountByLocationId(locationId);
useEffect(() => {
  console.log(count, 'countObj')
}, [count])
```

**Using API:**
```jsx
if (client) {
  const commentElement = client.getCommentElement();
  let subscription = commentElement.getUnreadCommentAnnotationCountByLocationId(locationId).subscribe((countObj) => {
    console.log(countObj);
  });
}
```

To unsubscribe from the subscription:
```jsx
subscription?.unsubscribe()
```
</Tab>
<Tab title="Other Frameworks">

```jsx
if (Velt) {
  const commentElement = Velt.getCommentElement();
  let subscription = commentElement.getUnreadCommentAnnotationCountByLocationId(locationId).subscribe((countObj) => {
    console.log(countObj);
  });
}
```

To unsubscribe from the subscription:
```jsx
subscription?.unsubscribe()
```
</Tab>
</Tabs>



#### getCommentAnnotations
- Subscribe to the comment annotations for all the specified documents.
- If you don't specify any query, it will return data from the currently set `documents` and `locations`.
- You can specify 30 documents at a time.
- **Params:** (optional) [CommentRequestQuery](/api-reference/sdk/models/data-models#commentrequestquery)
- **Returns:** [GetCommentAnnotationsResponse](/api-reference/sdk/models/data-models#getcommentannotationsresponse)
<Info>
  Avaiable on SDK version 4.0.0 and above.
</Info>
<Tabs>
<Tab title="React / Next.js">

**Using Hooks:**
```jsx
const { data } = useGetCommentAnnotations(query);

useEffect(() => {
  if (data) {
    // initial data value will be null while the request is in progress
    console.log("Comment Annotations:", data);
  }
}, [data]);

```

**Using API:**
```jsx
const commentElement = client.getCommentElement();
commentElement.getCommentAnnotations(query).subscribe((response) => {
  // initial data value will be null while the request is in progress
  console.log("Comment Annotations:", response.data);
});
```

</Tab>

<Tab title="Other Frameworks">
  **Using API:**
```js
const commentElement = Velt.getCommentElement();
commentElement.getCommentAnnotations(query).subscribe((response) => {
  // initial data value will be null while the request is in progress
  console.log("Comment Annotations:", response.data);
});
```
</Tab>
</Tabs>


#### fetchCommentAnnotations

- Fetches comment annotations based on various criteria such as organizationId, folderId, or specific documentIds.
- It supports pagination and filtering options.
- This is different from the existing subscription API which susbcribes to realtime changes to the comments data.
- Params: [FetchCommentAnnotationsRequest](/api-reference/sdk/models/data-models#fetchcommentannotationsrequest)
- Returns: [FetchCommentAnnotationsResponse](/api-reference/sdk/models/data-models#fetchcommentannotationsresponse)

<Tabs>
<Tab title="React / Next.js">
```jsx
// Get all annotations for a specific folder
const commentElement = client.getCommentElement();
const response = await commentElement.fetchCommentAnnotations({
  organizationId: 'org1', 
  folderId: 'folder1',
  allDocuments: true
});

// Get annotations for specific documents
const response = await commentElement.fetchCommentAnnotations({
  organizationId: 'org1',
  documentIds: ['doc1', 'doc2']
});

// Get annotations with filters
const response = await commentElement.fetchCommentAnnotations({
  organizationId: 'org1',
  documentIds: ['doc1', 'doc2'],
  createdAfter: 1234567890,
  statusIds: ['open'],
  pageSize: 20
});
```
</Tab>

<Tab title="Other Frameworks">
```js
// Get all annotations for a specific folder
const commentElement = Velt.getCommentElement();
const response = await commentElement.fetchCommentAnnotations({
  organizationId: 'org1', 
  folderId: 'folder1',
  allDocuments: true
});

// Get annotations for specific documents
const response = await commentElement.fetchCommentAnnotations({
  organizationId: 'org1',
  documentIds: ['doc1', 'doc2']
});

// Get annotations with filters
const response = await commentElement.fetchCommentAnnotations({
  organizationId: 'org1',
  documentIds: ['doc1', 'doc2'],
  createdAfter: 1234567890,
  statusIds: ['open'],
  pageSize: 20
});
```
</Tab>
</Tabs>

#### getSelectedComments

- Get the currently selected comment annotations.
- Returns: [`CommentAnnotation[]`](/api-reference/sdk/models/data-models#commentannotation).


<Tabs>
<Tab title="React / Next.js">

```jsx
const commentElement = client.getCommentElement();
const subscription = commentElement.getSelectedComments().subscribe((selectedComments) => {
  console.log('Selected comments:', selectedComments);
});

```

Unsubscribe from the subscription when you're done:
```jsx
subscription?.unsubscribe()

```

</Tab>

<Tab title="Other Frameworks">

```js
const commentElement = Velt.getCommentElement();
const subscription = commentElement.getSelectedComments().subscribe((selectedComments) => {
  console.log('Selected comments:', selectedComments);
});
```

Unsubscribe from the subscription when you're done:
```js
subscription?.unsubscribe()
```

</Tab>
</Tabs>

#### getCommentAnnotationById

- Retrieve a specific comment annotation by its ID.
- By default, it will return the comment annotation for the current `documentId`.
- If you pass in a `documentId`, it will return the comment annotation for the given `documentId`.
- Returns: [CommentAnnotation](/api-reference/sdk/models/data-models#commentannotation)

<Tabs>
  <Tab title="React / Next.js">
  **Using Hooks:**
    ```jsx
    const annotation = useCommentAnnotationById({
      annotationId: '-O6W3jD0Lz3rxuDuqQFx',  // AnnotationID
      documentId: 'document-id'              // DocumentId (Optional)
    });

    useEffect(() => {
      console.log('annotation', annotation);
    }, [annotation]);
    ```

**Using API:**
    ```javascript
    const commentElement = client.getCommentElement();

    let subscription = commentElement.getCommentAnnotationById({
      annotationId: '-O6W3jD0Lz3rxuDuqQFx',  // AnnotationID
      documentId: 'document-id'              // DocumentId (Optional)
    }).subscribe((annotation) => {
      console.log('annotation', annotation);
    });
    ```

    To unsubscribe from the subscription:
    ```jsx
    subscription?.unsubscribe()
    ```
  </Tab>
  
  <Tab title="Other Frameworks">
    **Using API:**
    ```javascript
    const commentElement = Velt.getCommentElement();

    let subscription = commentElement.getCommentAnnotationById({
      annotationId: '-O6W3jD0Lz3rxuDuqQFx',  // AnnotationID
      documentId: 'document-id'              // DocumentId (Optional)
    }).subscribe((annotation) => {
      console.log('annotation', annotation);
    });
    ```

    To unsubscribe from the subscription:
    ```jsx
    subscription?.unsubscribe()
    ```
  </Tab>
</Tabs>

#### getElementRefByAnnotationId
This will return the Xpath of the DOM element on which the comment was added.
<Tabs>
<Tab title="React / Next.js">

```jsx
const commentElement = client.getCommentElement();
let elementRef = commentElement.getElementRefByAnnotationId('annotationId')

```
</Tab>

<Tab title="Other Frameworks">
```jsx
const commentElement = Velt.getCommentElement();
let elementRef = commentElement.getElementRefByAnnotationId('annotationId')
```
</Tab>
</Tabs>

#### markAsRead

- Mark a comment annotation as read for the current user. This updates the `viewedBy` field of the comment annotation to include the current user.
- Params: `annotationId: string`
- Returns: `Promise<void>`

<Tabs>
<Tab title="React / Next.js">

```jsx
const markAsReadRequest = {
  annotationId: 'ANNOTATION_ID'
};

// Hook
const { markAsRead } = useCommentUtils();
await markAsRead(markAsReadRequest);

// API Method
const commentElement = client.getCommentElement();
await commentElement.markAsRead(markAsReadRequest);
```

</Tab>

<Tab title="Other Frameworks">

```js
const markAsReadRequest = {
  annotationId: 'ANNOTATION_ID'
};

const commentElement = Velt.getCommentElement();
await commentElement.markAsRead(markAsReadRequest);
```

</Tab>
</Tabs>

#### markAsUnread

- Mark a comment annotation as unread for the current user. This removes the current user from the `viewedBy` field of the comment annotation.
- Params: `annotationId: string`
- Returns: `Promise<void>`

<Tabs>
<Tab title="React / Next.js">

```jsx
const markAsUnreadRequest = {
  annotationId: 'ANNOTATION_ID'
};

// Hook
const { markAsUnread } = useCommentUtils();
await markAsUnread(markAsUnreadRequest);

// API Method
const commentElement = client.getCommentElement();
await commentElement.markAsUnread(markAsUnreadRequest);
```

</Tab>

<Tab title="Other Frameworks">

```js
const markAsUnreadRequest = {
  annotationId: 'ANNOTATION_ID'
};

const commentElement = Velt.getCommentElement();
await commentElement.markAsUnread(markAsUnreadRequest);
```

</Tab>
</Tabs>

# Messages

#### addComment

- Add a comment to a specific comment annotation
- Params: [AddCommentRequest](/api-reference/sdk/models/data-models#addcommentrequest)
- Returns: [AddCommentEvent](/api-reference/sdk/models/data-models#addcommentevent)

<Tabs>
<Tab title="React / Next.js">
```jsx
const comment = {
    commentText: 'This is a comment',
    commentHtml: '<p>This is a comment</p>',
};

const addCommentRequest = {
  annotationId: 'ANNOTATION_ID',
  comment: comment
};

// Hook
const { addComment } = useAddComment();
const addCommentEventData = await addComment(addCommentRequest);

// API Method
const commentElement = client.getCommentElement();
const addCommentEventData = await commentElement.addComment(addCommentRequest);
```
</Tab>

<Tab title="Other Frameworks">
```js
const comment = {
    commentText: 'This is a comment',
    commentHtml: '<p>This is a comment</p>',
};

const addCommentRequest = {
  annotationId: 'ANNOTATION_ID',
  comment: comment
};

const commentElement = Velt.getCommentElement();
const addCommentEventData = await commentElement.addComment(addCommentRequest);
```
</Tab>
</Tabs>

#### updateComment

- Update a comment in a specific comment annotation
- Params: [UpdateCommentRequest](/api-reference/sdk/models/data-models#updatecommentrequest)
- Returns: [UpdateCommentEvent](/api-reference/sdk/models/data-models#updatecommentevent)

<Tabs>
<Tab title="React / Next.js">
```jsx
const comment = {
		commentId: 'COMMENT_ID',
    commentText: 'This is a comment',
    commentHtml: '<p>This is a comment</p>',
};

const updateCommentRequest = {
  annotationId: 'ANNOTATION_ID',
  comment: comment
};

// Hook
const { updateComment } = useUpdateComment();
const updateCommentEvent = await updateComment(updateCommentRequest);

// API Method
const commentElement = client.getCommentElement();
const updateCommentEvent = await commentElement.updateComment(updateCommentRequest);
```
</Tab>

<Tab title="Other Frameworks">
```js
const comment = {
		commentId: 'COMMENT_ID',
    commentText: 'This is a comment',
    commentHtml: '<p>This is a comment</p>',
};

const updateCommentRequest = {
  annotationId: 'ANNOTATION_ID',
  comment: comment
};

const commentElement = Velt.getCommentElement();
const updateCommentEvent = await commentElement.updateComment(updateCommentRequest);
```
</Tab>
</Tabs>


#### deleteComment

- Delete a comment from a specific comment annotation
- Params: [DeleteCommentRequest](/api-reference/sdk/models/data-models#deletecommentrequest)
- Returns: [DeleteCommentEvent](/api-reference/sdk/models/data-models#deletecommentevent)

<Tabs>
<Tab title="React / Next.js">
```jsx
const deleteCommentRequest = {
  annotationId: 'ANNOTATION_ID',
  commentId: COMMENT_ID
};

// Hook
const { deleteComment } = useDeleteComment();
const deleteCommentEvent = await deleteComment(deleteCommentRequest);

// API Method
const commentElement = client.getCommentElement();
const deleteCommentEvent = await commentElement.deleteComment(deleteCommentRequest);
```
</Tab>

<Tab title="Other Frameworks">
```js
const deleteCommentRequest = {
  annotationId: 'ANNOTATION_ID',
  commentId: COMMENT_ID
};

const commentElement = Velt.getCommentElement();
const deleteCommentEvent = await commentElement.deleteComment(deleteCommentRequest);
```
</Tab>
</Tabs>

#### getComment

- Get comments from a specific comment annotation
- Params: [GetCommentRequest](/api-reference/sdk/models/data-models#getcommentrequest)
- Returns: [Comment[]](/api-reference/sdk/models/data-models#comment)

<Tabs>
<Tab title="React / Next.js">
```jsx
const getCommentRequest = {
  annotationId: 'ANNOTATION_ID'
};

// Hook
const { getComment } = useGetComment();
const comments = await getComment(getCommentRequest);

// API Method
const commentElement = client.getCommentElement();
const comments = await commentElement.getComment(getCommentRequest);
```
</Tab>

<Tab title="Other Frameworks">
```js
const getCommentRequest = {
  annotationId: 'ANNOTATION_ID'
};

const commentElement = Velt.getCommentElement();
const comments = await commentElement.getComment(getCommentRequest);
```
</Tab>
</Tabs>



#### getUnreadCommentCountOnCurrentDocument
<Tabs>
<Tab title="React / Next.js with Hooks">
You can get the number of unread `Comments` on the current `Document` by using the `useUnreadCommentCountOnCurrentDocument()` hook:

```jsx
const count = useUnreadCommentCountOnCurrentDocument();
useEffect(() => {
  console.log(count, 'countObj')
}, [count])
```
</Tab>
<Tab title="React / Next.js">
You can get the number of unread `Comments` on the current `Document` by using the `getUnreadCommentCountOnCurrentDocument()` method:

```jsx
if (client) {
  const commentElement = client.getCommentElement();
  let subscription = commentElement.getUnreadCommentCountOnCurrentDocument().subscribe((countObj) => {
    console.log(countObj);
  });
}
```

To unsubscribe from the subscription:
```jsx
subscription?.unsubscribe()
```
</Tab>

<Tab title="Other Frameworks">
You can get the number of unread `Comments` on the current `Document` by using the `getUnreadCommentCountOnCurrentDocument()` method:

```jsx
if (Velt) {
  const commentElement = Velt.getCommentElement();
  let subscription = commentElement.getUnreadCommentCountOnCurrentDocument().subscribe((countObj) => {
    console.log(countObj);
  });
}
```

To unsubscribe from the subscription:
```jsx
subscription?.unsubscribe()
```
</Tab>
</Tabs>

#### getUnreadCommentCountByLocationId
<Tabs>
<Tab title="React / Next.js with Hooks">

You can get the number of unread `Comments` by `Location Id` by using the `useUnreadCommentCountByLocationId()` hook:

```jsx
const count = useUnreadCommentCountByLocationId(locationId);
useEffect(() => {
  console.log(count, 'countObj')
}, [count])
```
</Tab>
<Tab title="React / Next.js">
You can get the number of unread `Comments` by `Location Id` by using the `getUnreadCommentCountByLocationId()` method:

```jsx
if (client) {
  const commentElement = client.getCommentElement();
  let subscription = commentElement.getUnreadCommentCountByLocationId(locationId).subscribe((countObj) => {
    console.log(countObj);
  });
}
```

To unsubscribe from the subscription:
```jsx
subscription?.unsubscribe()
```
</Tab>
<Tab title="React / HTML">
You can get the number of unread `Comments` by `Location Id` by using the `getUnreadCommentCountByLocationId()` method:

```jsx
if (Velt) {
  const commentElement = Velt.getCommentElement();
  let subscription = commentElement.getUnreadCommentCountByLocationId(locationId).subscribe((countObj) => {
    console.log(countObj);
  });
}
```

To unsubscribe from the subscription:
```jsx
subscription?.unsubscribe()
```
</Tab>
</Tabs>

#### getUnreadCommentCountByAnnotationId
<Tabs>
<Tab title="React / Next.js with Hooks">

You can get the number of unread `Comments` by annotation id by using the `useUnreadCommentCountByAnnotationId()` hook:

```jsx
const count = useUnreadCommentCountByAnnotationId(annotationId);
useEffect(() => {
   console.log(count, 'countObj')
}, [count])
```
</Tab>
<Tab title="React / Next.js">
You can get the number of unread `Comments` by annotation id by subscribing to the `getUnreadCommentCountByAnnotationId()` method:

```jsx
if (client) {
  const commentElement = client.getCommentElement();
  let subscription = commentElement.getUnreadCommentCountByAnnotationId(annotationId).subscribe((countObj) => {
    console.log(countObj);
  });
}
```

To unsubscribe from the subscription:
```jsx
subscription?.unsubscribe()
```

</Tab>

<Tab title="Other Frameworks">
You can get the number of unread `Comments` by annotation id by subscribing to the `getUnreadCommentCountByAnnotationId()` method:

```jsx
if (Velt) {
  const commentElement = Velt.getCommentElement();
  let subscription = commentElement.getUnreadCommentCountByAnnotationId(annotationId).subscribe((countObj) => {
    console.log(countObj);
  });
}
```

To unsubscribe from the subscription:
```jsx
subscription?.unsubscribe()
```
</Tab>
</Tabs>


# @Mentions

#### assignUser

- Assigns a user to a comment annotation
- Params: [AssignUserRequest](/api-reference/sdk/models/data-models#assignuserrequest)
- Returns: [AssignUserEvent](/api-reference/sdk/models/data-models#assignuserevent)

<Tabs>
<Tab title="React / Next.js">
```jsx
const assignUserRequest = {
  annotationId: 'ANNOTATION_ID',
  assignedTo: {
    userId: 'USER_ID',
    name: 'USER_NAME',
    email: 'USER_EMAIL'
  }
};

// Hook
const { assignUser } = useAssignUser();
const assignUserEventData = await assignUser(assignUserRequest);

// API Method
const commentElement = client.getCommentElement();
const assignUserEventData = await commentElement.assignUser(assignUserRequest);
```
</Tab>

<Tab title="Other Frameworks">
```js
const assignUserRequest = {
  annotationId: 'ANNOTATION_ID',
  assignedTo: {
    userId: 'USER_ID',
    name: 'USER_NAME',
    email: 'USER_EMAIL'
  }
};

const commentElement = Velt.getCommentElement();
const assignUserEventData = await commentElement.assignUser(assignUserRequest);
```
</Tab>
</Tabs>


#### customAutocompleteSearch

- Handle autocomplete search for @mentions. You should use this if you have a large contact list that you want to plug into the autocomplete dropdown, and search directly your own data source.
- Event: [`AutocompleteSearchEvent`](/api-reference/sdk/models/data-models#autocompletesearchevent)

<Tabs>
<Tab title="React / Next.js">
<Steps>
<Step title="Enable the feature">
```jsx
// Enable via props
<VeltComments customAutocompleteSearch={true} />


// Or, enable via Comment Element API
const commentElement = client.getCommentElement();
commentElement.enableCustomAutocompleteSearch();
commentElement.disableCustomAutocompleteSearch();
```
</Step>
<Step title="Set initial list">
```jsx
contactElement.updateContactList(users);
```
</Step>
<Step title="Handle search event">
```jsx
commentElement.on('autocompleteSearch').subscribe(async (inputData) => {
    const searchText = inputData.searchText;

    if (inputData.type === 'contact') {
        const filteredUsersData = await __your_api_call__(searchText);
        contactElement.updateContactList(filteredUsersData, { merge: false });
    }
});

```
</Step>
</Steps>
</Tab>
<Tab title="Other Frameworks">
<Steps>
<Step title="Enable the feature">
```js
// Enable via attribute
<velt-comments custom-autocomplete-search="true"></velt-comments>

// Or, enable via Comment Element API
const commentElement = Velt.getCommentElement();
commentElement.enableCustomAutocompleteSearch();
commentElement.disableCustomAutocompleteSearch();
```
</Step>
<Step title="Set initial list">
```js
contactElement.updateContactList(users);
```
</Step>
<Step title="Handle search event">
```js
commentElement.on('autocompleteSearch').subscribe(async (inputData) => {
    const searchText = inputData.searchText;

    if (inputData.type === 'contact') {
        const filteredUsersData = await __your_api_call__(searchText);
        contactElement.updateContactList(filteredUsersData, { merge: false });
    }
});

```
</Step>
</Steps>
</Tab>
</Tabs>





#### enableAtHere
- This allows you to notify all the users explicitly added to the current document.
- It won't notify users in the organization who are not explicitly added to the document.

Default: Disabled.

![](/gifs/enable-@-here.png)

<Tabs>

<Tab title="React / Next.js">
**Hooks:**
```jsx
const contactElement = useContactUtils();

useEffect(() => {
  contactElement.enableAtHere();
  contactElement.disableAtHere();
}, [contactElement]);

```
**API:**
```jsx
const contactElement = client.getContactElement();
contactElement.enableAtHere();
contactElement.disableAtHere();
```
</Tab>

<Tab title="Other Frameworks">
```jsx
const contactElement = Velt.getContactElement();
contactElement.enableAtHere();
contactElement.disableAtHere();
```
</Tab>
</Tabs>




#### enableUserMentions
- This allows you to enable or disable user @mentions.


Whether user @mentions are enabled.

`Default: true`


<Tabs>
<Tab title="React / Next.js">
Using Props:

```jsx 
<VeltComments userMentions={false} />
```
**Using Hooks:**

```jsx
const contactElement = useContactUtils();

useEffect(() => {
  contactElement.enableUserMentions();
  contactElement.disableUserMentions();
}, [contactElement]);
```
**Using API Method:**
```jsx
const contactElement = client.getContactElement();
contactElement.enableUserMentions();
contactElement.disableUserMentions();
```
</Tab>

<Tab title="Other Frameworks">
**Using props:**
```jsx 
<velt-comments user-mentions="false"></velt-comments>
```
**Using API Method:**
```jsx
const commentElement = Velt.getCommentElement();
commentElement.enableUserMentions(); // to enable user mentions
commentElement.disableUserMentions(); // to disable user mentions
```
</Tab>
</Tabs>


#### expandMentionGroups
- Expand the user groups and show individual users inside the groups in the @mentions dropdown menu.
<Tabs>
<Tab title="React / Next.js">
```jsx
<VeltComments expandMentionGroups={true} />
```
</Tab>
<Tab title="Other Frameworks">
```html
<velt-comments expand-mention-groups="true"></velt-comments>
```
</Tab>
</Tabs>

#### getContactList
- Subscribe to the list of users added to organization, folder, document, user groups or the ones overwritten using the `updateContactList` API.
- **Params:** none
- **Returns:** [GetContactListResponse](/api-reference/sdk/models/data-models#getcontactlistresponse)

<Tabs>
<Tab title="React / Next.js">
**Using Hooks:**
```jsx
const contactList = useContactList();
console.log(contactList); // initial value will be null
```
**Using API:**
```jsx
const contactElement = useContactUtils();
contactElement.getContactList().subscribe((response) => {
  console.log(response); // initial value will be null
});
```
</Tab>
<Tab title="Other Frameworks">
```js
const contactElement = Velt.getContactElement();
contactElement.getContactList().subscribe((response) => {
  console.log(response); // initial value will be null
});
```
</Tab>
</Tabs>


#### onContactSelected
- This event is triggered when a contact is selected from the contact dropdown in the Comment Dialog.
- Use the event object to determine if the selected contact has access to the document using fields like `isOrganizationContact`, `isDocumentContact` and `documentAccessType`.
- If the selected contact doesn't have access to the document, you can show an invite dialog to the user to invite the contact to the document.

The returned data will be in the following schema:
```jsx
export class UserContactSelectedPayload {
    contact!: UserContact; // Selected Contact.
    isOrganizationContact!: boolean; // Is user part of organization contact.
    isDocumentContact!: boolean; // Is user part of document contact.
    documentAccessType!: string; // Document access type.
}
```

<Tabs>
<Tab title="React / Next.js">
**Using Hooks:**
```jsx
const selectedContact = useContactSelected();

useEffect(() => {
  console.log('selectedContact: ', selectedContact);
}, [selectedContact]);

```
**Using API:**
```jsx
const contactElement = client.getContactElement();

contactElement.onContactSelected().subscribe((selectedContact: any) => {
  console.log('selectedContact : ', selectedContact);
});
```
</Tab>

<Tab title="Other Frameworks">
```jsx
const contactElement = Velt.getContactElement();

contactElement.onContactSelected().subscribe((selectedContact: any) => {
  console.log('selectedContact: ', selectedContact);
});
```
</Tab>
</Tabs>


#### setAtHereLabel
- This allows you to modify the default text of the @here feature. eg: @all, @everyone, @team, etc.

<Tabs>
<Tab title="React / Next.js">
**Using Props:**
```jsx
<VeltComments atHereLabel='@all'>
```

**Using Hooks:**
```jsx
const contactElement = useContactUtils();

useEffect(() => {
  contactElement.setAtHereLabel('@all');
}, [contactElement]);
```

**Using API Method:**

```jsx
const contactElement = client.getContactElement();
contactElement.setAtHereLabel('@all');
```
</Tab>

<Tab title="Other Frameworks">
**Using Props:**
```jsx
<velt-comments at-here-label="@all">
```

**Using API Method:**
```jsx
const contactElement = Velt.getContactElement();
contactElement.setAtHereLabel('@all');
```
</Tab>
</Tabs>


#### setAtHereDescription
- Customize the description that appears for the @here mention.

<Tabs>
<Tab title="React / Next.js">
**Using Props:**
```jsx
<VeltComments atHereDescription="Notify all users in this document" />
```

**Using Hooks:**
```jsx
const contactElement = useContactUtils();

useEffect(() => {
  contactElement.setAtHereDescription('Notify all users in this document');
}, [contactElement]);
```

**Using API Method:**
```jsx
const contactElement = client.getContactElement();
contactElement.setAtHereDescription('Notify all users in this document');
```

</Tab>

<Tab title="Other Frameworks">

**Using Props:**
```html
<velt-comments at-here-description="Notify all users in this document"></velt-comments>
```

**Using API Method:**
```javascript
const contactElement = Velt.getContactElement();
contactElement.setAtHereDescription('Notify all users in this document');
```
</Tab>
</Tabs>


#### showMentionGroupsFirst
- Show the user groups in the @mentions dropdown menu before the non-group users.
<Tabs>
<Tab title="React / Next.js">
```jsx
<VeltComments showMentionGroupsFirst={true} />
```
</Tab>
<Tab title="Other Frameworks">
```html
<velt-comments show-mention-groups-first="true"></velt-comments>
```
</Tab>
</Tabs>

#### showMentionGroupsOnly
- Show only the user groups in the @mentions dropdown menu and not the non-group users.
<Tabs>
<Tab title="React / Next.js">
```jsx
<VeltComments showMentionGroupsOnly={true} />
```
</Tab>
<Tab title="Other Frameworks">
```html
<velt-comments show-mention-groups-only="true"></velt-comments>
```
</Tab>
</Tabs>




#### subscribeCommentAnnotation

- Subscribes to a comment annotation
- Params: [SubscribeCommentAnnotationRequest](/api-reference/sdk/models/data-models#subscribecommentannotationrequest)
- Returns: [SubscribeCommentAnnotationEvent](/api-reference/sdk/models/data-models#subscribecommentannotationevent)

<Tabs>
<Tab title="React / Next.js">
```jsx
const subscribeCommentAnnotationRequest = {
  annotationId: 'ANNOTATION_ID'
};

// Hook
const { subscribeCommentAnnotation } = useSubscribeCommentAnnotation();
const subscribeCommentAnnotationEvent = await subscribeCommentAnnotation(subscribeCommentAnnotationRequest);

// API Method
const commentElement = client.getCommentElement();
const subscribeCommentAnnotationEvent = await commentElement.subscribeCommentAnnotation(subscribeCommentAnnotationRequest);
```
</Tab>

<Tab title="Other Frameworks">
```js
const subscribeCommentAnnotationRequest = {
  annotationId: 'ANNOTATION_ID'
};

const commentElement = Velt.getCommentElement();
const subscribeCommentAnnotationEvent = await commentElement.subscribeCommentAnnotation(subscribeCommentAnnotationRequest);
```
</Tab>
</Tabs>

#### unsubscribeCommentAnnotation

- Unsubscribes from a comment annotation
- Params: [UnsubscribeCommentAnnotationRequest](/api-reference/sdk/models/data-models#unsubscribecommentannotationrequest)
- Returns: [UnsubscribeCommentAnnotationEvent](/api-reference/sdk/models/data-models#unsubscribecommentannotationevent)

<Tabs>
<Tab title="React / Next.js">
```jsx
const unsubscribeCommentAnnotationRequest = {
  annotationId: 'ANNOTATION_ID'
};

// Hook
const { unsubscribeCommentAnnotation } = useUnsubscribeCommentAnnotation();
const unsubscribeCommentAnnotationEvent = await unsubscribeCommentAnnotation(unsubscribeCommentAnnotationRequest);

// API Method
const commentElement = client.getCommentElement();
const unsubscribeCommentAnnotationEvent = await commentElement.unsubscribeCommentAnnotation(unsubscribeCommentAnnotationRequest);
```
</Tab>

<Tab title="Other Frameworks">
```js
const unsubscribeCommentAnnotationRequest = {
  annotationId: 'ANNOTATION_ID'
};

const commentElement = Velt.getCommentElement();
const unsubscribeCommentAnnotationEvent = await commentElement.unsubscribeCommentAnnotation(unsubscribeCommentAnnotationRequest);
```
</Tab>
</Tabs>


#### updateContactList
- By default, the contact list is generated using the users in the organization and the document.
- However, if you do not want to use that feature or want to provide a custom list of contacts, you can use this method.
- By default, it will overwrite the current contact list. You can merge the provided contacts with the existing list by passing the merge flag as `{merge:true}`.
- This method will only update the contact list in the current user session. It doens't update the user contacts in the database or change the access control.

<Tabs>
<Tab title="React / Next.js">
**Using Hooks:**
```jsx
const contactElement = useContactUtils();

useEffect(() => {
  contactElement.updateContactList([{userId: 'userId1', name: 'User Name', email: 'user1@velt.dev'}], {merge: false});
}, [contactElement]);

```
**Using API:**
```jsx
const contactElement = client.getContactElement();
contactElement.updateContactList([{userId: 'userId1', name: 'User Name', email: 'user1@velt.dev'}], {merge: false});
```
</Tab>

<Tab title="Other Frameworks">
```jsx
const contactElement = Velt.getContactElement();
contactElement.updateContactList([{userId: 'userId1', name: 'User Name', email: 'user1@velt.dev'}], {merge: false});
```
</Tab>
</Tabs>


#### updateContactListScopeForOrganizationUsers
- Sometimes you may want to show only certain types of contacts in the contact dropdown.
- By default, organization users will see all contacts in the organization, any user groups and any contacts added to the document.
- Using this method, you can restrict the contacts shown in the dropdown to only certain types.
- This only affects the Organization Users and not the Document Users. Document Users will always only see contacts added to the document.

Here are the available options:
* `all`: Show all the contacts
* `organization`: Show organization contacts.
* `organizationUserGroup`: Show organization user groups.
* `document`: Show document contacts.


<Tabs>
<Tab title="React / Next.js">
```jsx
const contactElement = client.getContactElement();
contactElement.updateContactListScopeForOrganizationUsers(['all', 'organization', 'organizationUserGroup', 'document']);
```
</Tab>

<Tab title="Other Frameworks">
```jsx
const contactElement = Velt.getContactElement();
contactElement.updateContactListScopeForOrganizationUsers(['all', 'organization', 'organizationUserGroup', 'document']);
```
</Tab>
</Tabs>


# Metadata

#### addContext
Custom metadata allows you to add extra information to comments, enhancing their functionality. Here's what you can do with it:

- Render additional data on comments
- Position comment pins manually
- Create custom UI components
- Enable comment filtering on custom data

To add custom metadata, use the `event.addContext()` method when a comment is added. This method accepts an object with key-value pairs.

![](/images/addContext.png)

<Tabs>
<Tab title="React / Next.js">
```jsx
// Hook
const commentEventCallbackData = useCommentEventCallback('addCommentAnnotation');
useEffect(() => {
  if (commentEventCallbackData) {
    commentEventCallbackData.addContext({ customKey: 'customValue' });
  }
}, [commentEventCallbackData]);

// API Method
const commentElement = client.getCommentElement();
commentElement.on('addCommentAnnotation').subscribe((event) => {
    event.addContext({ customKey: 'customValue' });
});

```
</Tab>

<Tab title="Other Frameworks">
```js
const commentElement = Velt.getCommentElement();
commentElement.on('addCommentAnnotation').subscribe((event) => {
    event.addContext({ customKey: 'customValue' });
});
```
</Tab>
</Tabs>

#### updateContext
- Update the custom metadata associated with a comment annotation using the `updateContext` method.
- Utilize this method to update the context of a comment annotation at any time. For example, you might use this when the name of the dashboard containing the comment annotation changes.

The `commentElement.updateContext()` method accepts three parameters:
- The Comment Annotation ID
- The new metadata object
- An optional `updateContextConfig` object. Specify how the new metadata should be applied:
  - `{ merge: true }`: Merges the new metadata with the existing metadata
  - `{ merge: false }` or omitted: Replaces the existing metadata entirely (default behavior)

<Tabs>
<Tab title="React / Next.js">

Using API:
```js

const updatedContext = { customKey: 'customValue' };
const updateContextConfig = { merge: true };

const commentElement = client.getCommentElement();
commentElement.updateContext(COMMENT_ANNOTATION_ID, updatedContext, updateContextConfig);
```
</Tab>

<Tab title="Other Frameworks">

Using API method:
```js
const updatedContext = { customKey: 'customValue' };
const updateContextConfig = { merge: true };

const commentElement = client.getCommentElement();
commentElement.updateContext(COMMENT_ANNOTATION_ID, updatedContext, updateContextConfig);
```
</Tab>
</Tabs>

## Aggregation

### Overview

**Aggregation** lets you filter, group, and render comments that match specific criteria â€” without writing any custom logic.  
It's especially powerful when comments are tied to structured data such as products, categories, or financial entities.

You can group comments by:

- Metadata (`context`)
- Element IDs (`targetElementId`)
- Resource identifiers (`documentId`, `folderId`, `locationId`)

In short: aggregation helps you **query comments like data**.

---

### When to Use Aggregation

Use aggregation when your app involves complex relationships or taxonomy-based filtering.

#### ðŸ§© Tables & Dashboards

**Supply Chain Example**  
A product can belong to multiple categories. When viewing data by category, you may want to display all comments made on products within that category â€” or even across product variants.

**Financial Planning Example**  
A budget item (e.g., _Marketing Q1_) can have multiple subcategories (e.g., _Paid Ads_, _Sponsorships_).  
Aggregation allows you to show all comments related to a specific period, department, or account group â€” even if those comments live across different documents or views.

---

### How It Works

#### Comment Metadata Fields

Each comment can include one or more of the following identifiers or metadata fields:

| Field | Description |
|--------|--------------|
| `folderId` | Target folder ID |
| `documentId` | Target document ID |
| `locationId` | Target location ID |
| `targetElementId` | Target DOM element ID |
| `context` | Custom metadata object for grouping or filtering |

---

#### Comment Creation

When you use any of the above identifiers or metadata fields in the following supported components, they automatically get **attached to the comment** at the time it's created.  
This ensures that each comment carries the correct folder, document, element, or context metadata â€” so it can later be filtered or grouped accurately.

**Supported Components**

- Inline Comments Section  
- Comment Tool

<Tabs>
<Tab title="React / Next.js">
```jsx
// Comment Tool with context metadata
<VeltCommentTool
  targetElementId="cell-jan-cheese-zurich"
  context={{
    month: "jan",
    year: "2024",
    product: "cheese",
    location: "zurich"
  }}
/>

// Inline Comments Section with context
<VeltInlineCommentsSection
  targetElementId="budget-item-marketing-q1"
  context={{
    department: "marketing",
    quarter: "Q1",
    category: "paid-ads"
  }}
/>
```
</Tab>
<Tab title="Other Frameworks">
```html
<!-- Comment Tool with context metadata -->
<velt-comment-tool
  target-element-id="cell-jan-cheese-zurich"
  context='{
    "month": "jan",
    "year": "2024",
    "product": "cheese",
    "location": "zurich"
  }'
>
</velt-comment-tool>

<!-- Inline Comments Section with context -->
<velt-inline-comments-section
  target-element-id="budget-item-marketing-q1"
  context='{
    "department": "marketing",
    "quarter": "Q1",
    "category": "paid-ads"
  }'
>
</velt-inline-comments-section>
```
</Tab>
</Tabs>

---

#### Comment Rendering

When the above identifiers or metadata fields are passed to the following rendering components, they determine **which comments are displayed**.  
Only comments that match the provided folder, document, element, or context values will be rendered in that component.

**Supported Components**

- Comment Bubble  
- Inline Comments Section  
- Comment Pin (Standalone) â€” _does not support_ `targetElementId`

<Tabs>
<Tab title="React / Next.js">
```jsx
// Comment Bubble - filter by context
<VeltCommentBubble
  context={{ product: "cheese" }}
  contextOptions={{ partialMatch: true }}
/>

// Comment Bubble - filter by target element
<VeltCommentBubble targetElementId="cell-jan-cheese-zurich" />

// Inline Comments Section - filter by context
<VeltInlineCommentsSection
  context={{ department: "marketing" }}
  contextOptions={{ partialMatch: true }}
/>

// Comment Pin - filter by context (no targetElementId support)
<VeltCommentPin
  context={{ product: "cheese", month: "jan" }}
/>
```
</Tab>
<Tab title="Other Frameworks">
```html
<!-- Comment Bubble - filter by context -->
<velt-comment-bubble
  context='{ "product": "cheese" }'
  context-options='{ "partialMatch": true }'
>
</velt-comment-bubble>

<!-- Comment Bubble - filter by target element -->
<velt-comment-bubble target-element-id="cell-jan-cheese-zurich">
</velt-comment-bubble>

<!-- Inline Comments Section - filter by context -->
<velt-inline-comments-section
  context='{ "department": "marketing" }'
  context-options='{ "partialMatch": true }'
>
</velt-inline-comments-section>

<!-- Comment Pin - filter by context (no targetElementId support) -->
<velt-comment-pin
  context='{ "product": "cheese", "month": "jan" }'
>
</velt-comment-pin>
```
</Tab>
</Tabs>

---

### Filtering Behavior

When filtering comments, only annotations matching **all provided fields** will be shown:

```
folderId
documentId
locationId
targetElementId
context
```

---

### `Context` Matching

You can choose between two matching modes for the `context` field: **Full Match** (default) or **Partial Match**.

---

#### ðŸ”’ Full Match (Default)

A comment matches **only if all fields** in its context exactly match your filter criteria.

**Example:**

```js
// Comment context
{ month: "jan", product: "cheese", location: "zurich" }

// Filters
{ month: "jan", product: "cheese", location: "zurich" }  âœ… Matches
{ month: "jan", product: "cheese" }                      âŒ No match (missing field)
{ month: "jan", product: "cheese", year: "2024" }        âŒ No match (extra field)
```

<Tabs>
<Tab title="React / Next.js">
```jsx
// Full match (default)
<VeltCommentBubble
  context={{ month: "jan", product: "cheese", location: "zurich" }}
/>
```
</Tab>
<Tab title="Other Frameworks">
```html
<!-- Full match (default) -->
<velt-comment-bubble
  context='{ "month": "jan", "product": "cheese", "location": "zurich" }'
>
</velt-comment-bubble>
```
</Tab>
</Tabs>

---

#### ðŸ” Partial Match

Enable partial matching with `contextOptions={{ partialMatch: true }}`.

A comment matches if **all fields in your filter exist in the comment's context**.  
Extra fields in the comment context don't prevent a match.

**Example:**

```js
// Comment context
{ day: "01", week: "01", month: "jan", product: "cheese", location: "zurich" }

// Filters
{ product: "cheese" }                   âœ… Matches
{ day: "01", product: "cheese" }        âœ… Matches
{ product: "cheese", category: "dairy"} âŒ No match (missing field)
```

**Example**

<Tabs>
<Tab title="React / Next.js">
```jsx
{/* Comment Bubble with Partial Match */}
<VeltCommentBubble
  context={{ product: "cheese" }}
  contextOptions={{ partialMatch: true }}
/>

{/* Comment Tool with Partial Match */}
<VeltCommentTool
  targetElementId="element_id"
  context={{ product: "cheese" }}
  contextOptions={{ partialMatch: true }}
/>
```
</Tab>
<Tab title="Other Frameworks">
```html
<!-- Comment Bubble with Partial Match -->
<velt-comment-bubble
  context='{ "product": "cheese" }'
  context-options='{ "partialMatch": true }'
>
</velt-comment-bubble>

<!-- Comment Tool with Partial Match -->
<velt-comment-tool
  target-element-id="element_id"
  context='{ "product": "cheese" }'
  context-options='{ "partialMatch": true }'
>
</velt-comment-tool>
```
</Tab>
</Tabs>

---

### Grouping Matched Comment Annotations

When multiple comments match your filter criteria, you can **group them** into a single visual element â€” such as a Comment Bubble, Comment Pin, or Inline Comments Section â€” for a cleaner, multi-threaded UI.

**How it works:**

- Enable grouping globally with `groupMatchedComments`
- All matching annotations are shown as one grouped thread
- The comment count shows total grouped annotations
- Users can expand to view and interact with all related threads

**Example**

If there are three comments for `"product: cheese"` across different months, they can all appear in one Comment Bubble when you filter by `{ product: "cheese" }`.

<Tabs>
<Tab title="React / Next.js">
```jsx
// Enable grouping globally
<VeltComments groupMatchedComments={true} />

// Grouped Comment Bubble
<VeltCommentBubble
  context={{ product: "cheese" }}
  contextOptions={{ partialMatch: true }}
/>

// Enable/disable via API
const commentElement = client.getCommentElement();
commentElement.enableGroupMatchedComments();
commentElement.disableGroupMatchedComments();
```
</Tab>
<Tab title="Other Frameworks">
```html
<!-- Enable grouping globally -->
<velt-comments group-matched-comments="true"></velt-comments>

<!-- Grouped Comment Bubble -->
<velt-comment-bubble
  context='{ "product": "cheese" }'
  context-options='{ "partialMatch": true }'
  comment-count-type="total"
>
</velt-comment-bubble>

<script>
  const commentElement = Velt.getCommentElement();
  commentElement.enableGroupMatchedComments();
  commentElement.disableGroupMatchedComments();
</script>
```
</Tab>
</Tabs>

---

# Custom Lists

#### createCustomListDataOnAnnotation
- Add a custom dropdown list at the Comment Annotation level. 
- Use this to add custom tags or categories to the comment.

![](/images/customization/comment-annotation-custom-list.png)

```jsx
let customList = [
    { id: 'violent', label: 'Violent' },
    { id: 'inappropriate', label: 'Inappropriate' },
    { id: 'robbery', label: 'Robbery' },
    { id: 'nsfw', label: 'NSFW' },
];

const customListDataOnCommentAnnotation = {
	  type: 'multi', // choose from 'multi' or 'single'
    placeholder: 'Select a category',
    data: customList, // your customList data here
};
```

<Tabs>
<Tab title="React / Next.js with hooks">
**Using Props:**
```jsx	
<VeltComments customListDataOnAnnotation={customListDataOnCommentAnnotation} />
```

**API Method:**
```jsx
const commentElement = useCommentUtils();		
commentElement.createCustomListDataOnAnnotation(customListDataOnCommentAnnotation);
```

</Tab>

<Tab title="React / Next.js">
**Using Props:**
```jsx	
<VeltComments customListDataOnAnnotation={customListDataOnCommentAnnotation} />
```

**API Method:**
```jsx
const commentElement = client.getCommentElement();		
commentElement.createCustomListDataOnAnnotation(customListDataOnCommentAnnotation);
```
</Tab>

<Tab title="Other Frameworks">
```jsx
const commentElement = Velt.getCommentElement();			
commentElement.createCustomListDataOnAnnotation(customListDataOnCommentAnnotation);
```
</Tab>
</Tabs>


#### createCustomListDataOnComment
You can have custom dropdown lists appear when certain `hotkeys` are pressed.

When you press a hotkey inside the Comment Dialog composer, it will open a dropdown list of items that you can select.

![](/images/customization/custom-list-1.png)

Selecting an item frop the dropdown list will add a chip that inside the comment text.

![](/images/customization/custom-list-2.png)

<Tip>
Grouped lists: Useful for workflows like issue trackers (e.g., group by "Priority" or "Status"), allowing users to quickly refer and insert custom entities from your app. With this feature, you can combine multiple entity types into one drop down just like Linear.
</Tip>

<Warning>Make sure the hotkey is a single character such as `#` or `/`.</Warning>

The items in the list must be in the following schema:

<Note>
Use `AutocompleteGroup` only for grouped lists. For flat lists, do not include `groups` on the config object or `groupId` on items.
</Note>

```jsx
export class AutocompleteGroup {
    id!: string;
    name!: string;
}

export class AutocompleteItem {
    id!: string; // Unique identifier
    name!: string; // Item name. This appears as the main item text in the UI.
    description?: string; // Item description. This appears as the secondary item text in the UI.
    icon?: { url?: string; svg?: string }; // Item icon. Either URL or inline SVG.
    link?: string; // Item link. You can use this to open a link when the item is clicked. Check the event listener below for more details.
    groupId?: string; // Optional: assigns item to a group (by AutocompleteGroup.id)
}
```

##### **Flat List Implementation**

```jsx
let customList = [
  { id: '1', name: 'File 1', description: 'File Description 1', icon: { url: 'https://cdn-icons-png.flaticon.com/512/9496/9496432.png' } },
  { id: '2', name: 'File 2', description: 'File Description 2', icon: { url: 'https://cdn-icons-png.flaticon.com/512/11471/11471469.png' } },
  { id: '3', name: 'File 3', description: 'File Description 3', icon: { url: 'https://cdn-icons-png.flaticon.com/512/2656/2656402.png' } }
];

const customListDataOnComment = {
	hotkey: 'UNIQUE_HOTKEY', // only single charater is allowed. eg: '#'
	type: 'custom',
    data: customList, // your customList data here
};
```

<Tabs>
<Tab title="React / Next.js with Hooks">
```jsx
// Using Props
<VeltComments customListDataOnComment={customListDataOnComment} />

// Hook
const commentElement = useCommentUtils();
commentElement.createCustomListDataOnComment(customListDataOnComment);
```
</Tab>
<Tab title="React / Next.js">
```jsx
// Using Props
<VeltComments customListDataOnComment={customListDataOnComment} />

// Hook
const commentElement = client.getCommentElement();
commentElement.createCustomListDataOnComment(customListDataOnComment);
```
</Tab>

<Tab title="Other Frameworks">
```jsx
const commentElement = Velt.getCommentElement();
commentElement.createCustomListDataOnComment(customListDataOnComment);
```
</Tab>
</Tabs>

##### **Grouped List Implementation**

```ts
const customListWithGroups = {
  hotkey: '$',
  type: 'custom',
  groups: [
    { id: 'categories', name: 'Categories' },
    { id: 'priorities', name: 'Priorities' }
  ],
  data: [
    // Categories group
    { id: 'bug_1', name: 'Bug 1', description: 'Bug report 1', groupId: 'categories', icon: { svg: '<svg></svg>' } },
    { id: 'feature_2', name: 'Feature Request 2', description: 'New feature 2', groupId: 'categories', icon: { url: 'https://random.png' } },
    // Priorities group
    { id: 'high_1', name: 'High Priority 1', description: 'Urgent task 1', groupId: 'priorities', icon: { url: 'https://random.png' } },
    { id: 'medium_2', name: 'Medium Priority 2', description: 'Normal task 2', groupId: 'priorities', icon: { svg: '<svg></svg>' } },
    // Ungrouped items
    { id: 'misc_1', name: 'Miscellaneous 1', description: 'Other items 1', icon: { url: 'https://random.png' } },
    { id: 'note_2', name: 'Note 2', description: 'General note 2', icon: { svg: '<svg></svg>' } }
  ]
};
```

<Tabs>
<Tab title="React / Next.js with Hooks">
```ts
// Using Props
<VeltComments customListDataOnComment={customListWithGroups} />

// Hook
const commentElement = useCommentUtils();
commentElement.createCustomListDataOnComment(customListWithGroups);
```
</Tab>
<Tab title="React / Next.js">
```ts
const commentElement = client.getCommentElement();
commentElement.createCustomListDataOnComment(customListWithGroups);
```
</Tab>
<Tab title="Other Frameworks">
```js
const commentElement = Velt.getCommentElement();
commentElement.createCustomListDataOnComment(customListWithGroups);
```
</Tab>
</Tabs>

##### **Listen to click events on chips**

After the comment is saved, the item will be rendered as a chip on the comment content. When the user clicks on it, you will get an event callback with the data of the clicked chip (`AutocompleteItem`).

<Info>This event will also be triggered when the user clicks on the contact chips added via the @mentions feature.</Info>

<Tabs>
<Tab title="React / Next.js with Hooks">
```jsx
let autocompleteChipData = useAutocompleteChipClick(); 
```
</Tab>

<Tab title="React / Next.js">
```jsx
const autocompleteElement = client.getAutocompleteElement();
const subscription = autocompleteElement.onAutocompleteChipClick().subscribe((_data) => {
  console.log(_data);
});
```
To unsubscribe from the subscription:
```jsx
subscription?.unsubscribe()
```
</Tab>

<Tab title="Other Frameworks">
```jsx
const autocompleteElement = Velt.getAutocompleteElement();
const subscription = autocompleteElement.onAutocompleteChipClick().subscribe((_data) => {
  console.log(_data);
});
```
To unsubscribe from the subscription:
```jsx
subscription?.unsubscribe()
```
</Tab>
</Tabs>


#### customAutocompleteSearch

- Handle autocomplete search for custom list. You should use this if you have a large list that you want to plug into the autocomplete dropdown, and search directly your own data source.
- Event: [`AutocompleteSearchEvent`](/api-reference/sdk/models/data-models#autocompletesearchevent)

<Tabs>
<Tab title="React / Next.js">
<Steps>
<Step title="Enable the feature">
```jsx
// Enable via props
<VeltComments customAutocompleteSearch={true} />


// Or, enable via Comment Element API
const commentElement = client.getCommentElement();
commentElement.enableCustomAutocompleteSearch();
commentElement.disableCustomAutocompleteSearch();
```
</Step>
<Step title="Set initial list">
```jsx
// For @mentions feature
contactElement.updateContactList(users);

// For custom list feature
commentElement.createCustomListDataOnComment({
    hotkey: "#",
    type: "custom",
    data: customListData,
});
```
</Step>
<Step title="Handle search event">
```jsx
commentElement.on('autocompleteSearch').subscribe(async (inputData) => {
    const searchText = inputData.searchText;

    // For @mentions feature
    if (inputData.type === 'contact') {
        const filteredUsersData = await __your_api_call__(searchText);
        contactElement.updateContactList(filteredUsersData, { merge: false });
    }

    // For custom list feature
    if (inputData.type === 'custom') {
        const filteredListData = await __your_api_call__(searchText, autocompleteData);
        commentElement.createCustomListDataOnComment({
            hotkey: "#",
            type: "custom",
            data: filteredListData,
        });
    }
});

```
</Step>
</Steps>
</Tab>
<Tab title="Other Frameworks">
<Steps>
<Step title="Enable the feature">
```js
// Enable via attribute
<velt-comments custom-autocomplete-search="true"></velt-comments>

// Or, enable via Comment Element API
const commentElement = Velt.getCommentElement();
commentElement.enableCustomAutocompleteSearch();
commentElement.disableCustomAutocompleteSearch();
```
</Step>
<Step title="Set initial list">
```js
commentElement.createCustomListDataOnComment({
    hotkey: "#",
    type: "custom",
    data: customListData,
});
```
</Step>
<Step title="Handle search event">
```js
commentElement.on('autocompleteSearch').subscribe(async (inputData) => {
    const searchText = inputData.searchText;

    if (inputData.type === 'custom') {
        const filteredListData = await __your_api_call__(searchText, autocompleteData);
        commentElement.createCustomListDataOnComment({
            hotkey: "#",
            type: "custom",
            data: filteredListData,
        });
    }
});

```
</Step>
</Steps>
</Tab>
</Tabs>



# Event Subscription

### [on](/api-reference/sdk/api/api-methods#on)

Subscribe to Comment Events. Here is the list of events you can subscribe to and the event objects you will receive.

| Category | Event Type | Description | Event Object |
|----------|------------|-------------|--------------|
| Threads | `addCommentAnnotation` | Add a new comment annotation | [AddCommentAnnotationEvent](/api-reference/sdk/models/data-models#addcommentannotationevent) |
| Threads | `deleteCommentAnnotation` | Delete a comment annotation | [DeleteCommentAnnotationEvent](/api-reference/sdk/models/data-models#deletecommentannotationevent) |
| Messages | `addComment` | Add a new comment | [AddCommentEvent](/api-reference/sdk/models/data-models#addcommentevent) |
| Messages | `updateComment` | Update an existing comment | [UpdateCommentEvent](/api-reference/sdk/models/data-models#updatecommentevent) |
| Messages | `deleteComment` | Delete a comment | [DeleteCommentEvent](/api-reference/sdk/models/data-models#deletecommentevent) |
| @Mentions | `assignUser` | Assign a user to a comment | [AssignUserEvent](/api-reference/sdk/models/data-models#assignuserevent) |
| @Mentions | `subscribeCommentAnnotation` | Subscribe to a comment annotation | [SubscribeCommentAnnotationEvent](/api-reference/sdk/models/data-models#subscribecommentannotationevent) |
| @Mentions | `unsubscribeCommentAnnotation` | Unsubscribe from a comment annotation | [UnsubscribeCommentAnnotationEvent](/api-reference/sdk/models/data-models#unsubscribecommentannotationevent) |
| @Mentions | `autocompleteSearch` | When user starts searching for a contact in the @mentions dropdown or for a list item in the custom list dropdown | [AutocompleteSearchEvent](/api-reference/sdk/models/data-models#autocompletesearchevent) |
| Attachments | `addAttachment` | Add an attachment to a comment | [AddAttachmentEvent](/api-reference/sdk/models/data-models#addattachmentevent) |
| Attachments | `deleteAttachment` | Delete an attachment from a comment | [DeleteAttachmentEvent](/api-reference/sdk/models/data-models#deleteattachmentevent) |
| Reactions | `addReaction` | Add a reaction to a comment | [AddReactionEvent](/api-reference/sdk/models/data-models#addreactionevent) |
| Reactions | `deleteReaction` | Delete a reaction from a comment | [DeleteReactionEvent](/api-reference/sdk/models/data-models#deletereactionevent) |
| Reactions | `toggleReaction` | Toggle a reaction on a comment | [ToggleReactionEvent](/api-reference/sdk/models/data-models#togglereactionevent) |
| Status & Priority | `updateStatus` | Update the status of a comment | [UpdateStatusEvent](/api-reference/sdk/models/data-models#updatestatusevent) |
| Status & Priority | `resolveComment` | Resolve a comment | [ResolveCommentEvent](/api-reference/sdk/models/data-models#resolvecommentevent) |
| Status & Priority | `updatePriority` | Update the priority of a comment | [UpdatePriorityEvent](/api-reference/sdk/models/data-models#updatepriorityevent) |
| Status & Priority | `approveCommentAnnotation` | Approve a comment annotation | [ApproveCommentAnnotationEvent](/api-reference/sdk/models/data-models#approvecommentannotationevent) |
| Status & Priority | `acceptCommentAnnotation` | Accept a comment annotation | [AcceptCommentAnnotationEvent](/api-reference/sdk/models/data-models#acceptcommentannotationevent) |
| Status & Priority | `rejectCommentAnnotation` | Reject a comment annotation | [RejectCommentAnnotationEvent](/api-reference/sdk/models/data-models#rejectcommentannotationevent) |
| Recordings | `deleteRecording` | Delete a recording from a comment | [DeleteRecordingEvent](/api-reference/sdk/models/data-models#deleterecordingevent) |
| Deep Links | `copyLink` | Copy a deep link to a comment | [CopyLinkEvent](/api-reference/sdk/models/data-models#copylinkevent) |
| Access | `updateAccess` | Update access settings for a comment | [UpdateAccessEvent](/api-reference/sdk/models/data-models#updateaccessevent) |
| Comment Sidebar | `commentSidebarDataInit` | Triggered when comment sidebar data is first loaded | [CommentSidebarDataInitEvent](/api-reference/sdk/models/data-models#commentsidebardatainitevent) |
| Comment Sidebar | `commentSidebarDataUpdate` | Triggered when comment sidebar data is updated | [CommentSidebarDataUpdateEvent](/api-reference/sdk/models/data-models#commentsidebardataupdateevent) |
| UI | `composerClicked` | Triggered when comment composer is clicked | [ComposerClickedEvent](/api-reference/sdk/models/data-models#composerclickedevent) |
| UI | `commentPinClicked` | Triggered when a comment pin is clicked | [CommentPinClickedEvent](/api-reference/sdk/models/data-models#commentpinclickedevent) |
| UI | `linkClicked` | Triggered when a clickable link in comment content is clicked | [LinkClickedEvent](/api-reference/sdk/models/data-models#linkclickedevent) |
| Recorder | `transcriptionDone` | Triggered when a transcription is generated and ready | [TranscriptionDoneEvent](/api-reference/sdk/models/data-models#transcriptiondoneevent) |

<Tabs>
<Tab title="React / Next.js">
```jsx
// Hook
const commentEventCallbackData = useCommentEventCallback('addCommentAnnotation');
useEffect(() => {
  if (commentEventCallbackData) {
    // Handle comment action callback event response
  }
}, [commentEventCallbackData]);

// API Method
const commentElement = client.getCommentElement();
commentElement.on('addCommentAnnotation').subscribe((event) => {
    // Handle the event response
});

```
</Tab>

<Tab title="Other Frameworks">
```js
const commentElement = Velt.getCommentElement();
commentElement.on('addCommentAnnotation').subscribe((event) => {
    // Handle the event response
});
```
</Tab>
</Tabs>


# Attachments

#### enableAttachments

![](/images/file-attachment.png)

Whether file attachments are enabled.

Default: `true`

When this is on, users can attach image files to their comments. Users can download or delete an attachment. Users can attach multiple files at once.

Currently we support `.png`, `.jpg`, `.gif` (static & animated), `.svg` file types up to 15MB per file.

<Tabs>
<Tab title="React / Next.js">
```js
<VeltComments attachments={true} />
````
```jsx
const commentElement = client.getCommentElement();
commentElement.enableAttachments();
commentElement.disableAttachments();
```
</Tab>

<Tab title="Other Frameworks">
```js
<velt-comments attachments="true"></velt-comments>
````
```jsx
const commentElement = Velt.getCommentElement();
commentElement.enableAttachments();
commentElement.disableAttachments();
```
</Tab>

</Tabs>

#### enableScreenshot

Whether screenshot option is enabled in comments.

Default: `false`

When enabled, users can attach screenshots when adding comments. This provides a quick way to capture and share visual context.

<Tabs>
<Tab title="React / Next.js">
```jsx
// Using Component Props
<VeltComments screenshot={true} />

// Using API methods
const commentElement = client.getCommentElement();
commentElement.enableScreenshot();
commentElement.disableScreenshot();
```
</Tab>

<Tab title="Other Frameworks">
```html
<!-- Using HTML attributes -->
<velt-comments screenshot="true"></velt-comments>

<script>
// Using API methods
const commentElement = Velt.getCommentElement();
commentElement.enableScreenshot();
commentElement.disableScreenshot();
</script>
```
</Tab>

</Tabs>

#### addAttachment

- Add an attachment to a specific comment annotation
- Params: [AddAttachmentRequest](/api-reference/sdk/models/data-models#addattachmentrequest) 
- Returns: Promise\<[AddAttachmentResponse\[\]](/api-reference/sdk/models/data-models#addattachmentresponse)>

<Tabs>
<Tab title="React / Next.js">
```jsx
const addAttachmentRequest = {
  annotationId: 'ANNOTATION_ID',
  files: '<Files[]>'
};

// Hook
const { addAttachment } = useAddAttachment();
const attachmentResponses = await addAttachment(addAttachmentRequest);

// API Method
const commentElement = client.getCommentElement();
const attachmentResponses = await commentElement.addAttachment(addAttachmentRequest);
```
</Tab>

<Tab title="Other Frameworks">
```js
const addAttachmentRequest = {
  annotationId: 'ANNOTATION_ID',
  files: '<Files[]>'
};

const commentElement = Velt.getCommentElement();
const attachmentResponses = await commentElement.addAttachment(addAttachmentRequest);
```
</Tab>
</Tabs>


#### deleteAttachment

- Delete an attachment from a specific comment annotation
- Params: [DeleteAttachmentConfig](/api-reference/sdk/models/data-models#deleteattachmentconfig)
- Returns: Promise\<[DeleteAttachmentEvent](/api-reference/sdk/models/data-models#deleteattachmentevent) | null>

<Tabs>
<Tab title="React / Next.js">
```jsx
const deleteAttachmentRequest = {
  annotationId: 'ANNOTATION_ID',
  commentId: COMMENT_ID,
  attachmentId: 'ATTACHMENT_ID'
};

// Hook
const { deleteAttachment } = useDeleteAttachment();
const deleteAttachmentEvent = await deleteAttachment(deleteAttachmentRequest);

// API Method
const commentElement = client.getCommentElement();
const deleteAttachmentEvent = await commentElement.deleteAttachment(deleteAttachmentRequest);
```
</Tab>

<Tab title="Other Frameworks">
```js
const deleteAttachmentRequest = {
  annotationId: 'ANNOTATION_ID',
  commentId: COMMENT_ID,
  attachmentId: 'ATTACHMENT_ID'
};

const commentElement = Velt.getCommentElement();
const deleteAttachmentEvent = await commentElement.deleteAttachment(deleteAttachmentRequest);
```
</Tab>
</Tabs>

#### getAttachment

- Get attachments from a specific comment annotation
- Params: [GetAttachmentRequest](/api-reference/sdk/models/data-models#getattachmentrequest)
- Returns: Promise\<[Attachment\[\]](/api-reference/sdk/models/data-models#attachment)>

<Tabs>
<Tab title="React / Next.js">
```jsx
const getAttachmentRequest = {
  annotationId: 'ANNOTATION_ID',
  commentId: COMMENT_ID,
};

// Hook
const { getAttachment } = useGetAttachment();
const attachments = await getAttachment(getAttachmentRequest);

// API Method
const commentElement = client.getCommentElement();
const attachments = await commentElement.getAttachment(getAttachmentRequest);
```
</Tab>

<Tab title="Other Frameworks">
```js
const getAttachmentRequest = {
  annotationId: 'ANNOTATION_ID',
  commentId: COMMENT_ID,
};

const commentElement = Velt.getCommentElement();
const attachments = await commentElement.getAttachment(getAttachmentRequest);
```
</Tab>
</Tabs>

#### allowedFileTypes

Limit file types in comment attachments by specifying allowed file extensions.

Default: Not specified (all supported file types allowed)

When this property is set, users can only attach files with the specified extensions. This helps you maintain security standards and ensure only approved file types are shared in collaborative discussions.

By default, Velt supports `.png`, `.jpg`, `.gif` (static & animated), `.svg` file types up to 15MB per file. With `allowedFileTypes`, you can restrict to a subset of these or any other file extensions your application requires.

<Tabs>
<Tab title="React / Next.js">
```jsx
// Using component prop
<VeltComments allowedFileTypes={['jpg', 'png']} />
```
```jsx
// Using API method
const commentElement = client.getCommentElement();
commentElement.setAllowedFileTypes(['jpg', 'png']);
```
</Tab>

<Tab title="Other Frameworks">
```html
<!-- Using HTML attribute -->
<velt-comments allowed-file-types="['jpg', 'png']"></velt-comments>
```
```js
// Using API method
const commentElement = Velt.getCommentElement();
commentElement.setAllowedFileTypes(['jpg', 'png']);
```
</Tab>
</Tabs>

#### attachmentNameInMessage

Display the attachment filename in the message when a file is attached.

Default: `false`

When this property is enabled, the attachment filename will appear in the message text when a user selects a file to attach. This provides immediate visual confirmation of which file they've attached to their comment, improving clarity before submitting.

<Tabs>
<Tab title="React / Next.js">
```jsx
<VeltComments attachmentNameInMessage={true} />
```
</Tab>

<Tab title="Other Frameworks">
```html
<velt-comments attachment-name-in-message="true"></velt-comments>
```
</Tab>
</Tabs>

#### setComposerFileAttachments

Programmatically add file attachments to the comment composer from your application instead of requiring users to select files from the file system.

This method enables workflows where you want to attach files programmatically, such as:
- Attaching screenshots captured within your application
- Including generated reports or documents
- Adding files from your own storage system
- Pre-populating attachments based on user context

Params: [UploadFileData](/api-reference/sdk/models/data-models#uploadfiledata)

The `UploadFileData` object accepts the following properties:
- `files` (required): Array of File objects to attach to the comment composer
- `annotationId` (optional): ID of the target comment annotation. Use this to add attachments to an existing comment thread
- `targetElementId` (optional): ID of the target element where the comment composer is attached. Use this to add attachments to a specific element

<Tabs>
<Tab title="React / Next.js">
```jsx
const commentElement = client.getCommentElement();

// Add attachments to a new comment composer
commentElement.setComposerFileAttachments({
  files: [file1, file2],
});

// Add attachments to an existing comment annotation
commentElement.setComposerFileAttachments({
  files: [file1, file2],
  annotationId: 'annotation-123',
});

// Add attachments to a comment composer on a specific element
commentElement.setComposerFileAttachments({
  files: [file1, file2],
  targetElementId: 'element-456',
});
```
</Tab>

<Tab title="Other Frameworks">
```js
const commentElement = Velt.getCommentElement();

// Add attachments to a new comment composer
commentElement.setComposerFileAttachments({
  files: [file1, file2],
});

// Add attachments to an existing comment annotation
commentElement.setComposerFileAttachments({
  files: [file1, file2],
  annotationId: 'annotation-123',
});

// Add attachments to a comment composer on a specific element
commentElement.setComposerFileAttachments({
  files: [file1, file2],
  targetElementId: 'element-456',
});
```
</Tab>
</Tabs>




# Reactions

#### enableReactions
![](/images/reactions.png)

Whether emoji reactions are enabled.

Default: `true`

<Tabs>
<Tab title="React / Next.js">
```jsx
<VeltComments reactions={true} />
```

```jsx
const commentElement = client.getCommentElement();
commentElement.enableReactions();
commentElement.disableReactions();
```
</Tab>

<Tab title="Other Frameworks">
```jsx
<velt-comments reactions="true"></velt-comments>
```

```jsx
const commentElement = Velt.getCommentElement();
commentElement.enableReactions();
commentElement.disableReactions();
```

</Tab>
</Tabs>

#### setCustomReactions

- You can set custom reactions by passing a map that contains information about the reactions you want to add.
- The map keys should be the reaction ID, and the map value should contain an object with either an `url` or `emoji` field to represent the reaction icon you want to use.

<Tabs>
<Tab title="React / Next.js">

```jsx
const commentElement = client.getCommentElement();

const customReactions = {
    "reactionId1": {
        "emoji": "ðŸ¤£" // This will default to system emoji
    },
    "reactionId2": {
        "emoji": "ðŸŽ‰" // This will default to system emoji
    },
    "reactionId3": {
        "emoji": "ðŸš€" // This will default to system emoji
    }
}
commentElement.setCustomReactions(customReactions);
```

</Tab>

<Tab title="Other Frameworks">
```jsx
const commentElement = Velt.getCommentElement();

const customReactions = {
    "reactionId1": {
        "emoji": "ðŸ¤£" // This will default to system emoji
    },
    "reactionId2": {
        "emoji": "ðŸŽ‰" // This will default to system emoji
    },
    "reactionId3": {
        "emoji": "ðŸš€" // This will default to system emoji
    }
}
commentElement.setCustomReactions(customReactions);
```

</Tab>
</Tabs>


#### addReaction

- Add a reaction to a specific comment annotation
- Params: [AddReactionRequest](/api-reference/sdk/models/data-models#addreactionrequest)
- Returns: Promise\<[AddReactionEvent](/api-reference/sdk/models/data-models#addreactionevent) | null>

<Tabs>
<Tab title="React / Next.js">
```jsx
const addReactionRequest = {
  annotationId: '-OCWolieeXVOfPqTa0G-',
  commentId: 384399,
  reaction: {
    reactionId: 'fire',
    customReaction: {
          "emoji": "ðŸ”¥"
    }
  }
};

// Hook
const { addReaction } = useAddReaction();
const addReactionEvent = await addReaction(addReactionRequest);

// API Method
const commentElement = client.getCommentElement();
const addReactionEvent = await commentElement.addReaction(addReactionRequest);
```
</Tab>

<Tab title="Other Frameworks">
```js
const addReactionRequest = {
  annotationId: '-OCWolieeXVOfPqTa0G-',
  commentId: 384399,
  reaction: {
    reactionId: 'fire',
    customReaction: {
          "emoji": "ðŸ”¥"
    }
  }
};

const commentElement = Velt.getCommentElement();
const addReactionEvent = await commentElement.addReaction(addReactionRequest);
```
</Tab>
</Tabs>

#### deleteReaction

- Delete a reaction from a specific comment annotation
- Params: [DeleteReactionRequest](/api-reference/sdk/models/data-models#deletereactionrequest)
- Returns: Promise\<[DeleteReactionEvent](/api-reference/sdk/models/data-models#deletereactionevent) | null>

<Tabs>
<Tab title="React / Next.js">
```jsx
const deleteReactionRequest = {
  annotationId: '-OCWolieeXVOfPqTa0G-',
  commentId: 384399,
  reaction: {
    reactionId: 'fire'
  }
};

// Hook
const { deleteReaction } = useDeleteReaction();
const deleteReactionEvent = await deleteReaction(deleteReactionRequest);

// API Method
const commentElement = client.getCommentElement();
const deleteReactionEvent = await commentElement.deleteReaction(deleteReactionRequest);
```
</Tab>

<Tab title="Other Frameworks">
```js
const deleteReactionRequest = {
  annotationId: '-OCWolieeXVOfPqTa0G-',
  commentId: 384399,
  reaction: {
    reactionId: 'fire'
  }
};

const commentElement = Velt.getCommentElement();
const deleteReactionEvent = await commentElement.deleteReaction(deleteReactionRequest);
```
</Tab>
</Tabs>

#### toggleReaction

- Toggle a reaction for a specific comment annotation
- Params: [ToggleReactionRequest](/api-reference/sdk/models/data-models#togglereactionrequest)
- Returns: Promise\<[ToggleReactionEvent](/api-reference/sdk/models/data-models#togglereactionevent) | null>

<Tabs>
<Tab title="React / Next.js">
```jsx
const toggleReactionRequest = {
  annotationId: '-OCWolieeXVOfPqTa0G-',
  commentId: 384399,
  reaction: {
    reactionId: 'fire'
  }
};

// Hook
const { toggleReaction } = useToggleReaction();
const toggleReactionEvent = await toggleReaction(toggleReactionRequest);

// API Method
const commentElement = client.getCommentElement();
const toggleReactionEvent = await commentElement.toggleReaction(toggleReactionRequest);
```
</Tab>

<Tab title="Other Frameworks">
```js
const toggleReactionRequest = {
  annotationId: '-OCWolieeXVOfPqTa0G-',
  commentId: 384399,
  reaction: {
    reactionId: 'fire'
  }
};

const commentElement = Velt.getCommentElement();
const toggleReactionEvent = await commentElement.toggleReaction(toggleReactionRequest);
```
</Tab>
</Tabs>


# Status & Priority

#### enableStatus
![](/images/status-default.png)

Whether to enable the default status dropdown & filters.

`Default: true`

When this is on, users can assign a status to each comment & filter comment by status in the sidebar. You can customize the list of status options as shown below on this page.
<Tabs>
<Tab title="React / Next.js">
```js
<VeltComments status={true} />
```
</Tab>

<Tab title="Other Frameworks">
```js
<velt-comments status="true"></velt-comments>
```
</Tab>


</Tabs>

API Method:
<Tabs>
<Tab title="React / Next.js">
```jsx
const commentElement = client.getCommentElement();
commentElement.enableStatus();
commentElement.disableStatus();
```
</Tab>

<Tab title="Other Frameworks">

```jsx
const commentElement = Velt.getCommentElement();
commentElement.enableStatus();
commentElement.disableStatus();
```
</Tab>


</Tabs>
#### setCustomStatus

![](/images/custom-status.png)


- With custom statuses, you can replace the default statuses with your own values.
- These statuses are also used in the comment sidebar to filter comments by status.
- There are three types of statuses:
  - `default`: This will be the default status assigned to each comment.
  - `ongoing`: This is treated as an intermediary status, you can add as many statuses with type ongoing as you want.
  - `terminal`: This represents a status that is completed. Comments with this status type are no longer shown in the DOM.
- Ensure that there are at least 2 statuses set.

<Tabs>
<Tab title="React / Next.js">
```jsx
const commentElement = client.getCommentElement();
commentElement.setCustomStatus([
  {
    id: 'open',
    name: 'Open',
    color: '#625df5',
    lightColor: '#f2f2fe',
    type: 'default',
  },
  {
    id: 'resolved',
    name: 'Resolved',
    color: '#198f65',
    lightColor: '#edf6f3',
    type: 'terminal',
  },
])
```
</Tab>

<Tab title="Other Frameworks">
```jsx
const commentElement = Velt.getCommentElement();
commentElement.setCustomStatus([
  {
    id: 'open',
    name: 'Open',
    color: '#625df5',
    lightColor: '#f2f2fe',
    type: 'default',
  },
  {
    id: 'resolved',
    name: 'Resolved',
    color: '#198f65',
    lightColor: '#edf6f3',
    type: 'terminal',
  },
])
```
</Tab>

</Tabs>


#### enableResolveButton
![](/images/resolve-button.png)

Whether to show resolve button on comments.

`Default: true`

This adds a tick mark button on the top right corner of the comment dialog. Clicking on this button will mark the comment as resolved.
<Tabs>
<Tab title="React / Next.js">

```js
<VeltComments resolveButton={true} />
```
</Tab>

<Tab title="Other Frameworks">
```js
<velt-comments resolve-button="true"></velt-comments>
```
</Tab>


</Tabs>
API Method:
<Tabs>
<Tab title="React / Next.js">
```jsx
const commentElement = client.getCommentElement();
commentElement.enableResolveButton();
commentElement.disableResolveButton();
```
</Tab>

<Tab title="Other Frameworks">
```jsx
const commentElement = Velt.getCommentElement();
commentElement.enableResolveButton();
commentElement.disableResolveButton();
```
</Tab>


</Tabs>

#### updateStatus

- Updates the status of a comment annotation.
- Params: [UpdateStatusRequest](/api-reference/sdk/models/data-models#updatestatusrequest)
- Returns: [UpdateStatusEvent](/api-reference/sdk/models/data-models#updatestatusevent)

<Tabs>
<Tab title="React / Next.js">
```jsx
const updateStatusRequest = {
  annotationId: 'ANNOTATION_ID',
  status: {
    "id": "open",
    "name": "Open",
    "color": "white",
    "lightColor":"green",
    "type": "default"
  }
};

// Hook
const { updateStatus } = useUpdateStatus();
const updateStatusEvent = await updateStatus(updateStatusRequest);

// API Method
const commentElement = client.getCommentElement();
const updateStatusEvent = await commentElement.updateStatus(updateStatusRequest);
```
</Tab>

<Tab title="Other Frameworks">
```js
const updateStatusRequest = {
  annotationId: 'ANNOTATION_ID',
  status: {
    "id": "open",
    "name": "Open",
    "color": "white",
    "lightColor":"green",
    "type": "default"
  }
};

const commentElement = Velt.getCommentElement();
const updateStatusEvent = await commentElement.updateStatus(updateStatusRequest);
```
</Tab>
</Tabs>

#### resolveCommentAnnotation

- Resolves a comment annotation
- Params: [ResolveCommentAnnotationRequest](/api-reference/sdk/models/data-models#resolvecommentannotationrequest)
- Returns: [ResolveCommentAnnotationEvent](/api-reference/sdk/models/data-models#resolvecommentannotationevent)

<Tabs>
<Tab title="React / Next.js">
```jsx
const resolveCommentAnnotationRequest = {
  annotationId: 'ANNOTATION_ID'
};

// Hook
const { resolveCommentAnnotation } = useResolveCommentAnnotation();
const resolveCommentAnnotationEvent = await resolveCommentAnnotation(resolveCommentAnnotationRequest);

// API Method
const commentElement = client.getCommentElement();
const resolveCommentAnnotationEvent = await commentElement.resolveCommentAnnotation(resolveCommentAnnotationRequest);
```
</Tab>

<Tab title="Other Frameworks">
```js
const resolveCommentAnnotationRequest = {
  annotationId: 'ANNOTATION_ID'
};

const commentElement = Velt.getCommentElement();
const resolveCommentAnnotationEvent = await commentElement.resolveCommentAnnotation(resolveCommentAnnotationRequest);
```
</Tab>
</Tabs>




#### enablePriority

![](/images/priority-default.png)

Whether to enable setting priority on comments.

`Default: false`

When this is on, users can assign a priority to each comment & filter comment by priority in the sidebar. You can customize the list of priority options as shown later on this page in the Set Custom Priorities section.
<Tabs>
<Tab title="React / Next.js">
```js
<VeltComments priority={true} />
```
</Tab>

<Tab title="Other Frameworks">
```js
<velt-comments priority="true"></velt-comments>
```
</Tab>


</Tabs>
API Method:
<Tabs>
<Tab title="React / Next.js">
```jsx
const commentElement = client.getCommentElement();
commentElement.enablePriority();
commentElement.disablePriority();
```
</Tab>

<Tab title="Other Frameworks">
```jsx
const commentElement = Velt.getCommentElement();
commentElement.enablePriority();
commentElement.disablePriority();
```
</Tab>


</Tabs>
#### setCustomPriority
![](/images/custom-priority.png)


<Tabs>
<Tab title="React / Next.js">
Pass custom priorities in the `customPriority` prop.

`Default priorities: P0, P1, P2`

With custom priorities, you can replace the default priorities with your own values. These priorities are also used in the comment sidebar to filter comments by priority.

This will work if you have enabled the priority feature.

The `color` property is used to set the priority pill background color.

The `lightColor` property sets the background color of the filter.
```js

<VeltComments customPriority={[
  {
    "id": "low",
    "name": "Low",
    "color": "red",
    "lightColor": "pink",
  },
]}/>
```
</Tab>

<Tab title="Other Frameworks">
Pass custom priorities in the `custom-priority`.

`Default priorities: P0, P1, P2`

With custom priorities, you can replace the default priorities with your own values. These priorities are also used in the comment sidebar to filter comments by priority.

This will work if you have enabled the priority feature.

The `color` property is used to set the priority pill background color.

The `lightColor` property sets the background color of the filter.
```js
<velt-comments custom-priority='[
  {
    "id": "low",
    "name": "Low",
    "color": "red",
    "lightColor": "pink",
  }
]'></velt-comments>
```

</Tab>


</Tabs>

API Method:
<Tabs>
<Tab title="React / Next.js">
```jsx
const commentElement = client.getCommentElement();
commentElement.setCustomPriority([
  {
    "id": "low",
    "name": "Low",
    "color": "red",
    "lightColor": "pink",
  },
])
```
</Tab>

<Tab title="Other Frameworks">
```jsx
const commentElement = Velt.getCommentElement();
commentElement.setCustomPriority([
  {
    "id": "low",
    "name": "Low",
    "color": "red",
    "lightColor": "pink",
  },
])
```
</Tab>
</Tabs>

<Warning>
Make sure to have at least 2 categories set.
</Warning>

#### updatePriority

- Updates the priority of a comment annotation
- Params: [UpdatePriorityRequest](/api-reference/sdk/models/data-models#updatepriorityrequest) 
- Returns: [UpdatePriorityEvent](/api-reference/sdk/models/data-models#updatepriorityevent)

<Tabs>
<Tab title="React / Next.js">
```jsx
const updatePriorityRequest = {
  annotationId: 'ANNOTATION_ID',
  priority: {
    "id": "low",
    "name": "Low",
    "color": "red",
    "lightColor": "pink",
  }
};

// Hook
const { updatePriority } = useUpdatePriority();
const updatePriorityEvent = await updatePriority(updatePriorityRequest);

// API Method
const commentElement = client.getCommentElement();
const updatePriorityEvent = await commentElement.updatePriority(updatePriorityRequest);
```
</Tab>

<Tab title="Other Frameworks">
```js
const updatePriorityRequest = {
  annotationId: 'ANNOTATION_ID',
  priority: {
    "id": "low",
    "name": "Low",
    "color": "red",
    "lightColor": "pink",
  }
};

const commentElement = Velt.getCommentElement();
const updatePriorityEvent = await commentElement.updatePriority(updatePriorityRequest);
```
</Tab>
</Tabs>


# Recording

#### deleteRecording

- Delete a recording from a specific comment annotation
- Params: [DeleteRecordingRequest](/api-reference/sdk/models/data-models#deleterecordingrequest)
- Returns: Promise\<[DeleteRecordingEvent](/api-reference/sdk/models/data-models#deleterecordingevent) | null>

<Tabs>
<Tab title="React / Next.js">
```jsx
const deleteRecordingRequest = {
  annotationId: 'ANNOTATION_ID',
  commentId: COMMENT_ID,
  recordingId: 'RECORDING_ID'
};

// Hook
const { deleteRecording } = useDeleteRecording();
const deleteRecordingEvent = await deleteRecording(deleteRecordingRequest);

// API Method
const commentElement = client.getCommentElement();
const deleteRecordingEvent = await commentElement.deleteRecording(deleteRecordingRequest);
```
</Tab>

<Tab title="Other Frameworks">
```js
const deleteRecordingRequest = {
  annotationId: 'ANNOTATION_ID',
  commentId: COMMENT_ID,
  recordingId: 'RECORDING_ID'
};

const commentElement = Velt.getCommentElement();
const deleteRecordingEvent = await commentElement.deleteRecording(deleteRecordingRequest);
```
</Tab>
</Tabs>


#### getRecording

- Get recordings from a specific comment annotation
- Params: [GetRecordingRequest](/api-reference/sdk/models/data-models#getrecordingrequest)
- Returns: Promise\<[RecordedData\[\]](/api-reference/sdk/models/data-models#recordeddata)>

<Tabs>
<Tab title="React / Next.js">
```jsx
const getRecordingRequest = {
  annotationId: 'ANNOTATION_ID',
  commentId: COMMENT_ID
};

// Hook
const { getRecording } = useGetRecording();
const recordings = await getRecording(getRecordingRequest);

// API Method
const commentElement = client.getCommentElement();
const recordings = await commentElement.getRecording(getRecordingRequest);
```
</Tab>

<Tab title="Other Frameworks">
```js
const getRecordingRequest = {
  annotationId: 'ANNOTATION_ID',
  commentId: COMMENT_ID
};

const commentElement = Velt.getCommentElement();
const recordings = await commentElement.getRecording(getRecordingRequest);
```
</Tab>
</Tabs>



#### setAllowedRecordings

![](/images/recorder.png)

Set the Recorder media options within Comments: (`audio`, `screen`, `video`, `all`).
- `audio`: enables audio recording
- `screen`: enables screen recording
- `video`: enables video recording
- `all`: enables all recording options
- `none`: disables all recording options

Default: `"audio"`

<Tabs>
<Tab title="React / Next.js">
```jsx
<VeltComments recordings="video,screen" />
```
**Using API:**
```jsx
const commentElement = client.getCommentElement();
commentElement.setAllowedRecordings("video"); // set video mode only
commentElement.setAllowedRecordings("audio,screen"); // set audio and screen mode only
commentElement.setAllowedRecordings("all"); // set all modes
commentElement.setAllowedRecordings("none"); // disable all modes
```
</Tab>

**Using Props:**
<Tab title="Other Frameworks">
```jsx
<velt-comments recordings="video,screen"></velt-comments>
```
**Using API:**
```jsx
const commentElement = Velt.getCommentElement();
commentElement.setAllowedRecordings("video"); // set video mode only
commentElement.setAllowedRecordings("audio,screen"); // set audio and screen mode only
commentElement.setAllowedRecordings("all"); // set all modes
commentElement.setAllowedRecordings("none"); // disable all modes
```
</Tab>
</Tabs>

#### enableRecordingCountdown
![](/gifs/recording-countdown.gif)

Whether the Recorder countdown is enabled.

Default: `true`
<Tabs>
<Tab title="React / Next.js">
```jsx
<VeltComments recordingCountdown={false} />
```

```jsx
const recorderElement = client.getRecorderElement();
recorderElement.enableRecordingCountdown();
recorderElement.disableRecordingCountdown();
```
</Tab>

<Tab title="Other Frameworks">
```jsx
<velt-comments recording-countdown="false"></velt-comments>
```

```jsx
const recorderElement = Velt.getRecorderElement();
recorderElement.enableRecordingCountdown();
recorderElement.disableRecordingCountdown();
```
</Tab>


</Tabs>

#### enableRecordingTranscription
Controls whether to enable AI transcription for recordings.

Default: `enabled`

<Tabs>
    <Tab title="React / Next.js">
      **Using Props:**
      ```jsx
      <VeltComments recordingTranscription={false} />
      ```
      **Using API Methods:**
      ```javascript
      // Using comment element
      const commentElement = client.getCommentElement();
      commentElement.enableRecordingTranscription();
      commentElement.disableRecordingTranscription();

      // Or using recorder element 
      const recorderElement = client.getRecorderElement();
      recorderElement.enableRecordingTranscription();
      recorderElement.disableRecordingTranscription();
      ```
    </Tab>
    <Tab title="Other Frameworks">
      **Using Props:**
      ```html
      <velt-comments recording-transcription="false"></velt-comments>
      ```
      **Using API Methods:**
      ```javascript
      // Using comment element
      const commentElement = Velt.getCommentElement();
      commentElement.enableRecordingTranscription();
      commentElement.disableRecordingTranscription();

      // Or using recorder element 
      const recorderElement = Velt.getRecorderElement();
      recorderElement.enableRecordingTranscription();
      recorderElement.disableRecordingTranscription();
      ```
    </Tab>
  </Tabs>

# Deep Link

#### getLink

- Get a link to a specific comment annotation
- Params: [GetLinkRequest](/api-reference/sdk/models/data-models#getlinkrequest)
- Returns: [GetLinkResponse](/api-reference/sdk/models/data-models#getlinkresponse)

<Tabs>
<Tab title="React / Next.js">
```jsx
const getLinkRequest = {
  annotationId: 'ANNOTATION_ID'
};

// Hook
const { getLink } = useGetLink();
const getLinkResponse = await getLink(getLinkRequest);

// API Method
const commentElement = client.getCommentElement();
const getLinkResponse = await commentElement.getLink(getLinkRequest);
```
</Tab>

<Tab title="Other Frameworks">
```js
const getLinkRequest = {
  annotationId: 'ANNOTATION_ID'
};

const commentElement = Velt.getCommentElement();
const getLinkResponse = await commentElement.getLink(getLinkRequest);
```
</Tab>
</Tabs>

#### copyLink

- Copy a link to a specific comment annotation to clipboard
- Params: [CopyLinkRequest](/api-reference/sdk/models/data-models#copylinkrequest)
- Returns: [CopyLinkEvent](/api-reference/sdk/models/data-models#copylinkevent)

<Tabs>
<Tab title="React / Next.js">
```jsx
const copyLinkRequest = {
  annotationId: 'ANNOTATION_ID'
};

// Hook
const { copyLink } = useCopyLink();
const copyLinkEvent = await copyLink(copyLinkRequest);

// API Method
const commentElement = client.getCommentElement();
const copyLinkEvent = await commentElement.copyLink(copyLinkRequest);
```
</Tab>

<Tab title="Other Frameworks">
```js
const copyLinkRequest = {
  annotationId: 'ANNOTATION_ID'
};

const commentElement = Velt.getCommentElement();
const copyLinkEvent = await commentElement.copyLink(copyLinkRequest);
```
</Tab>
</Tabs>



# Navigation

#### scrollToCommentByAnnotationId
![](/gifs/scroll-on-click.gif)

- This will scroll the page to the element directly. This will work if the element is present on the DOM.

<Tabs>
<Tab title="React / Next.js">

```jsx
const commentElement = client.getCommentElement();
commentElement.scrollToCommentByAnnotationId('annotationId')
```

</Tab>

<Tab title="Other Frameworks">
```jsx
const commentElement = Velt.getCommentElement();
commentElement.scrollToCommentByAnnotationId('annotationId')
```
</Tab>


</Tabs>

#### selectCommentByAnnotationId
- Use this to programmatically select a comment annotation by its ID.
- When called without arguments or with an invalid ID, it will close the currently selected annotation.
- Example: If the user opens a comment URL from an email notification, you can use this to open the comment dialog after your page has finished rendering.

<Tabs>
<Tab title="React / Next.js">

```jsx
// Using Hooks
const commentElement = useCommentUtils();

// Open a specific annotation
commentElement.selectCommentByAnnotationId('COMMENT_ANNOTATION_ID');

// Close the currently selected annotation
commentElement.selectCommentByAnnotationId();
commentElement.selectCommentByAnnotationId('invalid-id');

// Using API methods
const commentElement = client.getCommentElement();

// Open a specific annotation
commentElement.selectCommentByAnnotationId('COMMENT_ANNOTATION_ID');

// Close the currently selected annotation
commentElement.selectCommentByAnnotationId();
commentElement.selectCommentByAnnotationId('invalid-id');
```

</Tab>

<Tab title="Other Frameworks">
```jsx
const commentElement = Velt.getCommentElement();

// Open a specific annotation
commentElement.selectCommentByAnnotationId('COMMENT_ANNOTATION_ID');

// Close the currently selected annotation
commentElement.selectCommentByAnnotationId();
commentElement.selectCommentByAnnotationId('invalid-id');
```
</Tab>
</Tabs>

#### onCommentSelectionChange

<Tabs>
<Tab title="React / Next.js with Hooks">
The `useCommentSelectionChangeHandler` hook can be used to subscribe to Comment selection changes.

```jsx
import React, { useEffect } from 'react';
import { useCommentSelectionChangeHandler } from '@veltdev/react';

function YourComponent() {
    const commentSelectionChange = useCommentSelectionChangeHandler();

    useEffect(() => {
        console.log('commentSelectionChange', commentSelectionChange);
    }, [commentSelectionChange]);

    return (
        <>
            Selected Comment: {commentSelectionChange.annotation.id}
        </>
    );
}
```
</Tab>
<Tab title="React / Next.js">
The `onCommentSelectionChange()` method can be used to listen Comment selection changes.
```jsx
const onCommentSelectionChange = (data) => {
  console.log('onCommentSelectionChange', data);
}

<VeltComments onCommentSelectionChange={(data) => onCommentSelectionChange(data)} />
```
Callback response schema:


```jsx
export class CommentSelectionChangeData {
  selected!: boolean;
  annotation!: CommentAnnotation;
}
```


**API Methods:**

```jsx
const commentElement = client.getCommentElement();
let subscription = commentElement.onCommentSelectionChange().subscribe((data) => {
  console.log('onCommentSelectionChange: ', data);
});
```


**To unsubscribe from the subscription:**
```jsx
subscription?.unsubscribe()
```
</Tab>

<Tab title="Other Frameworks">
The `onCommentSelectionChange()` method can be used to listen Comment selection changes.
```jsx
<velt-comments></velt-comments>
<script>
const commentTag = document.querySelector('velt-comments');
commentTag.addEventListener('onCommentSelectionChange', (event) => {
	console.log('onCommentSelectionChange event', event.detail);
});
</script>
```
**Callback response schema:**


```jsx
export class CommentSelectionChangeData {
  selected!: boolean;
  annotation!: CommentAnnotation;
}
```


**API Methods:**

```jsx
const commentElement = Velt.getCommentElement();
let subscription = commentElement.onCommentSelectionChange().subscribe((data) => {
  console.log('onCommentSelectionChange: ', data);
});
```


**To unsubscribe from the subscription:**
```jsx
subscription?.unsubscribe()
```
</Tab>
</Tabs>

#### enablescrollToComment

![](/gifs/scroll-on-click.gif)


Whether, users will be scrolled to the location of a `Comment` when it is clicked.

`Default: true`

By default, users will be redirected to a `Comment` if the comment id is provided in the url. But sometimes this experience is annoying, so we have provided a way to disable the option to automatically scroll users to the location of the `Comment`.


<Tabs>
<Tab title="React / Next.js">
To disable the feature, set `scrollToComment` to `false`.
```html
<VeltComments scrollToComment={false}/>
```
</Tab>

<Tab title="Other Frameworks">
To disable the feature, set `scroll-to-comment` to `false`.
```html
<velt-comments scroll-to-comment="false"></velt-comments>
```
</Tab>


</Tabs>
API methods:
<Tabs>
<Tab title="React / Next.js">
```jsx
const commentElement = client.getCommentElement();
// To enable scroll to component
commentElement.enablescrollToComment();
// To disable scroll to component
commentElement.disablescrollToComment();
```
</Tab>

<Tab title="Other Frameworks">

```jsx
const commentElement = Velt.getCommentElement();
// To enable scroll to component
commentElement.enablescrollToComment();
// To disable scroll to component
commentElement.disablescrollToComment();
```
</Tab>


</Tabs>

# DOM Controls
#### allowedElementIds
#### allowedElementClassNames
#### allowedElementQuerySelectors

![](/gifs/comment-area.gif)

Provide a list of element DOM IDs, class names, or query selectors where commenting should be allowed.

Comments will be disabled for all other elements. Note, this does not impact `Popover` mode.

<Tabs>
<Tab title="React / Next.js">
**Using Props:**
```js
<VeltComments 
  allowedElementIds={['some-element']} 
  allowedElementClassNames={["class-name-1", "class-name-2"]}
  allowedElementQuerySelectors={["#id1.class-name-1"]}
/>
```

**Using API Method:**
```jsx
const commentElement = client.getCommentElement();
commentElement.allowedElementIds(['some-element']);
commentElement.allowedElementClassNames(["class-name-1", "class-name-2"]);
commentElement.allowedElementQuerySelectors(["#id1.class-name-1"]);
```
</Tab>

<Tab title="Other Frameworks">
**Using Props:**
```html
<velt-comments 
  allowed-element-ids='["some-element"]'
  allowed-element-class-names='["class-name-1", "class-name-2"]'
  allowed-element-query-selectors='["#id1.class-name-1"]'
>

</velt-comments>
```

**Using API Method:**
```jsx
const commentElement = Velt.getCommentElement();
commentElement.allowedElementIds(['some-element']);
commentElement.allowedElementClassNames(["class-name-1", "class-name-2"]);
commentElement.allowedElementQuerySelectors(["#id1.class-name-1"]);
```
</Tab>
</Tabs>


#### data-velt-comment-disabled

![](/gifs/comment-area.gif)

Disable certain elements from being commented on.

Add the `data-velt-comment-disabled` attribute to elements where you want to disable commenting.

```html
<div data-velt-comment-disabled></div>
```


#### sourceId

- When you have multiple elements with the same DOM ID, you can use the `sourceId` attribute to control which element displays the comment dialog when adding a new comment.
- By default, comments appear on all matching elements.
- This is useful in cases where you have multiple instances of the same data component on a page and want the comment to appear on each instance, such as Popover comments on a table.
- You can randomly generate the `sourceId`. It just needs to be unique for each element in the current session.

<Tabs>
  <Tab title="React / Next.js">
    ```jsx
    <VeltCommentTool sourceId="sourceId1" />
    ```
  </Tab>

  <Tab title="Other Frameworks">
    ```html
    <velt-comment-tool source-id="sourceId1"></velt-comment-tool>
    ```
  </Tab>
</Tabs>


# AI Categorization
#### enableAutoCategorize

![](/images/ai-categories.png)

Whether AI auto-categorization of comments is enabled.

`Default: false`

We use AI to analyze your comment content and auto-categorize it so users can filter comments easily. You can provide a list of custom categories that we should use to categorize the comments (shown below).
<Tabs>
<Tab title="React / Next.js">
```js
<VeltComments autoCategorize={true} />
```
</Tab>

<Tab title="Other Frameworks">
```js
<velt-comments auto-categorize="true"></velt-comments>
```
</Tab>


</Tabs>
API Method:
<Tabs>
<Tab title="React / Next.js">
```jsx
const commentElement = client.getCommentElement();
commentElement.enableAutoCategorize();
commentElement.disableAutoCategorize();
```
</Tab>

<Tab title="Other Frameworks">
```jsx
const commentElement = Velt.getCommentElement();
commentElement.enableAutoCategorize();
commentElement.disableAutoCategorize();
```
</Tab>
</Tabs>
#### setCustomCategory

![](/images/custom-categories.png)

<Tabs>
<Tab title="React / Next.js">
Pass custom categories in the `customCategory` prop.

`Default categories: Question, Feedback, Bug, Other.`

With custom categories, you can replace the default categories with your own values.

These categories are used in the `Comments Sidebar` to filter comments by category. The AI `autoCategorize` feature uses the list of categories to determine the closest category to choose from.

The input format to the `customCategory` prop should be an array of objects with an `id`, `name`, and `color`. 

The `color` property is used to set the category pill background color.
```js
<VeltComments customCategory={[
  {
    "id": "bug",
    "name": "Bug",
    "color": "red"
  }
]}/>
```
</Tab>

<Tab title="Other Frameworks">
Pass custom categories in the `custom-category`.

`Default categories: Question, Feedback, Bug, Other.`

With custom categories, you can replace the default categories with your own values.

These categories are used in the `Comments Sidebar` to filter comments by category. The AI `auto-categorize` uses the list of categories to determine the closest category to choose from.

The input format to the `custom-category` should be an array of objects with an `id`, `name`, and `color`. 

The `color` property is used to set the category pill background color.
```js
<velt-comments customCategory='[
  {
    "id": "bug",
    "name": "Bug",
    "color": "red"
  }
]'></velt-comments>
```
</Tab>


</Tabs>
API Method:
<Tabs>
<Tab title="React / Next.js">
```jsx
const commentElement = client.getCommentElement();
commentElement.setCustomCategory([
  {
    "id": "bug",
    "name": "Bug",
    "color": "red"
  }
])
```
</Tab>

<Tab title="Other Frameworks">

```jsx
const commentElement = Velt.getCommentElement();
commentElement.setCustomCategory([
  {
    "id": "bug",
    "name": "Bug",
    "color": "red"
  }
])
```
</Tab>


</Tabs>
<Warning>
Make sure to have at least 2 categories set.
</Warning>

# UI/UX

#### composerMode
By default, the `Composer` in the `Comments Dialog` only shows the text input box and does not show the actions bar until the `Composer` is clicked on or the user starts typing.

You can modify this behavior by setting the `Composer Mode` prop to `"expanded"`. This will make the actions bar always visible. 

To keep the default behavior you can set the property to `"default"`.

`Default: "default"`
<Tabs>
<Tab title="React / Next.js">

```jsx
<VeltComments composerMode="expanded"/>
```
</Tab>
<Tab title="Other Frameworks">

```jsx
<velt-comments composer-mode="expanded"></velt-comments>
```
</Tab>

</Tabs>

#### commentToNearestAllowedElement

Attach comment pins to the closest allowed element when clicking on a non-allowed element.
Default: `false`
<Tabs>
<Tab title="React / Next.js">
```jsx
<VeltComments commentToNearestAllowedElement={true} />
```

**Using API:**
```jsx
const commentElement = client.getCommentElement();
commentElement.enableCommentToNearestAllowedElement();
commentElement.disableCommentToNearestAllowedElement();
```
</Tab>
<Tab title="Other Frameworks">
```html
<velt-comments comment-to-nearest-allowed-element="true"></velt-comments>
```

**Using API:**
```js
const commentElement = Velt.getCommentElement();
commentElement.enableCommentToNearestAllowedElement();
commentElement.disableCommentToNearestAllowedElement();
```
</Tab>
</Tabs>


#### deleteThreadWithFirstComment
Whether deleting the first comment in a thread will delete the entire thread.

Default: `true`

<Tabs>
<Tab title="React / Next.js">
```jsx
<VeltComments deleteThreadWithFirstComment={false} />
```
</Tab>

<Tab title="Other Frameworks">
```html
<velt-comments delete-thread-with-first-comment="false"></velt-comments>
```
</Tab>
</Tabs>

#### draftMode

Whether to store comments in draft if they are not submitted.
Default: `true`
<Tabs>
<Tab title="React / Next.js">
```jsx
<VeltComments draftMode={false} />
```

**Using API:**
```jsx
const commentElement = client.getCommentElement();
commentElement.enableDraftMode();
commentElement.disableDraftMode();
```
</Tab>
<Tab title="Other Frameworks">
```html
<velt-comments draft-mode="false"></velt-comments>
```

**Using API:**
```js
const commentElement = Velt.getCommentElement();
commentElement.enableDraftMode();
commentElement.disableDraftMode();
```
</Tab>
</Tabs>



#### enableCollapsedComments

You can control whether comments inside the annotation should be collapsed.

`Default: false`

<Tabs>
  <Tab title="React / Next.js">
  Using Props:
    ```jsx
    <VeltComments collapsedComments={true} />
    ```

    Using API:
    ```javascript
    const commentElement = client.getCommentElement();
    // To enable collapsed comments
    commentElement.enableCollapsedComments();
    // To disable collapsed comments
    commentElement.disableCollapsedComments();
    ```
  </Tab>
  
  <Tab title="Other Frameworks">
  Using Props:
    ```html
    <velt-comments collapsed-comments="true"></velt-comments>
    ```
    Using API:
    ```javascript
    const commentElement = Velt.getCommentElement();
    // To enable collapsed comments
    commentElement.enableCollapsedComments();
    // To disable collapsed comments
    commentElement.disableCollapsedComments();
    ```
  </Tab>
</Tabs>


#### enableFullExpanded

- You can control whether comments should be shown in fully expanded state by default.
- Available on all comment-related components and can be controlled via props or API methods.

`Default: false`

<Tabs>
<Tab title="React / Next.js">
Using Props:
```jsx
// Apply this change globally to all types of comments
<VeltComments fullExpanded={true} />

// Apply this change only in comments sidebar
<VeltCommentsSidebar fullExpanded={true} />

// Apply this change only in inline comments section
<VeltInlineCommentsSection fullExpanded={true} />

// Apply this change only in the standalone comment thread
<VeltCommentThread fullExpanded={true} />

```
Using API:
```js
// API Method
const commentElement = client.getCommentElement();
commentElement.enableFullExpanded();
commentElement.disableFullExpanded();
```
</Tab>
<Tab title="Other Frameworks">
Using Props:
```html
<!-- Apply this change globally to all types of comments -->
<velt-comments full-expanded="true"></velt-comments>

<!-- Apply this change only in comments sidebar -->
<velt-comments-sidebar full-expanded="true"></velt-comments-sidebar>

<!-- Apply this change only in inline comments section -->
<velt-inline-comments-section full-expanded="true"></velt-inline-comments-section>

<!-- Apply this change only in the standalone comment thread -->
<velt-comment-thread full-expanded="true"></velt-comment-thread>

```
Using API:
```js
const commentElement = Velt.getCommentElement();
commentElement.enableFullExpanded();
commentElement.disableFullExpanded();
```
</Tab>
</Tabs>


#### enableShortUserName

You can control whether long user names should be shortened. For long names, this will first create an initial of the second name and if the name is still long, it will truncate it with ellipses.

Default: `true`

<Tabs>
  <Tab title="React / Next.js">
  **Using Props:**
    ```jsx
    <VeltComments shortUserName={false} />
    ```

    **Using API:**
    ```javascript
    const commentElement = client.getCommentElement();
    commentElement.enableShortUserName();
    commentElement.disableShortUserName();
    ```
  </Tab>
  
  <Tab title="Other Frameworks">
  **Using Props:**
    ```html
    <velt-comments short-user-name="false"></velt-comments>
    ```
    **Using API:**
    ```javascript
    const commentElement = Velt.getCommentElement();
    commentElement.enableShortUserName();
    commentElement.disableShortUserName();
    ```
  </Tab>
</Tabs>


#### enableSignInButton
![](/images/sign-in-button.png)

Whether to enable Sign In button on comment dialog when user is anonymous or signed out.

`Default: false`

This allows anonymous or signed out users to still read the comments but encourages them to sign in if they want to respond to the comments. 

<Tabs>
<Tab title="React / Next.js">
```js
<VeltComments signInButton={true} />
```
</Tab>

<Tab title="Other Frameworks">
```js
<velt-comments sign-in-button="true"></velt-comments>
```
</Tab>


</Tabs>
API Method:
<Tabs>
<Tab title="React / Next.js">
```jsx
const commentElement = client.getCommentElement();
commentElement.enableSignInButton();
commentElement.disableSignInButton();
```
</Tab>

<Tab title="Other Frameworks">

```jsx
const commentElement = Velt.getCommentElement();
commentElement.enableSignInButton();
commentElement.disableSignInButton();
```
</Tab>


</Tabs>

#### enableSidebarButtonOnCommentDialog

![](/images/sidebar-button-on-comment-dialog.png)

Whether the Sidebar Button on Comment Dialogs show up.

`Default: true`

By Default, each Comment Dialog has a button at the bottom that will open the Comments Sidebar when clicked.

To disable it, you can set it to false:

<Tabs>
<Tab title="React / Next.js">
**Using Props:**
```jsx
<VeltComments sidebarButtonOnCommentDialog={true} />
```

**Using API methods:**
```jsx
const commentElement = client.getCommentElement();
commentElement.enableSidebarButtonOnCommentDialog()
commentElement.disableSidebarButtonOnCommentDialog() 
```
</Tab>

<Tab title="Other Frameworks">
**Using Props:**
```jsx
<velt-comments sidebar-button-comment-dialog="true"></velt-comments>
```

**Using API methods:**
```jsx
const commentElement = Velt.getCommentElement();
commentElement.enableSidebarButtonOnCommentDialog()
commentElement.disableSidebarButtonOnCommentDialog() 
```
</Tab>

</Tabs>


#### enableDeleteReplyConfirmation

You can enable a confirmation dialog before deleting a reply in comment threads. This feature helps prevent accidental deletions and improves user experience.

<Tabs>
  <Tab title="React / Next.js">
  Using Props:
    ```jsx
    <VeltComments deleteReplyConfirmation={true} />
    ```

    Using API:
    ```javascript
    const commentElement = client.getCommentElement();
    commentElement.enableDeleteReplyConfirmation();
    commentElement.disableDeleteReplyConfirmation();
    ```
  </Tab>
  
  <Tab title="Other Frameworks">
  Using Props:
    ```html
    <velt-comments delete-reply-confirmation="true"></velt-comments>
    ```
    Using API:
    ```javascript
    const commentElement = Velt.getCommentElement();
    commentElement.enableDeleteReplyConfirmation();
    commentElement.disableDeleteReplyConfirmation();
    ```
  </Tab>
</Tabs>

#### enableMobileMode
![](/images/mobile-mode.png)

![](/images/mobile-mode-composer.png)

Whether mobile mode is enabled.

When mobile mode is enabled and the screen width is small enough, comment windows will appear fixed to the bottom of the screen and full width instead of the usual popup window.

`Default: false`
<Tabs>
<Tab title="React / Next.js">
```js
<VeltComments mobileMode={true} />
````
</Tab>

<Tab title="Other Frameworks">
```js
<velt-comments mobile-mode="true"></velt-comments>
````
</Tab>


</Tabs>
API Method:
<Tabs>
<Tab title="React / Next.js">
```jsx
const commentElement = client.getCommentElement();
commentElement.enableMobileMode();
commentElement.disableMobileMode();
```
</Tab>

<Tab title="Other Frameworks">
```jsx
const commentElement = Velt.getCommentElement();
commentElement.enableMobileMode();
commentElement.disableMobileMode();
```
</Tab>

</Tabs>

#### enableCommentPinHighlighter

![](/images/pin-highlighter-outline.png)

Wheter the pin highlighter outline is enabled or not.

`Default: true`

<Tabs>
<Tab title="React / Next.js">
```jsx
<VeltComments commentPinHighlighter={false} />
```
</Tab>

<Tab title="Other Frameworks">
```jsx
<velt-comments comment-pin-highlighter="false"></velt-comments>
```
</Tab>


</Tabs>
API Methods:

<Tabs>
<Tab title="React / Next.js">
```jsx
const commentElement = client.getCommentElement();
commentElement.enableCommentPinHighlighter(); // to enable comment pin highlight
commentElement.disableCommentPinHighlighter(); // to disable comment pin highlight
```
</Tab>

<Tab title="Other Frameworks">

```jsx
const commentElement = Velt.getCommentElement();
commentElement.enableCommentPinHighlighter(); // to enable comment pin highlight
commentElement.disableCommentPinHighlighter(); // to disable comment pin highlight
```
</Tab>


</Tabs>


#### enableDialogOnHover
![](/gifs/show-dialog-on-hover.gif)

Whether the comment dialog shows on hover over the comment pin or the target element.

`Default: true`
<Tabs>
<Tab title="React / Next.js">
```js
<VeltComments dialogOnHover={true} />
````
</Tab>

<Tab title="Other Frameworks">
```js
<velt-comments dialog-on-hover="true"></velt-comments>
````

</Tab>


</Tabs>
API Method:
<Tabs>
<Tab title="React / Next.js">
```jsx
const commentElement = client.getCommentElement();
commentElement.enableDialogOnHover();
commentElement.disableDialogOnHover();
```
</Tab>

<Tab title="Other Frameworks">

```jsx
const commentElement = Velt.getCommentElement();
commentElement.enableDialogOnHover();
commentElement.disableDialogOnHover();
```
</Tab>


</Tabs>

#### enableFloatingCommentDialog
![](/gifs/floating-comment-dialog.gif)

Whether floating comment dialog is shown next to comment pin on hover or click.

`Default: true`
<Tabs>
<Tab title="React / Next.js">
```js
<VeltComments floatingCommentDialog={true} />
````
</Tab>

<Tab title="Other Frameworks">
```js
<velt-comments floating-comment-dialog="true"></velt-comments>
````

</Tab>


</Tabs>

API Method:
<Tabs>
<Tab title="React / Next.js">
```jsx
const commentElement = client.getCommentElement();
commentElement.enableFloatingCommentDialog();
commentElement.disableFloatingCommentDialog();
```
</Tab>

<Tab title="Other Frameworks">
```jsx
const commentElement = Velt.getCommentElement();
commentElement.enableFloatingCommentDialog();
commentElement.disableFloatingCommentDialog();
```
</Tab>

</Tabs>


#### excludeLocationIds

Use this to filter out Comments at a specific Location for certain Users.
<Tabs>
<Tab title="React / Next.js">
```jsx
const locationIds = ['location1', 'location2']; // list of location ids
client.excludeLocationIds(locationIds);
```

To reset it, you can pass an empty array:

```jsx
client.excludeLocationIds([]);
```
</Tab>

<Tab title="Other Frameworks">
```jsx
const locationIds = ['location1', 'location2']; // list of location ids
Velt.excludeLocationIds(locationIds);
```

To reset it, you can pass an empty array:

```jsx
Velt.excludeLocationIds([]);
```
</Tab>
</Tabs>

#### filterCommentsOnDom

- Filter out comments in the DOM when they are filtered in the sidebar.
- When the sidebar is closed (default mode) or unmounted (embed mode), the DOM filter will be removed.

`Default: false`
<Tabs>
  <Tab title="React / Next.js">
  **Using Props:**
  ```jsx
  <VeltComments filterCommentsOnDom={true} />
  ```
  **Using API:**
  ```js
  const commentElement = client.getCommentElement();
  commentElement.enableFilterCommentsOnDom();
  commentElement.disableFilterCommentsOnDom();
  ```
  </Tab>
  <Tab title="Other Frameworks">
  **Using Props:**
  ```html
  <velt-comments filter-comments-on-dom="true"></velt-comments>
  ```
  **Using API:**
  ```js
  const commentElement = Velt.getCommentElement();
  commentElement.enableFilterCommentsOnDom();
  commentElement.disableFilterCommentsOnDom();
  ```
  </Tab>
</Tabs>





#### onSidebarButtonOnCommentDialogClick

Use this to act on clicks on the Sidebar Button at the bottom of the Comment Dialog.

![](images/customization/onSidebarOnCommentDialogClick.png)

<Tabs>
<Tab title = "React / Next.js">

**Using Props:**
```jsx
<VeltComments onSidebarButtonOnCommentDialogClick={(event)=>yourMethod(event)} />
```
**Using Hooks:**
```jsx
const commentDialogSidebarClickEvent = useCommentDialogSidebarClickHandler();
useEffect(() => {
  console.log('CommentDialog Sidebar button clicked');
}, [commentDialogSidebarClickEvent]);
```

**Using API methods:**
```jsx
const commentElement = client.getCommentElement();
let subscription = commentElement.onSidebarButtonOnCommentDialogClick().subscribe((event) => yourMethod(event));
```
To unsubscribe from the subscription:
```jsx
subscription?.unsubscribe()
```
</Tab>

<Tab title = "HTML">

**Using Props:**
```jsx
<velt-comments onsidebarbuttononcommentdialogclick="yourMethod(event)"></velt-comments>
```
**Using API Methods:**
```jsx
const commentElement = Velt.getCommentElement();
let subscription = commentElement.onSidebarButtonOnCommentDialogClick().subscribe((event) => yourMethod(event));
```
To unsubscribe from the subscription:
```jsx
subscription?.unsubscribe()
```
</Tab>
</Tabs>



#### onSignIn
When the user clicks on the sign in button, we will emit an `onSignIn` event that you can handle with your own sign in method. 

No data is passed with the event.
<Tabs>
<Tab title="React / Next.js">
```js
<VeltComments onSignIn={() => yourSignInMethod()} />
```
</Tab>

<Tab title="Other Frameworks">
```js
const veltCommentsTag = document.querySelector('velt-comments');

veltCommentsTag?.addEventListener('onSignIn', (event) => {
  console.log('*** onCommentSignIn ***');
  console.log(event.detail);
});
```
</Tab>


</Tabs>

#### enableReplyAvatars

This shows the avatars of unique users who have replied to a comment.
  - `replyAvatars`: Whether the reply avatar component is enabled.
  - `maxReplyAvatars`: The maximum number of reply avatars to show. It will show the count of remaining unque users as the next avatar.

`Default: false`

<Tabs>
  <Tab title="React / Next.js">
  **Using props:**
  ```jsx
  <VeltComments maxReplyAvatars={2} replyAvatars={true} />
  ```

  **Using API:**
  ```jsx
  const commentsElement = client.getCommentsElement();
  commentsElement.enableReplyAvatars(); // Enables the reply avatar component.
  commentsElement.disableReplyAvatars(); // Disables the reply avatar component.
  commentsElement.setMaxReplyAvatars(2); // Sets the maximum number of reply avatars to show.
  ```

  </Tab>
  
  <Tab title="Other Frameworks">
  **Using props:**
  ```html
  <velt-comments max-reply-avatars="2" reply-avatars="true"></velt-comments>
  ```

  **Using API:**
  ```jsx
  const commentsElement = Velt.getCommentsElement();
  commentsElement.enableReplyAvatars(); // Enables the reply avatar component.
  commentsElement.disableReplyAvatars(); // Disables the reply avatar component.
  commentsElement.setMaxReplyAvatars(2); // Sets the maximum number of reply avatars to show.
  ```
  </Tab>
  </Tabs>






#### showCommentsOnDom
Whether comments are shown on the DOM.

`Default: true`

By default, all the comments will be visible on DOM whenever we are able to detect to elements for that. But users can hide it from DOM if required.


There are 2 ways to show/hide comments on DOM:

Configuring attributes on the React Component:
<Tabs>
<Tab title="React / Next.js">
```js
{/* `true` to show comments, `false` to hide comments */}
<VeltComments commentsOnDom={false} />
```
</Tab>

<Tab title="Other Frameworks">
```js
<!-- `true` to show comments, `false` to hide comments -->
<velt-comments comments-on-dom="false"></velt-comments>
```

</Tab>


</Tabs>
Using API methods:
<Tabs>
<Tab title="React / Next.js">
```js
const commentElement = client.getCommentElement();
// to show comments on DOM
commentElement.showCommentsOnDom();
// to hide comments on DOM
commentElement.hideCommentsOnDom();
```
</Tab>

<Tab title="Other Frameworks">
```js
const commentElement = Velt.getCommentElement();
// to show comments on DOM
commentElement.showCommentsOnDom();
// to hide comments on DOM
commentElement.hideCommentsOnDom();
```
</Tab>

</Tabs>

#### showResolvedCommentsOnDom

Whether to show resolved comments on the DOM.

`Default: false`
<Tabs>
<Tab title="React / Next.js">
```jsx
<VeltComments resolvedCommentsOnDom={true} />
```
</Tab>

<Tab title="Other Frameworks">
```html
<velt-comments resolved-comments-on-dom="true"></velt-comments>
```

</Tab>


</Tabs>
API Methods:
<Tabs>
<Tab title="React / Next.js">
```jsx
const commentElement = client.getCommentElement();
// To show resolved comments on dom
commentElement.showResolvedCommentsOnDom();
// To hide resolved comments on dom
commentElement.hideResolvedCommentsOnDom();
```
</Tab>

<Tab title="Other Frameworks">

```jsx
const commentElement = Velt.getCommentElement();
// To show resolved comments on dom
commentElement.showResolvedCommentsOnDom();
// To hide resolved comments on dom
commentElement.hideResolvedCommentsOnDom();
```
</Tab>

</Tabs>


#### updateCommentDialogPosition
- Sometimes when you manually set the position of the Comment Pin, the Comment Dialog might not position itself near the pin in certain scenarios like scrolling, zooming the page when the comment dialog is open.
- Use this to manually trigger an update. The dialog will reposition itself near the pin.
<Tabs>
<Tab title="React / Next.js">

```jsx
const commentElement = client.getCommentElement();
commentElement.updateCommentDialogPosition();
```

</Tab>

<Tab title="Other Frameworks">
```jsx
const commentElement = Velt.getCommentElement();
commentElement.updateCommentDialogPosition();
```
</Tab>
</Tabs>

You can add custom lists at two levels: a. on the CommentAnnotation and b. on the Comment.

#### Link Callback

Enable a callback when users click on links rendered in comment content. When enabled, links wonâ€™t automatically open; instead an event is emitted.

How to use:
- By default `linkCallback` is `false`.
- When `false`, clicking a link opens it directly and no callback is triggered.
- When `true`, clicking a link does not open it; instead a `linkClicked` event is emitted so you can handle navigation.

<Tabs>
<Tab title="React / Next.js">
```jsx
// Using Props
<VeltComments linkCallback={true} />

// Using Hooks
const linkEvent = useCommentEventCallback('linkClicked')
useEffect(() => {
  if (linkEvent) {
    console.log('linkClicked', linkEvent);
  }
}, [linkEvent]);

// Using API
const commentElement = client.getCommentElement();
commentElement.on('linkClicked').subscribe((linkData) => {
  console.log('linkClicked', linkData);
});
```
</Tab>

<Tab title="Other Frameworks">
```html
<velt-comments link-callback="true"></velt-comments>

<script>
  const commentElement = Velt.getCommentElement();
  commentElement.on('linkClicked').subscribe((linkData) => {
    console.log('Comment link clicked:', linkData);
  });
</script>
```
</Tab>
</Tabs>

Types:
```ts
export interface LinkClickedEvent {
  text: string;
  link: string;
  commentAnnotation: CommentAnnotation;
  commentId: Number;
  metadata?: VeltEventMetadata;
}
```


# Extra Information
#### enableCommentIndex
![](/images/index-indicator.png)

Whether comment index is enabled.

`Default: false`

This appears in the comment sidebar and on the comment pins. When this is on, we show a small icon indicating the comment index in the order of creation date. This enables users to find and navigate to the desired comment quickly.

<Tabs>
<Tab title="React / Next.js">
```js
<VeltComments commentIndex={true} />
````
</Tab>

<Tab title="Other Frameworks">
```js
<velt-comments comment-index="true"></velt-comments>
````

</Tab>
</Tabs>

API Method:
<Tabs>
<Tab title="React / Next.js">
```jsx
const commentElement = client.getCommentElement();
commentElement.enableCommentIndex();
commentElement.disableCommentIndex();
```
</Tab>

<Tab title="Other Frameworks">
```jsx
const commentElement = Velt.getCommentElement();
commentElement.enableCommentIndex();
commentElement.disableCommentIndex();
```
</Tab>
</Tabs>

#### enableDeviceInfo
![](/images/device-info.png)

Whether device type indicator is enabled.

`Default: false`

When this is on, we show additional information in the `Comment Thread` indicating which device the comment was created on. This is useful especially for design tools, where additional context is needed for debugging issues.

<Tabs>
<Tab title="React / Next.js">
```js
<VeltComments deviceInfo={true} />
```
</Tab>

<Tab title="Other Frameworks">
```js
<velt-comments device-info="true"></velt-comments>
```

</Tab>
</Tabs>

API Method:
<Tabs>
<Tab title="React / Next.js">

```jsx
const commentElement = client.getCommentElement();
commentElement.enableDeviceInfo();
commentElement.disableDeviceInfo();
```
</Tab>

<Tab title="Other Frameworks">
```jsx
const commentElement = Velt.getCommentElement();
commentElement.enableDeviceInfo();
commentElement.disableDeviceInfo();
```
</Tab>
</Tabs>


#### enableDeviceIndicatorOnCommentPins
![](/images/device-info-pin.png)


Whether the device type indicator on `Comment Pins` is enabled.

`Default: false`

When this is on, we show a small device type icon on the `Comment Pin` indicating which device the comment was created on. This is useful especially for design tools, where additional context is needed for debugging issues.
<Tabs>
<Tab title="React / Next.js">
```js
<VeltComments deviceIndicatorOnCommentPins={true} />
````
</Tab>

<Tab title="Other Frameworks">
```jsx
<velt-comments device-indicator-on-comment-pins="true"></velt-comments>
```
</Tab>
</Tabs>


API Method:
<Tabs>
<Tab title="React / Next.js">
```jsx
const commentElement = client.getCommentElement();
commentElement.enableDeviceIndicatorOnCommentPins();
commentElement.disableDeviceIndicatorOnCommentPins();
```
</Tab>

<Tab title="Other Frameworks">
```jsx
const commentElement = Velt.getCommentElement();
commentElement.enableDeviceIndicatorOnCommentPins();
commentElement.disableDeviceIndicatorOnCommentPins();
```
</Tab>
</Tabs>

#### enableGhostComments

![](/images/ghost-comment-pin.png)

![](/images/ghost-comment-dialog-box.png)

Whether to show ghost comments on the DOM.

`Default: false`

Ghost comments are comments that were once linked to certain content on the DOM but that content is no longer available. If this is on, we display ghost comments in gray, close to where they were originally positioned on the DOM.
<Tabs>
<Tab title="React / Next.js">
```js
<VeltComments ghostComments={true} />
```

**Using API methods:**
```jsx
const commentElement = client.getCommentElement();
commentElement.enableGhostComments();
commentElement.disableGhostComments();
```
</Tab>

<Tab title="Other Frameworks">
```js
<velt-comments ghost-comments="true"></velt-comments>
```
**Using API methods:**
```jsx
const commentElement = Velt.getCommentElement();
commentElement.enableGhostComments();
commentElement.disableGhostComments();
```
</Tab>
</Tabs>


#### enableGhostCommentsIndicator
![](/images/ghost-comment-sidebar.png)

Whether to show ghost comment labels in the comment sidebar.

`Default: true`

Ghost comments are always shown in the comments sidebar so that users can see the history of all comments. If this is on, we show a label on the comment in the sidebar indicating that the original content on which this comment was added is no longer available. This sets better expectations with the users.

<Tabs>
<Tab title="React / Next.js">
```js
<VeltComments ghostCommentsIndicator={true} />
```
**Using API methods:**
```jsx
const commentElement = client.getCommentElement();
commentElement.enableGhostCommentsIndicator();
commentElement.disableGhostCommentsIndicator();
```
</Tab>

<Tab title="Other Frameworks">
```html
<velt-comments ghost-comments-indicator="true"></velt-comments>
```
**Using API methods:**
```jsx
const commentElement = Velt.getCommentElement();
commentElement.enableGhostCommentsIndicator();
commentElement.disableGhostCommentsIndicator();
```
</Tab>

</Tabs>

# Special File Type Support
#### Iframe Container Support

![](/images/iframe-comment.png)


- To enable comments on an iframe, add `data-velt-iframe-container="true"` to the iframe's container element.
- Note this will not insert the comments inside the contents of the iframe, but rather on top of the iframe.

```html
<div data-velt-iframe-container="true">
	<iframe src="https://www.wikipedia.org/" width="500px" height="500px"></iframe>
</div>
```

#### data-velt-pdf-viewer
![](/images/pdf-comments.png)

To support comments on top of a pdf viewer, add the `data-velt-pdf-viewer="true"` attribute in the container element of the pdf viewer.

```html
<!-- Add this attribute to the container of your pdf viewer -->
<div id="viewerContainer" data-velt-pdf-viewer="true">
    <!-- Your pdf viewer here -->
    <div id="viewer" class="pdfViewer"></div>
</div>
```

#### svgAsImg

- By default, Velt SDK treats SVGs as layered elements.
- If you want to treat SVGs as flat images, you can use this.
- Default: `false`

<Tabs>
<Tab title="React / Next.js">
**Using Props:**
```jsx
<VeltComments svgAsImg={true} />
```

**Using API:**
```jsx
const commentElement = client.getCommentElement();
commentElement.enableSvgAsImg();
commentElement.disableSvgAsImg();
```
</Tab>
<Tab title="Other Frameworks">
**Using Props:**
```html
<velt-comments svg-as-img="true"></velt-comments>
```

**Using API:**
```html
const commentElement = client.getCommentElement();
commentElement.enableSvgAsImg();
commentElement.disableSvgAsImg();
```
</Tab>
</Tabs>

# Keyboard Controls
#### enableHotkey

Whether Hotkeys are enabled or not. For now, the only hotkey supported is pressing `c` to enable `comment mode`.

`Default: false`

<Tabs>
<Tab title="React / Next.js">
**Using Props:**
```jsx
<VeltComments hotkey={false} />
```
**Using API Method:**
```jsx
const commentElement = client.getCommentElement();
commentElement.enableHotkey();
commentElement.disableHotkey();
```
</Tab>

<Tab title="Other Frameworks">
**Using Props:**
```html
<velt-comments hotkey="true"></velt-comments>
```
**Using API Method:**
```jsx
const commentElement = Velt.getCommentElement();
commentElement.enableHotkey();
commentElement.disableHotkey();
```
</Tab>
</Tabs>

#### enableEnterKeyToSubmit

- By default, pressing `enter` will add a new line and pressing `shift` + `enter` will submit a comment.
- You can change this default behavior so that pressing `enter` will submit a comment by setting the `enterKeyToSubmit` property to `true`.

<Tabs>
<Tab title="React / Next.js">
**Using Props:**
```jsx
<VeltComments enterKeyToSubmit={true} />
```
**Using API Method:**
```jsx
const commentElement = client.getCommentElement();
commentElement.enableEnterKeyToSubmit();
commentElement.disableEnterKeyToSubmit();
```
</Tab>

<Tab title="Other Frameworks">
**Using Props:**
```jsx
<velt-comments enter-key-to-submit="true"></velt-comments>
```
**Using API Method:**
```jsx
const commentElement = Velt.getCommentElement();
commentElement.enableEnterKeyToSubmit();
commentElement.disableEnterKeyToSubmit();
```
</Tab>
</Tabs>

#### enableDeleteOnBackspace

- Use this to enable or disable deleting comments when backpsace key is pressed.

Default: `enabled`

<Tabs>
<Tab title="React / Next.js">
**Using Props:**
```jsx
<VeltComments deleteOnBackspace={false} />
```

**Using API:**
```jsx
const commentElement = client.getCommentElement();
commentElement.enableDeleteOnBackspace();
commentElement.disableDeleteOnBackspace();
```

</Tab>

<Tab title="Other Frameworks">
**Using Props:**
```jsx
<velt-comments delete-on-backspace="false"></velt-comments>
```

**Using API:**
```jsx
const commentElement = client.getCommentElement();
commentElement.enableDeleteOnBackspace();
commentElement.disableDeleteOnBackspace();
```
</Tab>
</Tabs>

# Moderation
#### enableModeratorMode

![](/images/moderator-mode.png)

Whether comments require moderator approval.

`Default: false`

By default, when a user adds a comment it is visible to all authenticated users on the same `document`. Moderator mode makes visibility of all comments private to only `admin` users and the comment author. Admin users will see an approve button on the comment dialog. Once approved the comment will be visible to all users who can access the `document`.

You can set some users as `admin` by setting the `isAdmin` property in the User object, during the `identify()` call.
<Tabs>
<Tab title="React / Next.js">
```js
<VeltComments moderatorMode={true} />
```
</Tab>

<Tab title="Other Frameworks">
```js
<velt-comments moderator-mode="true"></velt-comments>
```
</Tab>


</Tabs>
API Method:
<Tabs>
<Tab title="React / Next.js">
```jsx
const commentElement = client.getCommentElement();
commentElement.enableModeratorMode();
commentElement.disableModeratorMode();
```
</Tab>

<Tab title="Other Frameworks">
```jsx
const commentElement = Velt.getCommentElement();
commentElement.enableModeratorMode();
commentElement.disableModeratorMode();
```
</Tab>


</Tabs>

#### enableResolveStatusAccessAdminOnly

- Restrict the resolve action to admin users and the comment author only.

<Tabs>
    <Tab title="React / Next.js">
      **Using props:**
      ```jsx
      <VeltComments resolveStatusAccessAdminOnly={true} />
      ```
      **Using API:**
      ```javascript
      const commentElement = client.getCommentElement();
      // To enable resolve status access admin only
      commentElement.enableResolveStatusAccessAdminOnly();
      // To disable resolve status access admin only
      commentElement.disableResolveStatusAccessAdminOnly();
      ```
    </Tab>
    <Tab title="Other Frameworks">
      **Using props:**
      ```html
      <velt-comments resolve-status-access-admin-only="true"></velt-comments>
      ```
      **Using API:**
      ```javascript
      const commentElement = Velt.getCommentElement();
      // To enable resolve status access admin only
      commentElement.enableResolveStatusAccessAdminOnly();
      // To disable resolve status access admin only
      commentElement.disableResolveStatusAccessAdminOnly();
      ```
    </Tab>
  </Tabs>

#### approveCommentAnnotation

- Approves a comment annotation in moderator mode
- Params: [ApproveCommentAnnotationRequest](/api-reference/sdk/models/data-models#approvecommentannotationrequest)
- Returns: [ApproveCommentAnnotationEvent](/api-reference/sdk/models/data-models#approvecommentannotationevent)

<Tabs>
<Tab title="React / Next.js">
```jsx
const approveCommentAnnotationRequest = {
  annotationId: 'ANNOTATION_ID'
};

// Hook
const { approveCommentAnnotation } = useApproveCommentAnnotation();
const approveCommentAnnotationEvent = await approveCommentAnnotation(approveCommentAnnotationRequest);

// API Method
const commentElement = client.getCommentElement();
const approveCommentAnnotationEvent = await commentElement.approveCommentAnnotation(approveCommentAnnotationRequest);
```
</Tab>

<Tab title="Other Frameworks">
```js
const approveCommentAnnotationRequest = {
  annotationId: 'ANNOTATION_ID'
};

const commentElement = Velt.getCommentElement();
const approveCommentAnnotationEvent = await commentElement.approveCommentAnnotation(approveCommentAnnotationRequest);
```
</Tab>
</Tabs>


#### acceptCommentAnnotation

- Accepts a comment annotation in suggestion mode
- Params: [AcceptCommentAnnotationRequest](/api-reference/sdk/models/data-models#acceptcommentannotationrequest)  
- Returns: [AcceptCommentAnnotationEvent](/api-reference/sdk/models/data-models#acceptcommentannotationevent)

<Tabs>
<Tab title="React / Next.js">
```jsx
const acceptCommentAnnotationRequest = {
  annotationId: 'ANNOTATION_ID'
};

// Hook
const { acceptCommentAnnotation } = useAcceptCommentAnnotation();
const acceptCommentAnnotationEventData = await acceptCommentAnnotation(acceptCommentAnnotationRequest);

// API Method
const commentElement = client.getCommentElement();
const acceptCommentAnnotationEventData = await commentElement.acceptCommentAnnotation(acceptCommentAnnotationRequest);
```
</Tab>

<Tab title="Other Frameworks">
```js
const acceptCommentAnnotationRequest = {
  annotationId: 'ANNOTATION_ID'
};

const commentElement = Velt.getCommentElement();
const acceptCommentAnnotationEventData = await commentElement.acceptCommentAnnotation(acceptCommentAnnotationRequest);
```
</Tab>
</Tabs>

#### rejectCommentAnnotation

- Rejects a comment annotation in suggestion mode
- Params: [RejectCommentAnnotationRequest](/api-reference/sdk/models/data-models#rejectcommentannotationrequest)  
- Returns: [RejectCommentAnnotationEvent](/api-reference/sdk/models/data-models#rejectcommentannotationevent)

<Tabs>
<Tab title="React / Next.js">
```jsx
const rejectCommentAnnotationRequest = {
  annotationId: 'ANNOTATION_ID'
};

// Hook
const { rejectCommentAnnotation } = useRejectCommentAnnotation();
const rejectCommentAnnotationEventData = await rejectCommentAnnotation(rejectCommentAnnotationRequest);

// API Method
const commentElement = client.getCommentElement();
const rejectCommentAnnotationEventData = await commentElement.rejectCommentAnnotation(rejectCommentAnnotationRequest);
```
</Tab>

<Tab title="Other Frameworks">
```js
const rejectCommentAnnotationRequest = {
  annotationId: 'ANNOTATION_ID'
};

const commentElement = Velt.getCommentElement();
const rejectCommentAnnotationEventData = await commentElement.rejectCommentAnnotation(rejectCommentAnnotationRequest);
```
</Tab>
</Tabs>


#### enableSuggestionMode

![](/images/accept-reject.png)

Whether to enable suggestion mode to accept or reject comments.

`Default: false`


<Tabs>
<Tab title="React / Next.js">
To accept comments, set the `suggestionMode` attribute to `true`.
```js
<VeltComments suggestionMode={true} />
```
</Tab>

<Tab title="Other Frameworks">
To accept comments, set the `suggestion-mode` attribute to `true`.
```js
<velt-comments suggestion-mode="true"></velt-comments>
```
</Tab>


</Tabs>

API Method:
<Tabs>
<Tab title="React / Next.js">
```jsx
const commentElement = client.getCommentElement();
commentElement.enableSuggestionMode();
commentElement.disableSuggestionMode();
```

</Tab>

<Tab title="Other Frameworks">
```jsx
const commentElement = Velt.getCommentElement();
commentElement.enableSuggestionMode();
commentElement.disableSuggestionMode();
```
</Tab>


</Tabs>

#### updateAccess

- Updates access permissions for a comment annotation
- Params: [UpdateAccessRequest](/api-reference/sdk/models/data-models#updateaccessrequest)
- Returns: [UpdateAccessEvent](/api-reference/sdk/models/data-models#updateaccessevent)

<Tabs>
<Tab title="React / Next.js">
```jsx
const updateAccessRequest = {
  annotationId: 'ANNOTATION_ID',
  accessMode: 'private';
};

// Hook
const { updateAccess } = useUpdateAccess();
const updateAccessEvent = await updateAccess(updateAccessRequest);

// API Method
const commentElement = client.getCommentElement();
const updateAccessEvent = await commentElement.updateAccess(updateAccessRequest);
```
</Tab>

<Tab title="Other Frameworks">
```js
const updateAccessRequest = {
  annotationId: 'ANNOTATION_ID',
  accessMode: 'private';
  }
};

const commentElement = Velt.getCommentElement();
const updateAccessEvent = await commentElement.updateAccess(updateAccessRequest);
```
</Tab>
</Tabs>


#### enablePrivateComments

![](/images/private-comment.png)

- Private comment mode enables admin users to add comments that are only visible to other admin users.
- Use this to enable or disable private comment mode.

Default: `false`

<Tabs>
<Tab title="React / Next.js">
To enable private comment mode, set the `privateCommentMode` attribute to `true`:
```html
<VeltComments privateCommentMode={true} />
```
</Tab>

<Tab title="Other Frameworks">
To enable private comment mode, set the `private-comment-mode` attribute to `true`:
```html
<velt-comments private-comment-mode="true"></velt-comments>
```
</Tab>


</Tabs>
API Methods:
API to enable/disable private comment mode:
<Tabs>
<Tab title="React / Next.js">
```jsx
const commentElement = client.getCommentElement();
// To enable private comment mode
commentElement.enablePrivateCommentMode();
// To disable private comment mode
commentElement.disablePrivateCommentMode();
```
</Tab>

<Tab title="Other Frameworks">

```jsx
const commentElement = Velt.getCommentElement();
// To enable private comment mode
commentElement.enablePrivateCommentMode();
// To disable private comment mode
commentElement.disablePrivateCommentMode();
```
</Tab>


</Tabs>


#### enableReadOnly
Control whether comments are in read-only mode. When enabled, any features requiring user interaction (e.g., Composer, Reactions, Status) will be removed.

Default: `false`

<Tabs>
  <Tab title="React / Next.JS">
    Using Props:
    ```jsx
    <VeltComments readOnly={true} />
    ```

    Using API:
    ```js
      const commentElement = client.getCommentElement();
      commentElement.enableReadOnly();
      commentElement.disableReadOnly();
    ```
  </Tab>

  <Tab title="Other Frameworks">
    Using Props:
    ```html
    <velt-comments read-only="true"></velt-comments>
    ```

    Using API:
    ```js
      const commentElement = Velt.getCommentElement();
      commentElement.enableReadOnly();
      commentElement.disableReadOnly();
    ```
  </Tab>
</Tabs>



# Comment Read Status

#### enableSeenByUsers
Control whether the "Seen By" feature is enabled for comments. When enabled, it shows which users have seen each comment.

Default: `true`
<Tabs>
    <Tab title="React / Next.js">
      **Using Props:**
      ```jsx
      <VeltComments seenByUsers={false} />
      ```
      **Using API:**
      ```jsx
      const commentElement = client.getCommentElement();
      commentElement.enableSeenByUsers();
      commentElement.disableSeenByUsers();
      ```
    </Tab>
    <Tab title="Other Frameworks">
      **Using Props:**
      ```html
      <velt-comments seen-by-users="false"></velt-comments>
      ```
      **Using API:**
      ```javascript
      const commentElement = Velt.getCommentElement();
      commentElement.enableSeenByUsers();
      commentElement.disableSeenByUsers();
      ```
    </Tab>
  </Tabs>


#### setUnreadIndicatorMode

Whether `verbose` mode is enabled for unread `Comments`. 

`Default: 'minimal'`

Unread `Comments` can be in `minimal` mode or `verbose` mode.

In `minimal` mode, a small red dot indicator appears for unread `Comments`.

In `verbose` mode, a larger badge with the text "UNREAD" will appear for unread `Comments`.


<Frame>
![](/images/unread-compare.png)
</Frame>

<Tabs>
<Tab title="React / Next.js">
```jsx
<VeltComments unreadIndicatorMode={"verbose"} />
```
</Tab>

<Tab title="Other Frameworks">
```jsx
<velt-comments unread-indicator-mode="verbose"></velt-comments>
```

</Tab>
</Tabs>

API Method:
<Tabs>
<Tab title="React / Next.js">
```jsx
const commentElement = client.getCommentElement();
commentElement.setUnreadIndicatorMode("verbose"); // use badge with text UNREAD
commentElement.setUnreadIndicatorMode("minimal"); // use small red dot indicator
```
</Tab>

<Tab title="Other Frameworks">
```jsx
const commentElement = Velt.getCommentElement();
commentElement.setUnreadIndicatorMode("verbose"); // use badge with text UNREAD
commentElement.setUnreadIndicatorMode("minimal"); // use small red dot indicator
```
</Tab>
</Tabs>

# Toggle Comment Types

#### enableAreaComment

Area comments allows users to draw a rectangle and attach a comment to it.
Use this to enable or disable area comments. 

Default: `true`

![](/images/enable-disable-area-comments.png)

<Tabs>
<Tab title="React / Next.js">
**Using Props:**
```jsx
<VeltComments areaComment={false} />
```

**Using API Method:**
```jsx
const commentElement = client.getCommentElement();
commentElement.enableAreaComment();
commentElement.disableAreaComment();
```
</Tab>

<Tab title="Other Frameworks">
**Using Props:**
```jsx
<velt-comments area-comment="false"></velt-comments>
```

Using API Method:
```jsx
const commentElement = client.getCommentElement();
commentElement.enableAreaComment();
commentElement.disableAreaComment();
```
</Tab>
</Tabs>

#### enablePopoverMode
<Info>For a complete setup guide for Popover mode, [read here](/async-collaboration/comments/setup/popover).</Info>

Whether Popover Mode is enabled.

Default: `false`
<Tabs>
<Tab title="React / Next.js">
```jsx
<VeltComments popoverMode={true}/>
```

**Using API:**
```jsx
const commentElement = client.getCommentElement();
commentElement.enablePopoverMode();
commentElement.disablePopoverMode();
```
</Tab>

<Tab title="Other Frameworks">
```jsx
<velt-comments popover-mode="true"></velt-comments> 
```

**Using API:**
```jsx
const commentElement = Velt.getCommentElement();
commentElement.enablePopoverMode();
commentElement.disablePopoverMode();
```

</Tab>


</Tabs>


#### enableStreamMode
<Info>For a complete setup guide for Stream mode, [read here](/async-collaboration/comments/setup/stream).</Info>

Whether Stream Mode is enabled.

Default: `false`
<Tabs>
<Tab title="React / Next.js">
```jsx
<VeltComments streamMode={true}/>
```
**Using API:**
```jsx
const commentElement = client.getCommentElement();
commentElement.enableStreamMode();
commentElement.disableStreamMode();
```
</Tab>

<Tab title="Other Frameworks">
```jsx
<velt-comments stream-mode="true"></velt-comments> 
```
**Using API:**
```jsx
const commentElement = Velt.getCommentElement();
commentElement.enableStreamMode();
commentElement.disableStreamMode();
```
</Tab>


</Tabs>


#### enableTextMode
<Info>For a complete setup guide for Text mode, [read here](/async-collaboration/comments/setup/text).</Info>

Whether Text Mode is enabled.

Default: `true`

![](/images/text-comment.png)



<Tabs>
<Tab title="React / Next.js">
**Using Props:**
```jsx
<VeltComments textMode={true}/>
```

**Using API:**
```jsx
const commentElement = client.getCommentElement();
commentElement.enableTextComments();
commentElement.disableTextComments();
```
</Tab>

<Tab title="Other Frameworks">
**Using Props:**
```html
<velt-comments text-mode="true"></velt-comments> 
```

**Using API:**
```jsx
const commentElement = Velt.getCommentElement();
commentElement.enableTextComments();
commentElement.disableTextComments();
```
</Tab>
</Tabs>


#### enableInlineCommentMode
![](/images/text-comment-opened.png)

Whether In-line comment mode is enabled.

When In-line comment mode is enabled, comments will appear under the text they are associated with in the DOM, instead of as a pop up window.

Default: `false`
<Tabs>
<Tab title="React / Next.js">
```jsx
<VeltComments inlineCommentMode={true}/>
```
```jsx
const commentElement = client.getCommentElement();
commentElement.enableInlineCommentMode();
commentElement.disableInlineCommentMode();
```
</Tab>

<Tab title="Other Frameworks">
```jsx
<velt-comments inline-comment-mode="true"></velt-comments> 
```

```jsx
const commentElement = Velt.getCommentElement();
commentElement.enableInlineCommentMode();
commentElement.disableInlineCommentMode();
```

</Tab>


</Tabs>


#### enableMultithread
- By default comments are single threaded.
- You can make it multithreaded by setting `multiThread` prop to `true`.
- If you had previously used a wireframe for the comment dialog, you will need to add the [multithread wireframe](/ui-customization/features/async/comments/multithread-comment-dialog).
- Default: `false`
<Tabs>
  <Tab title="React / Next.js">
  ```jsx
  <VeltComments multiThread={true} />
  ```
  </Tab>
  <Tab title="Other Frameworks">
  ```html
  <velt-comments multi-thread="true">
  </velt-comments>
  ```
  </Tab>
  </Tabs>


# Comment Tool

#### context
- Add `context` to the `Velt Comment Tool` component to associate custom metadata with comments created using that tool.
- Predefine context directly within the component itself.
- Currently, this feature is specific to popover comments. This allows you to, for example, assign unique context to each cell in a table if you place a `Velt Comment Tool` in each cell.
- The `context` prop accepts an object with key-value pairs.


<Tabs>
<Tab title="React / Next.js">
  ```jsx
  // For popover comments
  <VeltCommentTool context={{ key1: 'value1' }} />
  ```
  </Tab>
  <Tab title="HTML">
  ```html
  <!-- For popover comments. Make sure to stringify the context object. -->
  <velt-comment-tool context='{"key1": "value1"}'></velt-comment-tool>
  ```
  </Tab>
</Tabs>


#### enableCommentMode

![](/images/comment-mode-on-off.png)


Turns Comment mode on or off.

When you click on the comment tool, it turns on comment mode and user can attach comment to any element on the DOM. Using this method you can programmatically turn on the commenting mode.
<Tabs>
<Tab title="React / Next.js">

```jsx
const commentElement = client.getCommentElement();
commentElement.enableCommentMode();
commentElement.disableCommentMode();
```
</Tab>

<Tab title="Other Frameworks">
```jsx
const commentElement = Velt.getCommentElement();
commentElement.enableCommentMode();
commentElement.disableCommentMode();
```
</Tab>


</Tabs>

#### onCommentModeChange

![](/images/onCommentModeChange.png)


The comment mode is toggled on and off when you click on the Comment Tool.

<Tabs>
<Tab title="React / Next.js with Hooks">
The `useCommentModeState()` hook can be used to get the Comment mode without having to subscribe to changes. When the Comment mode changes, the hook return value will update. 

The subscription is automatically unsubscribed when the component dismounts.

```jsx
import { useCommentModeState } from '@veltdev/react';

export default function YourDocument() {

  let commentModeState = useCommentModeState()

  return (
    <div>
       Comment Mode is turned on: {commentModeState}
    </div>
  )
}

```
</Tab>
<Tab title="React / Next.js">
To subscribe to changes in the comment mode, use the `onCommentModeChange()` method , as a property on `VeltCommentTool`:

```jsx
<VeltCommentTool onCommentModeChange={(mode) => onCommentModeChange(mode)} />
```
API method:
```jsx
let subscription = commentElement.onCommentModeChange().subscribe((mode) => {
    //mode contains the state after change
});
```
To unsubscribe from the subscription:
```jsx
subscription?.unsubscribe()
```
</Tab>

<Tab title="Other Frameworks">
API method:
```jsx
const commentElement = Velt.getCommentElement();
let subscription = commentElement.onCommentModeChange().subscribe((mode) => {
    //mode contains the state after change
});
```
To unsubscribe from the subscription:
```jsx
subscription?.unsubscribe()
```
</Tab>
</Tabs>

#### enableCommentTool

![](/images/comment-disabled.png)

Whether the Comment Tool button is Enabled.

`Default: true`

When the Comment Tool is disabled, it can not be used to leave comments. Other ways to leave comments, such as highlighting text, will also be disabled.

<Tabs>
<Tab title="React / Next.js">
**Using Props:**
```jsx
<VeltComments commentTool={false} />
```

Using API methods:
```jsx
const commentElement = client.getCommentElement();
commentElement.enableCommentTool();
commentElement.disableCommentTool();
```
</Tab>

<Tab title="Other Frameworks">
**Using Props:**
```html
<velt-comments comment-tool="false"></velt-comments>
```

**Using API methods:**
```jsx
const commentElement = Velt.getCommentElement();
commentElement.enableCommentTool();
commentElement.disableCommentTool();
```
</Tab>
</Tabs>

#### disabled

Disables the comment tool and prevents users from adding new comments.

This is helpful when you want to temporarily or conditionally restrict comment creation while still allowing users to view existing comments.

Default: `false`

<Note>
This prop disables the specific comment tool instance it is applied to; the `disableCommentTool()` API disables all comment tools globally.
</Note>

<Tabs>
<Tab title="React / Next.js">
```jsx
<VeltCommentTool disabled={true} />
```
</Tab>
<Tab title="Other Frameworks">
```html
<velt-comment-tool disabled="true"></velt-comment-tool>
```
</Tab>
</Tabs>

#### enableChangeDetectionInCommentMode

- By default, DOM Change Detection is disabled in Comment Mode for better performance.
- You can enable it to automatically reposition comment pins when the DOM changes while in Comment Mode.

`Default: false`

<Tabs>
<Tab title="React / Next.js">
**Using Props:**
```jsx
<VeltComments changeDetectionInCommentMode={true} />
```

**Using API Method:**
```jsx
const commentElement = client.getCommentElement();
commentElement.enableChangeDetectionInCommentMode();
commentElement.disableChangeDetectionInCommentMode();
```
</Tab>

<Tab title="Other Frameworks">
**Using Props:**
```html
<velt-comments change-detection-in-comment-mode="true"></velt-comments>
```

**Using API Method:**
```jsx
const commentElement = Velt.getCommentElement();
commentElement.enableChangeDetectionInCommentMode();
commentElement.disableChangeDetectionInCommentMode();
```
</Tab>
</Tabs>

#### enablePersistentCommentMode
- When Persistent comment mode is enabled, you can continue leave additional comments after finishing a comment.
- When it is disabled, you will need to reclick the Comment Tool every time when you want to make a comment.

Default: `false`

<Tabs>
<Tab title="React / Next.js">
```jsx
<VeltComments persistentCommentMode={true}/>
```

```jsx
const commentElement = client.getCommentElement();
commentElement.enablePersistentCommentMode();
commentElement.disablePersistentCommentMode();
```
</Tab>

<Tab title="Other Frameworks">
```jsx
<velt-comments persistent-comment-mode="true"></velt-comments>
```
```jsx
const commentElement = Velt.getCommentElement();
commentElement.enablePersistentCommentMode();
commentElement.disablePersistentCommentMode();
```
</Tab>


</Tabs>

#### forceCloseAllOnEsc
- When enabled, pressing the ESC key will force close persistent comment mode even if a comment thread is currently active.
- When disabled (default), pressing ESC will only close the active comment thread but keep persistent comment mode enabled.
- This provides more control over the ESC key behavior in persistent comment mode.

Default: `false`

<Tabs>
<Tab title="React / Next.js">
```jsx
<VeltComments forceCloseAllOnEsc={true}/>
```

```jsx
const commentElement = client.getCommentElement();
commentElement.enableForceCloseAllOnEsc();
commentElement.disableForceCloseAllOnEsc();
```
</Tab>

<Tab title="Other Frameworks">
```jsx
<velt-comments force-close-all-on-esc="true"></velt-comments>
```
```jsx
const commentElement = Velt.getCommentElement();
commentElement.enableForceCloseAllOnEsc();
commentElement.disableForceCloseAllOnEsc();
```
</Tab>
</Tabs>

#### setPinCursorImage
You can set custom mouse cursor when the comment mode is on.
The custom cursor image must be **32 x 32 pixels**.

<Tabs>
<Tab title="React / Next.js">

```jsx
<VeltComments pinCursorImage={BASE64_IMAGE_STRING} />
```
</Tab>
<Tab title="Other Frameworks">

```jsx
<velt-comments pin-cursor-image="BASE64_IMAGE_STRING"></velt-comments>
```
</Tab>
</Tabs>

API Methods:
 <Tabs>
<Tab title="React / Next.js">

```jsx
const commentElement = client.getCommentElement();
commentElement.setPinCursorImage(BASE64_IMAGE_STRING);
```
</Tab>
<Tab title="Other Frameworks">

```jsx
const commentElement = Velt.getCommentElement();
commentElement.setPinCursorImage(BASE64_IMAGE_STRING);
```
</Tab>
</Tabs>



# Minimap
#### enableMinimap
![](/images/minimap.png)
- The minimap shows a bar on the edge of the screen with indicators that show where comments exist.
- Use this to enable/disable the minimap. By default it's disabled.
- It can be positioned `left` or `right`. By default, it's positioned on the right side of the screen.

**Option a. Enable using config:**
<Tabs>
<Tab title="React / Next.js">
```jsx
<VeltComments minimap={true} minimapPosition="left" />
```

**API Method:**
```jsx
const commentElement = client.getCommentElement();
commentElement.enableMinimap();
commentElement.disableMinimap();
```

</Tab>

<Tab title="Other Frameworks">
```jsx
<velt-comments minimap="true" minimap-position="left"></velt-comments>
```

**API Method:**
```jsx
const commentElement = Velt.getCommentElement();
commentElement.enableMinimap();
commentElement.disableMinimap();
```
</Tab>

</Tabs>


**Option b. Enable using Minimap Component:**
This offers greater flexibility to customize and position the minimap.
<Tabs>
<Tab title="React / Next.js">
```jsx
<div className="relative-container">
  <VeltCommentsMinimap targetScrollableElementId="scrollableElement" position="left" />
  <div id="scrollableElement">
      {/* scrollable content */}
  </div>
</div>

<style>
  .relative-container {
    position: relative;
  }

  #scrollableElement {
    width: 100%;
    height: 200px; /* or any value */
    overflow: auto;
  }
</style>
```
</Tab>

<Tab title="Other Frameworks">
```jsx
<div class="relative-container">
  <velt-comments-minimap target-scrollable-element-id="scrollableElement" position="left"></velt-comments-minimap>
  <div id="scrollableElement">
      <!-- scrollable content -->
  </div>
</div>

<style>
  .relative-container {
    position: relative;
  }

  #scrollableElement {
    width: 100%;
    height: 200px; /* or any value */
    overflow: auto;
  }
</style>
```
</Tab>
</Tabs>


# Inline Comments
#### sortBy and sortOrder

- Change the default sorting order of Comments in the Inline Comments Section.

- Params:
  - `sortBy`: The field to sort by. Currently supports `createdAt` and `lastUpdated`. Default: `lastUpdated` for multithread and `createdAt` for single thread.
  - `sortOrder`: The order to sort by. It can be `asc` or `desc`. Default: `desc` for multithread and `asc` for single thread.


<Tabs>
  <Tab title="React / Next.js">
    ```jsx
      <VeltInlineCommentsSection 
        sortBy="createdAt" 
        sortOrder="desc"
      />
    ```
  </Tab>
  <Tab title="Other Frameworks">
    ```html
      <velt-inline-comments-section
        sort-by="createdAt"
        sort-order="desc"
      ></velt-inline-comments-section>
    ```
  </Tab>
</Tabs>

#### multiThread
- By default [inline comment section](/async-collaboration/comments/setup/inline-comments) is multithreaded.
- You can make it single threaded by setting `multiThread` prop to `false`.
- Default: `true`
<Tabs>
  <Tab title="React / Next.js">
  ```jsx
  <VeltInlineCommentsSection multiThread={false} />
  ```
  </Tab>
  <Tab title="Other Frameworks">
  ```html
  <velt-inline-comments-section multi-thread="false">
  </velt-inline-comments-section>
  ```
  </Tab>
  </Tabs>

#### composerPosition

- Change the position of the comment composer in the inline comments section to `top` or `bottom`.
- Default: `bottom`

<Tabs>
  <Tab title="React / Next.js">
  ```jsx
  <VeltInlineCommentsSection composerPosition="top" />
  ```
  </Tab>
  <Tab title="Other Frameworks">
  ```html
  <velt-inline-comments-section composer-position="top">
  </velt-inline-comments-section>
  ```
  </Tab>
</Tabs>


# Popover Comments
#### enableDialogOnTargetElementClick
![](/gifs/hover-cell-comment.gif)

Whether the comment dialog opens when target element is clicked. This is relevant only for Popover mode.

`Default: true`
<Tabs>
<Tab title="React / Next.js">
```js
<VeltComments dialogOnTargetElementClick={true} />
````
</Tab>

<Tab title="Other Frameworks">
```js
<velt-comments dialog-on-hover="true"></velt-comments>
````
</Tab>


</Tabs>
API Method:
<Tabs>
<Tab title="React / Next.js">
```jsx
const commentElement = client.getCommentElement();
commentElement.enableDialogOnTargetElementClick();
commentElement.disableDialogOnTargetElementClick();
```
</Tab>

<Tab title="Other Frameworks">
```jsx
const commentElement = Velt.getCommentElement();
commentElement.enableDialogOnTargetElementClick();
commentElement.disableDialogOnTargetElementClick();
```
</Tab>


</Tabs>

#### enablePopoverTriangleComponent
Whether the popover triangle appears when Popover Mode is enabled.

`Default: true`
<Tabs>
<Tab title="React / Next.js">
```jsx
<VeltComments popoverTriangleComponent={true}/>
```
</Tab>

<Tab title="Other Frameworks">
```jsx
<velt-comments popover-triangle-component="true"></velt-comments> 
```

</Tab>


</Tabs>

API Method:
<Tabs>
<Tab title="React / Next.js">
```jsx
const commentElement = client.getCommentElement();
commentElement.enablePopoverTriangleComponent();
commentElement.disablePopoverTriangleComponent();
```
</Tab>

<Tab title="Other Frameworks">
```jsx
const commentElement = Velt.getCommentElement();
commentElement.enablePopoverTriangleComponent();
commentElement.disablePopoverTriangleComponent();
```
</Tab>
</Tabs>


# Comment Bubble

#### annotationId
- The id of the comment annotation to show the comment bubble on.
- The bubble will be rendered only if there is a comment annotation that matches the provided `annotationId` in the current document.

<Tabs>
  <Tab title="React / Next.js">
  ```jsx
  <VeltCommentBubble annotationId="annotation-id-1" />
  ```
  </Tab>

  <Tab title="Other Frameworks">
  ```html
  <velt-comment-bubble annotation-id="annotation-id-1"></velt-comment-bubble>
  ```
  </Tab>
</Tabs>

#### targetElementId
- The DOM ID of the element where comment bubble is added.
- This binds the comment bubble to the element with the provided ID.
- The bubble will be rendered only if there is a comment annotation that was added to the element with the provided ID.

<Tabs>

  <Tab title="React / Next.js">
  ```jsx
  <VeltCommentBubble targetElementId="cell-id-1" />
  ```
  </Tab>

  <Tab title="Other Frameworks">
  ```html
  <velt-comment-bubble target-element-id="cell-id-1"></velt-comment-bubble>
  ```
  </Tab>
</Tabs>

#### context
- The `context` object to filter which comment annotations to show the comment bubble for.
- The bubble will be rendered only if there is a comment annotation that matches the provided `context` in the current document.
- Works only with `popover` mode comments.
- Perfect for complex tables with filtering and segmentation needs.
- Set flexible comment anchoring and filtering logic at the cell level using key-value pairs.
- **Supports aggregate views:** Eg: comments added in day view can appear in week/month views automatically.
- Context commonly has combined use with [context options](#contextoptions) and the [group matched comments](#groupmatchedcomments) feature.

<Tabs>
    <Tab title="React / Next.js">
      ```jsx
      <VeltCommentTool context={{ 'key1': 'value1', 'key2': 'value2' }} />
      // Full match
      <VeltCommentBubble context={{ 'key1': 'value1', 'key2': 'value2' }} />
      // Partial match
      <VeltCommentBubble context={{ 'key1': 'value1' }} contextOptions={{ partialMatch: true }} />
      ```
    </Tab>
    <Tab title="Other Frameworks">
      ```html
      <velt-comment-tool context='{"key1": "value1", "key2": "value2"}'></velt-comment-tool>

      <!-- Full match -->
      <velt-comment-bubble context='{"key1": "value1", "key2": "value2"}'></velt-comment-bubble>
      <!-- Partial match -->
      <velt-comment-bubble context='{"key1": "value1"}' context-options='{"partialMatch": true}'></velt-comment-bubble>
      ```
    </Tab>
  </Tabs>

#### contextOptions
- Matching behavior for the context object (default: full match, or set `partialMatch: true` for flexible matching).
- **How Partial Match Works:**
  - A comment will match if ALL provided filter criteria exist in the comment's context
  - Extra fields in the comment's context don't prevent matching
  - Missing fields in the comment's context prevent matching
  - Example: Comment has `{ day: "01", week: "01", month: "jan", product: "cheese", location: "zurich" }`
    - Filter `{ day: "01", product: "cheese" }` â†’ âœ… matches (both fields exist in comment)
    - Filter `{ day: "01", category: "dairy" }` â†’ âŒ no match (category doesn't exist in comment)
- **Partial Match Examples:**
  - Comment has `{ day: "01", week: "01", month: "jan", product: "cheese" }`
  - Filter with `{ day: "01", week: "01", month: "jan", product: "cheese" }` â†’ matches (full)
  - Filter with `{ week: "01", month: "jan", product: "cheese" }` â†’ matches (partial)
  - Filter with `{ day: "01", week: "01", month: "jan", product: "cheese", location: "zurich" }` â†’ no match

#### groupMatchedComments

Whether to group multiple comment annotations in Comment Bubble component when multiple annotations match the provided `context` or `targetElementId`.

Default: `false`

<Tabs>
  <Tab title="React / Next.js">
  **Using Props:**
  ```jsx
  <VeltComments groupMatchedComments={true} />
  ```
  **Using API:**
  ```jsx
  const commentElement = client.getCommentElement();
  commentElement.enableGroupMatchedComments();
  commentElement.disableGroupMatchedComments();
  ```
  </Tab>
  
  <Tab title="Other Frameworks">
  **Using Props:**
  ```html
  <velt-comments group-matched-comments="true"></velt-comments>
  ```
  **Using API:**
  ```jsx
  const commentElement = Velt.getCommentElement();
  commentElement.enableGroupMatchedComments();
  commentElement.disableGroupMatchedComments();
  ```

  </Tab>
  </Tabs>

#### commentCountType
Whether to show unread or total comment replies count on Comment Bubble Component.
- `total`: Shows the total number of replies. (default)
- `unread`: Shows the number of unread replies.

<Tabs>
<Tab title="React / Next.js">
```jsx
<VeltCommentBubble commentCountType={"unread"} />
```
</Tab>

<Tab title="Other Frameworks">
```jsx
<velt-comment-bubble comment-count-type="unread">
</velt-comment-bubble>
```
</Tab>
</Tabs>

#### readOnly

The `readOnly` flag prevents users from replying or editing existing comments in the target bubble while still displaying them.

This is useful when you want to display comments in a read-only mode where users can view but not modify or respond to comments.

Default: `false`

<Tabs>
<Tab title="React / Next.js">
```jsx
<VeltCommentBubble readOnly={true} />
```
</Tab>
<Tab title="Other Frameworks">
```html
<velt-comment-bubble read-only="true"></velt-comment-bubble>
```
</Tab>
</Tabs>


# Video Timeline Comments

#### setTotalMediaLength

Set the total length of media (in frames or seconds) for the timeline.

<Tabs>
  <Tab title="React / Next.js">
  **Using Props:**
    ```jsx
    <VeltCommentPlayerTimeline totalMediaLength={120} />
    ```
    **Using API Method:**
    ```jsx
    const commentElement = client.getCommentElement();
    commentElement.setTotalMediaLength(120);
    ```
  </Tab>
  <Tab title="Other Frameworks">
  **Using Props:**
    ```html
    <velt-comment-player-timeline total-media-length="120"></velt-comment-player-timeline>
    ```
    **Using API Method:**
    ```jsx
    const commentElement = Velt.getCommentElement();
    commentElement.setTotalMediaLength(120);
    ```
  </Tab>
</Tabs>


#### offset

- Allows comment bubbles to be positioned relative to both parent and child video clips by specifying an offset value.
- Default: `0`

<Tabs>
  <Tab title="React / Next.js">
    ```jsx
    <VeltCommentPlayerTimeline offset={10} />
    ```
  </Tab>
  <Tab title="Other Frameworks">
    ```html
    <velt-comment-player-timeline offset="10"></velt-comment-player-timeline>
    ```
  </Tab>
</Tabs>


# Comment Pin
#### enableBubbleOnPin

Show a Comment Bubble when user hovers or clicks on the Comment Pin vs showing the Comment Dialog.
The comment dialog will open only on clicking the comment bubble.

`Default: 'false'`

<Tabs>
<Tab title="React / Next.js with Hooks">
**Using Props:**
```jsx
<VeltComments bubbleOnPin={true} />
```
**Using API Method:**
```jsx
const commentElement = useCommentUtils();
commentElement.enableBubbleOnPin();
commentElement.disableBubbleOnPin();
```

</Tab>

<Tab title="React / Next.js">
**Using Props:**
```jsx
<VeltComments bubbleOnPin={true} />
```
**Using API Method:**
```jsx
const commentElement = client.getCommentElement();
commentElement.enableBubbleOnPin();
commentElement.disableBubbleOnPin();
```
</Tab>

<Tab title="Other Frameworks">
**Using Props:**
```jsx
<velt-comments bubble-on-pin="true">
</velt-comments>
```
**Using API Method:**
```jsx
const commentElement = Velt.getCommentElement();
commentElement.enableBubbleOnPin();
commentElement.disableBubbleOnPin();
```

</Tab>
</Tabs>

#### enableBubbleOnPinHover

Show a Comment Bubble when user hovers on the Comment Pin vs clicks on it.

`Default: 'true'`

<Tabs>
<Tab title="React / Next.js with Hooks">
**Using Props:**
```jsx
<VeltComments bubbleOnPin={true} bubbleOnPinHover={false} />
```
**Using API Method:**
```jsx
const commentElement = useCommentUtils();

// To enable/disable showing bubble on pin
commentElement.enableBubbleOnPin();
commentElement.disableBubbleOnPin();

// To enable/disable showing bubble on hover
commentElement.enableBubbleOnPinHover();
commentElement.disableBubbleOnPinHover();
```

</Tab>

<Tab title="React / Next.js">
**Using Props:**
```jsx
<VeltComments bubbleOnPin={true} bubbleOnPinHover={false} />
```
**Using API Method:**
```jsx
const commentElement = client.getCommentElement();
// To enable/disable showing bubble on pin
commentElement.enableBubbleOnPin();
commentElement.disableBubbleOnPin();

// To enable/disable showing bubble on hover
commentElement.enableBubbleOnPinHover();
commentElement.disableBubbleOnPinHover();
```
</Tab>

<Tab title="Other Frameworks">
**Using Props:**
```jsx
<velt-comments bubble-on-pin="true" bubble-on-pin-hover="false"></velt-comments>
```
**Using API Method:**
```jsx
const commentElement = Velt.getCommentElement();
// To enable/disable showing bubble on pin
commentElement.enableBubbleOnPin();
commentElement.disableBubbleOnPin();

// To enable/disable showing bubble on hover
commentElement.enableBubbleOnPinHover();
commentElement.disableBubbleOnPinHover();
```

</Tab>
</Tabs>


# Legacy Methods
#### onCommentAdd

<Tabs>
<Tab title="React / Next.js">

Using Props:
```js
<VeltComments onCommentAdd={(event) => yourMethod(event)} />

const yourMethod = (event) => {
  event?.addContext({ customKey: 'customValue' });
}
```

Using Hooks:
```jsx
import { useCommentAddHandler} from '@veltdev/react';

export default function YourDocument() {

  const commentAddEvent = useCommentAddHandler();

  useEffect(() => {
    console.log('commentAddEvent', commentAddEvent);
  }, [commentAddEvent]);

  return (
    <div></div>
  )
}
```

Using API:
```js
const commentElement = client.getCommentElement();

commentElement.onCommentAdd().subscribe((event) => {
  console.log('commentAddEvent', event);
});
```
</Tab>

<Tab title="Other Frameworks">

Using Event listener:
```js
const veltCommentsTag = document.querySelector('velt-comments');

veltCommentsTag?.addEventListener('onCommentAdd', (event) => {
  console.log('*** onCommentAdd ***');
  console.log(event.detail);
  event.detail?.addContext({ customKey: 'customValue' });
});
```

Using API method:
```js
const commentElement = Velt.getCommentElement();

commentElement.onCommentAdd().subscribe((event) => {
  event?.addContext({ customKey: 'customValue' });
});
```
</Tab>
</Tabs>

**onCommentAdd Event Data Schema**
| Field Name | Type | Description |
|------------|------|-------------|
| addContext | Function | Use this to set custom data on the comment |
| annotation | CommentAnnotation | The annotation that is associated with the comment that was updated |
| documentId | string | The document ID where the comment was added |
| location | Object | The location where the comment was added |
| targetAnnotationId | string | The id of the target annotation |



#### onCommentUpdate

<Tabs>
<Tab title="React / Next.js">

Using Props:
```js
<VeltComments onCommentUpdate={(event) => yourMethod(event)} />

const yourMethod = (event) => {
  console.log('commentUpdateEvent', event);
}
```

Using Hooks:
```jsx
import { useCommentUpdateHandler} from '@veltdev/react';

export default function YourDocument() {

  const commentUpdateEvent = useCommentUpdateHandler();
  useEffect(() => {
    console.log('commentUpdateEvent', commentUpdateEvent);
  }, [commentUpdateEvent]);

  return (
    <div></div>
  )
}
```
Using API:
```js
const commentElement = client.getCommentElement();

commentElement.onCommentUpdate().subscribe((event) => {
  console.log('commentUpdateEvent', event);
});
```
</Tab>

<Tab title="Other Frameworks">
Using Event Listener:
```js
const veltCommentsTag = document.querySelector('velt-comments');

veltCommentsTag?.addEventListener('onCommentUpdate', (event) => {
  console.log('*** onCommentUpdate ***');
  console.log(event.detail);
});
```

Using API method:
```js
const commentElement = Velt.getCommentElement();

commentElement.onCommentUpdate().subscribe((event) => {
  console.log('commentUpdateEvent', event);
});
```
</Tab>
</Tabs>


**onCommentUpdate Event Data Schema**
| Field Name | Type | Description |
|------------|------|-------------|
| annotation | CommentAnnotation | The annotation that is associated with the comment that was updated |
| type | string | The type of comment that was updated |
| targetAnnotationId | string | The ID of the target annotation that contains the comment that was updated |
| targetCommentId | number | The ID of the target comment that was updated |
| updateContext | Function | Use this to update the custom metadata on the comment annotation. |


#### getAllCommentAnnotations
- Get all comment annotations for a given document and location.
- By default, it will return data for the current `documentId` and `location`.
- Params (optional): 
  - `documentId`: string; it will return all comments in the given `documentId`.
  - `location`: Object; it will return all comments in the given `location`.

<Tabs>
<Tab title="React / Next.js">

**Using Hooks:**
```jsx
  const commentAnnotations = useCommentAnnotations();
  useEffect(() => {
    if (commentAnnotations) {
      console.log('commentAnnotations', commentAnnotations);
    }
  }, [commentAnnotations]);
```

**Using API:**
```js
const commentElement = client.getCommentElement();
let subscription = commentElement.getAllCommentAnnotations().subscribe((comments) => {
  console.log('commentAnnotations', comments);
});
```
To unsubscribe from the subscription:
```jsx
subscription?.unsubscribe()
```

</Tab>
<Tab title="Other Frameworks">
```js
if (Velt) {
  const commentElement = Velt.getCommentElement();
  let subscription = commentElement.getAllCommentAnnotations().subscribe((comments) => {
    // Do something with comments
  });
}
```
To unsubscribe from the subscription:
```jsx
subscription?.unsubscribe()
```
</Tab>
</Tabs>
