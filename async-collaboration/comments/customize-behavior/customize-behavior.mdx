---
title : "Customize Behavior"
---
# @Mentions

#### 1. enableAtHere
- This allows you to notify all the users explicitly added to the current document.
- It won't notify users in the organization who are not explicitly added to the document.

![](/gifs/enable-@-here.png)

<Tabs>

<Tab title="React / Next.js">
**Using Hooks:**
```jsx
const contactElement = useContactUtils();

useEffect(() => {
  contactElement.enableAtHere();
  contactElement.disableAtHere();
}, [contactElement]);

```
**Using API:**
```jsx
const contactElement = client.getContactElement();
contactElement.enableAtHere();
contactElement.disableAtHere();
```
</Tab>

<Tab title="Other Frameworks">
```jsx
const contactElement = Velt.getContactElement();
contactElement.enableAtHere();
contactElement.disableAtHere();
```
</Tab>
</Tabs>

#### 2. enableUserMentions
- This allows you to enable or disable user @mentions.


Whether user @mentions are enabled.

`Default: true`


<Tabs>
<Tab title="React / Next.js">
Using Props:

```jsx 
<VeltComments userMentions={false} />
```
**Using Hooks:**

```jsx
const contactElement = useContactUtils();

useEffect(() => {
  contactElement.enableUserMentions();
  contactElement.disableUserMentions();
}, [contactElement]);
```
**Using API Method:**
```jsx
const contactElement = client.getContactElement();
contactElement.enableUserMentions();
contactElement.disableUserMentions();
```
</Tab>

<Tab title="Other Frameworks">
**Using props:**
```jsx 
<velt-comments user-mentions="false"></velt-comments>
```
**Using API Method:**
```jsx
const commentElement = Velt.getCommentElement();
commentElement.enableUserMentions(); // to enable user mentions
commentElement.disableUserMentions(); // to disable user mentions
```
</Tab>
</Tabs>


#### 3. onContactSelected
- This event is triggered when a contact is selected from the contact dropdown in the Comment Dialog.
- Use the event object to determine if the selected contact has access to the document using fields like `isOrganizationContact`, `isDocumentContact` and `documentAccessType`.
- If the selected contact doesn't have access to the document, you can show an invite dialog to the user to invite the contact to the document.

The returned data will be in the following schema:
```jsx
export class UserContactSelectedPayload {
    contact!: UserContact; // Selected Contact.
    isOrganizationContact!: boolean; // Is user part of organization contact.
    isDocumentContact!: boolean; // Is user part of document contact.
    documentAccessType!: string; // Document access type.
}
```

<Tabs>
<Tab title="React / Next.js">
**Using Hooks:**
```jsx
const selectedContact = useContactSelected();

useEffect(() => {
  console.log('selectedContact: ', selectedContact);
}, [selectedContact]);

```
**Using API:**
```jsx
const contactElement = client.getContactElement();

contactElement.onContactSelected().subscribe((selectedContact: any) => {
  console.log('selectedContact : ', selectedContact);
});
```
</Tab>

<Tab title="Other Frameworks">
```jsx
const contactElement = Velt.getContactElement();

contactElement.onContactSelected().subscribe((selectedContact: any) => {
  console.log('selectedContact: ', selectedContact);
});
```
</Tab>
</Tabs>

#### 4. setAtHereLabel
- This allows you to modify the default text of the @here feature. eg: @all, @everyone, @team, etc.

<Tabs>
<Tab title="React / Next.js">
**Using Props:**
```jsx
<VeltComments atHereLabel='@all'>
```

**Using Hooks:**
```jsx
const contactElement = useContactUtils();

useEffect(() => {
  contactElement.setAtHereLabel('@all');
}, [contactElement]);
```

**Using API Method:**

```jsx
const contactElement = client.getContactElement();
contactElement.setAtHereLabel('@all');
```
</Tab>

<Tab title="Other Frameworks">
**Using Props:**
```jsx
<velt-comments at-here-label="@all">
```

**Using API Method:**
```jsx
const contactElement = Velt.getContactElement();
contactElement.setAtHereLabel('@all');
```
</Tab>
</Tabs>


#### 5. setAtHereDescription
- Customize the description that appears for the @here mention.

<Tabs>
<Tab title="React / Next.js">
**Using Props:**
```jsx
<VeltComments atHereDescription="Notify all users in this document" />
```

**Using Hooks:**
```jsx
const contactElement = useContactUtils();

useEffect(() => {
  contactElement.setAtHereDescription('Notify all users in this document');
}, [contactElement]);
```

**Using API Method:**
```jsx
const contactElement = client.getContactElement();
contactElement.setAtHereDescription('Notify all users in this document');
```

</Tab>

<Tab title="Other Frameworks">

**Using Props:**
```html
<velt-comments at-here-description="Notify all users in this document"></velt-comments>
```

**Using API Method:**
```javascript
const contactElement = Velt.getContactElement();
contactElement.setAtHereDescription('Notify all users in this document');
```
</Tab>
</Tabs>

#### 6. updateContactList
- By default, the contact list is generated using the users in the organization and the document.
- However, if you do not want to use that feature or want to provide a custom list of contacts, you can use this method.
- By default, it will overwrite the current contact list. You can merge the provided contacts with the existing list by passing the merge flag as `{merge:true}`.
- This method will only update the contact list in the current user session. It doens't update the user contacts in the database or change the access control.

<Tabs>
<Tab title="React / Next.js">
**Using Hooks:**
```jsx
const contactElement = useContactUtils();

useEffect(() => {
  contactElement.updateContactList([{userId: 'userId1', name: 'User Name', email: 'user1@velt.dev'}], {merge: false});
}, [contactElement]);

```
**Using API:**
```jsx
const contactElement = client.getContactElement();
contactElement.updateContactList([{userId: 'userId1', name: 'User Name', email: 'user1@velt.dev'}], {merge: false});
```
</Tab>

<Tab title="Other Frameworks">
```jsx
const contactElement = Velt.getContactElement();
contactElement.updateContactList([{userId: 'userId1', name: 'User Name', email: 'user1@velt.dev'}], {merge: false});
```
</Tab>
</Tabs>


#### 7. updateContactListScopeForOrganizationUsers
- Sometimes you may want to show only certain types of contacts in the contact dropdown.
- By default, organization users will see all contacts in the organization, any user groups and any contacts added to the document.
- Using this method, you can restrict the contacts shown in the dropdown to only certain types.
- This only affects the Organization Users and not the Document Users. Document Users will always only see contacts added to the document.

Here are the available options:
* `all`: Show all the contacts
* `organization`: Show organization contacts.
* `organizationUserGroup`: Show organization user groups.
* `document`: Show document contacts.


<Tabs>
<Tab title="React / Next.js">
```jsx
const contactElement = client.getContactElement();
contactElement.updateContactListScopeForOrganizationUsers(['all', 'organization', 'organizationUserGroup', 'document']);
```
</Tab>

<Tab title="Other Frameworks">
```jsx
const contactElement = Velt.getContactElement();
contactElement.updateContactListScopeForOrganizationUsers(['all', 'organization', 'organizationUserGroup', 'document']);
```
</Tab>
</Tabs>

# Action Methods

#### 8. addCommentOnSelectedText

![](/images/addCommentOnSelectedText.png)


By default, when you highlight over any text in `textMode` a Comment Tool button will appear. Clicking the button will add a comment on the highlighted text.

If you want to trigger the comment using an API method call instead of clicking the button, you can do the following:

<Tabs>
<Tab title="React / Next.js">

```jsx
const commentElement = client.getCommentElement();
// to add comment on selected text
commentElement.addCommentOnSelectedText();
```
</Tab>

<Tab title="Other Frameworks">
```jsx
const commentElement = Velt.getCommentElement();
// to add comment on selected text
commentElement.addCommentOnSelectedText();
```
</Tab>


</Tabs>

#### 9. addCommentOnElement

![](/images/addCommentOnElement.png)


Adds a Comment on a specific element by ID.

To add a comment on a specific element through an API method, use the `addCommentOnElement()` method and pass in an object with the schema shows in the example:

<Tabs>
<Tab title="React / Next.js">


```jsx

const element = {
  "targetElement": {
    "elementId": "element_id", // optional (pass elementId if you want to add comment on a specific element)
    "targetText": "target_text", // optional (pass targetText if you want to add comment on a specific text)
    "occurrence": 1, // optional (default: 1) This is relevant for text comment. By default, we will attach comment to the first occurence of the target text in your document. You can change this to attach your comment on a more specific text.
  	"selectAllContent": true, // Set to `true` if you want to select all the text content of the target element.
  },
  "commentData": [
    {
      "commentText": "This is awesome! Well done.", // To set plain text content
      "commentHtml": "This <span style=\"color: green; background-color: aliceblue; display: inline-block; padding: 4px; border-radius: 4px;\">is test</span> comment.", // To set HTML formatted content
      "replaceContentText": "This is new comment", // provide this replaceContentText to replace current text with
      "replaceContentHtml": "<span>This is <b>new</b> comment.</span>", // If replacement text contains html formatted text, then provide it here
    }
  ],
  "status": "open", // optional (default: open)
}

const commentElement = client.getCommentElement();
commentElement.addCommentOnElement(element);
```
</Tab>

<Tab title="Other Frameworks">
```jsx

const element = {
  "targetElement": {
    "elementId": "element_id", // optional (pass elementId if you want to add comment on a specific element)
    "targetText": "target_text", // optional (pass targetText if you want to add comment on a specific text)
    "occurrence": 1, // optional (default: 1) This is relevant for text comment. By default, we will attach comment to the first occurence of the target text in your document. You can change this to attach your comment on a more specific text.
  	"selectAllContent": true, // Set to `true` if you want to select all the text content of the target element.
  },
  "commentData": [
    {
      "commentText": "This is awesome! Well done.", // To set plain text content
      "commentHtml": "This <span style=\"color: green; background-color: aliceblue; display: inline-block; padding: 4px; border-radius: 4px;\">is test</span> comment.", // To set HTML formatted content
      "replaceContentText": "This is new comment", // provide this replaceContentText to replace current text with
      "replaceContentHtml": "<span>This is <b>new</b> comment.</span>", // If replacement text contains html formatted text, then provide it here
    }
  ],
  "status": "open", // optional (default: open)
}

const commentElement = Velt.getCommentElement();
commentElement.addCommentOnElement(element);
```
</Tab>


</Tabs>

#### 10. addManualComment
- This feature is particularly useful for complex UIs where you need precise control over the placement of Comment Pins.
- Using this you can manually set the position of Comment Annotations.
- Handle click events on your canvas/document and use the this method to create a comment with custom metadata.

<Tabs>
<Tab title="React / Next.js">

```jsx
const context = {
  postion: {x: 200, y: 100},
};
const commentElement = client.getCommentElement();
const config: ManualCommentAnnotationConfig = {
	context: context, // your context here
};
commentElement.addManualComment(config);
```

</Tab>

<Tab title="Other Frameworks">
```jsx
const context = {
  postion: {x: 200, y: 100},
};
const commentElement = Velt.getCommentElement();
const config: ManualCommentAnnotationConfig = {
	context: context, // your context here
};
commentElement.addManualComment(config);
```
</Tab>
</Tabs>

#### 11. deleteSelectedComment

![](/images/deleteSelectedComment.png)

To delete a comment using an API method, use the `deleteSelectedComment()` method.

<Tabs>
<Tab title="React / Next.js">
```jsx
if (client) {
  const commentElement = client.getCommentElement();
  commentElement.deleteSelectedComment();
}
```
</Tab>

<Tab title="Other Frameworks">
```jsx
if (Velt) {
  const commentElement = Velt.getCommentElement();
  commentElement.deleteSelectedComment();
}
```

</Tab>


</Tabs>



#### 12. getElementRefByAnnotationId

![](/images/getElementRefByAnnotationId.png)


This will return the Xpath of the DOM element on which the comment was added.
<Tabs>
<Tab title="React / Next.js">

```jsx
const commentElement = client.getCommentElement();
let elementRef = commentElement.getElementRefByAnnotationId('annotationId')

```
</Tab>

<Tab title="Other Frameworks">
```jsx
const commentElement = Velt.getCommentElement();
let elementRef = commentElement.getElementRefByAnnotationId('annotationId')

```
</Tab>


</Tabs>


#### 13. enableCommentMode

![](/images/comment-mode-on-off.png)


Turns Comment mode on or off.

When you click on the comment tool, it turns on comment mode and user can attach comment to any element on the DOM. Using this method you can programatically turn on the commenting mode.
<Tabs>
<Tab title="React / Next.js">

```jsx
const commentElement = client.getCommentElement();
commentElement.enableCommentMode();
commentElement.disableCommentMode();
```
</Tab>

<Tab title="Other Frameworks">
```jsx
const commentElement = Velt.getCommentElement();
commentElement.enableCommentMode();
commentElement.disableCommentMode();
```
</Tab>


</Tabs>

#### 14. scrollToCommentByAnnotationId
![](/gifs/scroll-on-click.gif)

- This will scroll the page to the element directly. This will work if the element is present on the DOM.

<Tabs>
<Tab title="React / Next.js">

```jsx
const commentElement = client.getCommentElement();
commentElement.scrollToCommentByAnnotationId('annotationId')
```

</Tab>

<Tab title="Other Frameworks">
```jsx
const commentElement = Velt.getCommentElement();
commentElement.scrollToCommentByAnnotationId('annotationId')
```
</Tab>


</Tabs>

#### 15. selectCommentByAnnotationId
- Use this to programatically select a comment annotation by its id.
- Example: If the user opens a comment url from an email notification,
you can use this open the comment dialog after your page has finished rendering.

<Tabs>
<Tab title="React / Next.js">

```jsx
const commentElement = client.getCommentElement();
commentElement.selectCommentByAnnotationId("COMMENT_ANNOTATION_ID");
```

</Tab>

<Tab title="Other Frameworks">
```jsx
const commentElement = Velt.getCommentElement();
commentElement.selectCommentByAnnotationId("COMMENT_ANNOTATION_ID");
```
</Tab>
</Tabs>

#### 16. updateCommentDialogPosition
- Sometimes when you manually set the position of the Comment Pin, the Comment Dialog might not position itself near the pin in certain scenarios like scrolling, zooming the page when the comment dialog is open.
- Use this to manually trigger an update. The dialog will reposition itself near the pin.
<Tabs>
<Tab title="React / Next.js">

```jsx
const commentElement = client.getCommentElement();
commentElement.updateCommentDialogPosition();
```

</Tab>

<Tab title="Other Frameworks">
```jsx
const commentElement = Velt.getCommentElement();
commentElement.updateCommentDialogPosition();
```
</Tab>
</Tabs>

You can add custom lists at two levels: a. on the CommentAnnotation and b. on the Comment.

# Custom Lists

#### 17. createCustomListDataOnAnnotation
- Add a custom dropdown list at the Comment Annotation level. 
- Use this to add custom tags or categories to the comment.

![](/images/customization/comment-annotation-custom-list.png)

```jsx
let customList = [
    { id: 'violent', label: 'Violent' },
    { id: 'inappropriate', label: 'Inappropriate' },
    { id: 'robbery', label: 'Robbery' },
    { id: 'nsfw', label: 'NSFW' },
];

const customListDataOnCommentAnnotation = {
	type: 'multi', // choose from 'multi' or 'single'
    placeholder: 'Select a category',
    data: customList, // your customList data here
};
```

<Tabs>
<Tab title="React / Next.js with hooks">
**Using Props:**
```jsx	
<VeltComments customListDataOnAnnotation={customListDataOnCommentAnnotation} />
```

**API Method:**
```jsx
const commentElement = useCommentUtils();		
commentElement.createCustomListDataOnAnnotation(customListDataOnCommentAnnotation);
```

</Tab>

<Tab title="React / Next.js">
**Using Props:**
```jsx	
<VeltComments customListDataOnAnnotation={customListDataOnCommentAnnotation} />
```

**API Method:**
```jsx
const commentElement = client.getCommentElement();		
commentElement.createCustomListDataOnAnnotation(customListDataOnCommentAnnotation);
```
</Tab>

<Tab title="Other Frameworks">
```jsx
const commentElement = Velt.getCommentElement();			
commentElement.createCustomListDataOnAnnotation(customListDataOnCommentAnnotation);
```
</Tab>
</Tabs>


#### 18. createCustomListDataOnComment
You can have custom dropdown lists appear when certain `hotkeys` are pressed.

When you press a hotkey inside the Comment Dialog composer, it will open a dropdown list of items that you can select.

![](/images/customization/custom-list-1.png)

Selecting an item frop the dropdown list will add a chip that inside the comment text.

![](/images/customization/custom-list-2.png)

<Steps titleSize="h2">

<Step title="Set hotkey and list data">

<Warning> Make sure the hotkey is a single character such as `#` or `/`</Warning>

- Create the list of data will be shown when the `hotkey` is pressed. Eg: When the user presses `#`, the list of files or links from other parts of your app is shown.
- The items in the list must be in the following schema:

```jsx
export class AutocompleteItem {
    id!: string; // Unique identifier
    name!: string; // Item name. This appears as the main item text in the UI.
    description?: string; // Item description. This appears as the secondary item text in the UI.
    icon?: { url?: string, svg?: string }; // Item icon. This appears as the icon in the UI.
    link?: string; // Item link. You can use this to open a link when the item is clicked. Check the event listener below for more details.
}
```

```jsx
let customList = [
    {
        id: '1',
        name: 'File 1',
        description: 'File Description 1',
        icon: {url: 'https://cdn-icons-png.flaticon.com/512/9496/9496432.png'}
    },
    {
        id: '2',
        name: 'File 2',
        description: 'File Description 2',
        icon: {url: 'https://cdn-icons-png.flaticon.com/512/11471/11471469.png'}
    },
    {
        id: '3',
        name: 'File 3',
        description: 'File Description 3',
        icon: {url: 'https://cdn-icons-png.flaticon.com/512/2656/2656402.png'}
    }
];

const customListDataOnComment = {
	hotkey: 'UNIQUE_HOTKEY', // only single charater is allowed. eg: '#'
	type: 'custom',
    data: customList, // your customList data here
};
```
<Tabs>
<Tab title="React / Next.js with hooks">
**Using Props:**
```jsx	
<VeltComments customListDataOnComment={customListDataOnComment} />
```

**API Method:**
```jsx
const commentElement = useCommentUtils();		
commentElement.createCustomListDataOnComment(customListDataOnComment);
```

</Tab>

<Tab title="React / Next.js">
**Using Props:**
```jsx	
<VeltComments customListDataOnComment={customListDataOnComment} />
```

**API Method:**
```jsx
const commentElement = client.getCommentElement();		
commentElement.createCustomListDataOnComment(customListDataOnComment);
```
</Tab>

<Tab title="Other Frameworks">
```jsx
const commentElement = Velt.getCommentElement();			
commentElement.createCustomListDataOnComment(customListDataOnComment);
```
</Tab>


</Tabs>

</Step>

<Step title="Listen to click event data on chips">
- After the comment is saved, the item will be rendered as a chip on the comment content.
- When the user clicks on it, you will get an event callback with the data of the clicked chip (AutocompleteItem).

<Info>This event will also be triggered when the user clicks on the contact chips added via the @mentions feature.</Info>

<Tabs>
<Tab title="React / Next.js with Hooks">
```jsx
let autocompleteChipData = useAutocompleteChipClick(); 
```
</Tab>

<Tab title="React / Next.js">
```jsx
const autocompleteElement = client.getAutocompleteElement();
const subscription = autocompleteElement.onAutocompleteChipClick().subscribe(_data => {
    console.log(_data);
})
```
To unsubscribe from the subscription:
```jsx
subscription?.unsubscribe()
```
</Tab>


<Tab title="Other Frameworks">
```jsx
const autocompleteElement = Velt.getAutocompleteElement();
const subscription = autocompleteElement.onAutocompleteChipClick().subscribe(_data => {
    console.log(_data);
})
```
To unsubscribe from the subscription:
```jsx
subscription?.unsubscribe()
```
</Tab>


</Tabs>


</Step>
</Steps>

# Custom Metadata

#### 19. addContext
Custom metadata allows you to add extra information to comments, enhancing their functionality. Here's what you can do with it:

- Render additional data on comments
- Position comment pins manually
- Create custom UI components
- Enable comment filtering on custom data

To add custom metadata, use the `event.addContext()` method when a comment is added. This method accepts an object with key-value pairs.

![](/images/addContext.png)

<Tabs>
<Tab title="React / Next.js">

Using Props:
```js
<VeltComments onCommentAdd={(event) => yourMethod(event)} />

const yourMethod = (event) => {
  event?.addContext({ customKey: 'customValue' });
}
```

Using Hooks:
```jsx
import { useCommentAddHandler} from '@veltdev/react';

export default function YourDocument() {

  const commentAddEvent = useCommentAddHandler();

  useEffect(() => {
    console.log('commentAddEvent', commentAddEvent);
    commentAddEvent?.addContext({ customKey: 'customValue' });
  }, [commentAddEvent]);

  return (
    <div></div>
  )
}
```

Using API method:
```js
const commentElement = client.getCommentElement();

commentElement.onCommentAdd().subscribe((event) => {
  event?.addContext({ customKey: 'customValue' });
});
```
</Tab>

<Tab title="Other Frameworks">

Using Event listener:
```js
const veltCommentsTag = document.querySelector('velt-comments');

veltCommentsTag?.addEventListener('onCommentAdd', (event) => {
  console.log('*** onCommentAdd ***');
  console.log(event.detail);
  event.detail?.addContext({ customKey: 'customValue' });
});
```

Using API method:
```js
const commentElement = Velt.getCommentElement();

commentElement.onCommentAdd().subscribe((event) => {
  event?.addContext({ customKey: 'customValue' });
});
```
</Tab>
</Tabs>


#### 20. updateContext
You can update the custom metadata associated with a comment annotation using the `updateContext` method. This method is available in two scenarios:

1. **In the `onCommentUpdate` event callback:**
   Use this to update the context when a comment is modified.

2. **Via the `updateContext` API method:**
   Utilize this method to update the context of a comment annotation at any time. For example, you might use this when the name of the dashboard containing the comment annotation changes.


**Option 1: onCommentUpdate event**
The `updateContext` method accepts two parameters:
- The new metadata object
- An optional `updateContextConfig` object. Specify how the new metadata should be applied:
  - `{ merge: true }`: Merges the new metadata with the existing metadata
  - `{ merge: false }` or omitted: Replaces the existing metadata entirely (default behavior)

<Tabs>
<Tab title="React / Next.js">

Using Props:
```js
<VeltComments onCommentUpdate={(event) => yourMethod(event)} />

const yourMethod = (event) => {
  console.log('commentUpdateEvent', event);
  event?.updateContext({ customKey: 'customValue' }, { merge: true });
}
```

Using Hooks:
```jsx
import { useCommentUpdateHandler} from '@veltdev/react';

export default function YourDocument() {

  const commentUpdateEvent = useCommentUpdateHandler();
  useEffect(() => {
    console.log('commentUpdateEvent', commentUpdateEvent);
    commentUpdateEvent?.updateContext({ customKey: 'customValue' }, { merge: true });
  }, [commentUpdateEvent]);

  return (
    <div></div>
  )
}
```
Using API:
```js
const commentElement = client.getCommentElement();

commentElement.onCommentUpdate().subscribe((event) => {
  console.log('commentUpdateEvent', event);
  event?.updateContext({ customKey: 'customValue' }, { merge: true });
});
```
</Tab>

<Tab title="Other Frameworks">
Using Event Listener:
```js
const veltCommentsTag = document.querySelector('velt-comments');

veltCommentsTag?.addEventListener('onCommentUpdate', (event) => {
  console.log('*** onCommentUpdate ***');
  console.log(event.detail);
  event.detail?.updateContext({ customKey: 'customValue' }, { merge: true });
});
```

Using API method:
```js
const commentElement = Velt.getCommentElement();

commentElement.onCommentUpdate().subscribe((event) => {
  console.log('commentUpdateEvent', event);
  event?.updateContext({ customKey: 'customValue' }, { merge: true });
});
```
</Tab>
</Tabs>

**Option 2: commentElement.updateContext**

The `commentElement.updateContext()` method accepts three parameters:
- The Comment Annotation ID
- The new metadata object
- An optional `updateContextConfig` object. Specify how the new metadata should be applied:
  - `{ merge: true }`: Merges the new metadata with the existing metadata
  - `{ merge: false }` or omitted: Replaces the existing metadata entirely (default behavior)

<Tabs>
<Tab title="React / Next.js">

Using API:
```js

const updatedContext = { customKey: 'customValue' };
const updateContextConfig = { merge: true };

const commentElement = client.getCommentElement();
commentElement.updateContext(COMMENT_ANNOTATION_ID, updatedContext, updateContextConfig);
```
</Tab>

<Tab title="Other Frameworks">

Using API method:
```js
const updatedContext = { customKey: 'customValue' };
const updateContextConfig = { merge: true };

const commentElement = client.getCommentElement();
commentElement.updateContext(COMMENT_ANNOTATION_ID, updatedContext, updateContextConfig);
```
</Tab>
</Tabs>

# Event Handlers

#### 21. onCommentAdd

![](/images/onCommentAdd.png)


<Tabs>
<Tab title="React / Next.js">

Using Props:
```js
<VeltComments onCommentAdd={(event) => yourMethod(event)} />

const yourMethod = (event) => {
  event?.addContext({ customKey: 'customValue' });
}
```

Using Hooks:
```jsx
import { useCommentAddHandler} from '@veltdev/react';

export default function YourDocument() {

  const commentAddEvent = useCommentAddHandler();

  useEffect(() => {
    console.log('commentAddEvent', commentAddEvent);
  }, [commentAddEvent]);

  return (
    <div></div>
  )
}
```

Using API:
```js
const commentElement = client.getCommentElement();

commentElement.onCommentAdd().subscribe((event) => {
  console.log('commentAddEvent', event);
});
```
</Tab>

<Tab title="Other Frameworks">

Using Event listener:
```js
const veltCommentsTag = document.querySelector('velt-comments');

veltCommentsTag?.addEventListener('onCommentAdd', (event) => {
  console.log('*** onCommentAdd ***');
  console.log(event.detail);
  event.detail?.addContext({ customKey: 'customValue' });
});
```

Using API method:
```js
const commentElement = Velt.getCommentElement();

commentElement.onCommentAdd().subscribe((event) => {
  event?.addContext({ customKey: 'customValue' });
});
```
</Tab>
</Tabs>

**onCommentAdd Event Data Schema**
| Field Name | Type | Description |
|------------|------|-------------|
| addContext | Function | Use this to set custom data on the comment |
| annotation | CommentAnnotation | The annotation that is associated with the comment that was updated |
| documentId | string | The document ID where the comment was added |
| location | Object | The location where the comment was added |
| targetAnnotationId | string | The id of the target annotation |



#### 22. onCommentUpdate

![](/images/onCommentUpdate.png)

<Tabs>
<Tab title="React / Next.js">

Using Props:
```js
<VeltComments onCommentUpdate={(event) => yourMethod(event)} />

const yourMethod = (event) => {
  console.log('commentUpdateEvent', event);
}
```

Using Hooks:
```jsx
import { useCommentUpdateHandler} from '@veltdev/react';

export default function YourDocument() {

  const commentUpdateEvent = useCommentUpdateHandler();
  useEffect(() => {
    console.log('commentUpdateEvent', commentUpdateEvent);
  }, [commentUpdateEvent]);

  return (
    <div></div>
  )
}
```
Using API:
```js
const commentElement = client.getCommentElement();

commentElement.onCommentUpdate().subscribe((event) => {
  console.log('commentUpdateEvent', event);
});
```
</Tab>

<Tab title="Other Frameworks">
Using Event Listener:
```js
const veltCommentsTag = document.querySelector('velt-comments');

veltCommentsTag?.addEventListener('onCommentUpdate', (event) => {
  console.log('*** onCommentUpdate ***');
  console.log(event.detail);
});
```

Using API method:
```js
const commentElement = Velt.getCommentElement();

commentElement.onCommentUpdate().subscribe((event) => {
  console.log('commentUpdateEvent', event);
});
```
</Tab>
</Tabs>


**onCommentUpdate Event Data Schema**
| Field Name | Type | Description |
|------------|------|-------------|
| annotation | CommentAnnotation | The annotation that is associated with the comment that was updated |
| type | string | The type of comment that was updated |
| targetAnnotationId | string | The ID of the target annotation that contains the comment that was updated |
| targetCommentId | number | The ID of the target comment that was updated |



#### 23. onCommentModeChange

![](/images/onCommentModeChange.png)


The comment mode is toggled on and off when you click on the Comment Tool.

<Tabs>
<Tab title="React / Next.js with Hooks">
The `useCommentModeState()` hook can be used to get the Comment mode without having to subscribe to changes. When the Comment mode changes, the hook return value will update. 

The subscription is automatically unsubscribed when the component dismounts.

```jsx
import { useCommentModeState } from '@veltdev/react';

export default function YourDocument() {

  let commentModeState = useCommentModeState()

  return (
    <div>
       Comment Mode is turned on: {commentModeState}
    </div>
  )
}

```
</Tab>
<Tab title="React / Next.js">
To subscribe to changes in the comment mode, use the `onCommentModeChange()` method , as a property on `VeltCommentTool`:

```jsx
<VeltCommentTool onCommentModeChange={(mode) => onCommentModeChange(mode)} />
```
API method:
```jsx
let subscription = commentElement.onCommentModeChange().subscribe((mode) => {
    //mode contains the state after change
});
```
To unsubscribe from the subscription:
```jsx
subscription?.unsubscribe()
```
</Tab>

<Tab title="Other Frameworks">
API method:
```jsx
const commentElement = Velt.getCommentElement();
let subscription = commentElement.onCommentModeChange().subscribe((mode) => {
    //mode contains the state after change
});
```
To unsubscribe from the subscription:
```jsx
subscription?.unsubscribe()
```
</Tab>
</Tabs>



#### 24. onCommentSelectionChange


<Tabs>
<Tab title="React / Next.js with Hooks">
The `useCommentSelectionChangeHandler` hook can be used to subscribe to Comment selection changes.

```jsx
import React, { useEffect } from 'react';
import { useCommentSelectionChangeHandler } from '@veltdev/react';

function YourComponent() {
    const commentSelectionChange = useCommentSelectionChangeHandler();

    useEffect(() => {
        console.log('commentSelectionChange', commentSelectionChange);
    }, [commentSelectionChange]);

    return (
        <>
            Selected Comment: {commentSelectionChange.annotation.id}
        </>
    );
}
```
</Tab>
<Tab title="React / Next.js">
The `onCommentSelectionChange()` method can be used to listen Comment selection changes.
```jsx
const onCommentSelectionChange = (data) => {
  console.log('onCommentSelectionChange', data);
}

<VeltComments onCommentSelectionChange={(data) => onCommentSelectionChange(data)} />
```
Callback response schema:


```jsx
export class CommentSelectionChangeData {
  selected!: boolean;
  annotation!: CommentAnnotation;
}
```


**API Methods:**

```jsx
const commentElement = client.getCommentElement();
let subscription = commentElement.onCommentSelectionChange().subscribe((data) => {
  console.log('onCommentSelectionChange: ', data);
});
```


**To unsubscribe from the subscription:**
```jsx
subscription?.unsubscribe()
```
</Tab>

<Tab title="Other Frameworks">
The `onCommentSelectionChange()` method can be used to listen Comment selection changes.
```jsx
<velt-comments></velt-comments>
<script>
const commentTag = document.querySelector('velt-comments');
commentTag.addEventListener('onCommentSelectionChange', (event) => {
	console.log('onCommentSelectionChange event', event.detail);
});
</script>
```
**Callback response schema:**


```jsx
export class CommentSelectionChangeData {
  selected!: boolean;
  annotation!: CommentAnnotation;
}
```


**API Methods:**

```jsx
const commentElement = Velt.getCommentElement();
let subscription = commentElement.onCommentSelectionChange().subscribe((data) => {
  console.log('onCommentSelectionChange: ', data);
});
```


**To unsubscribe from the subscription:**
```jsx
subscription?.unsubscribe()
```
</Tab>
</Tabs>

#### 25. onCopyLink

You can add a callback method for when a comment link is copied. This can be useful for tracking when a comment link is copied or showing a confirmation toast to the user.

<Tabs>

<Tab title="React / Next.js with Hooks">
  Using Hooks:
  ```jsx
    const commentLink = useCommentCopyLinkHandler();
    useEffect(() => {
      console.log('commentLink', commentLink);
    }, [commentLink]);
  ```
    Using API:
    ```jsx
    const commentElement = client.getCommentElement();
    commentElement.onCopyLink().subscribe((commentLink) => {
      console.log(commentLink);
    });
    ```
  </Tab>

  <Tab title="React / Next.js">
    Using API:
    ```jsx
    const commentElement = client.getCommentElement();
    commentElement.onCopyLink().subscribe((commentLink) => {
      console.log(commentLink);
    });
    ```
  </Tab>
  
  <Tab title="Other Frameworks">
    Using API:
    ```javascript
    const commentElement = Velt.getCommentElement();
    commentElement.onCopyLink().subscribe((commentLink) => {
      console.log(commentLink);
    });
    ```
  </Tab>
</Tabs>

# General Controls

#### 26. allowedElementIds
#### 27. allowedElementClassNames
#### 28. allowedElementQuerySelectors

![](/gifs/comment-area.gif)

Provide a list of element DOM IDs, class names, or query selectors where commenting should be allowed.

Comments will be disabled for all other elements. Note, this does not impact `Popover` mode.

<Tabs>
<Tab title="React / Next.js">
**Using Props:**
```js
<VeltComments 
  allowedElementIds={['some-element']} 
  allowedElementClassNames={["class-name-1", "class-name-2"]}
  allowedElementQuerySelectors={["#id1.class-name-1"]}
/>
```

**Using API Method:**
```jsx
const commentElement = client.getCommentElement();
commentElement.allowedElementIds['some-element'];
commentElement.allowedElementClassNames(["class-name-1", "class-name-2"]);
commentElement.allowedElementQuerySelectors(["#id1.class-name-1"]);
```
</Tab>

<Tab title="Other Frameworks">
**Using Props:**
```html
<velt-comments 
  allowed-element-ids='["some-element"]'
  allowed-element-class-names='["class-name-1", "class-name-2"]'
  allowed-element-query-selectors='["#id1.class-name-1"]'
>

</velt-comments>
```

**Using API Method:**
```jsx
const commentElement = Velt.getCommentElement();
commentElement.allowedElementIds['some-element'];
commentElement.allowedElementClassNames(["class-name-1", "class-name-2"]);
commentElement.allowedElementQuerySelectors(["#id1.class-name-1"]);
```
</Tab>
</Tabs>


#### 29. Disable Comments On Elements

![](/gifs/comment-area.gif)

Disable certain elements from being commented on.

Add the `data-velt-comment-disabled` attribute to elements where you want to disable commenting.

```html
<div data-velt-comment-disabled></div>
```

#### 30. enableCommentTool

![](/images/comment-disabled.png)

Whether the Comment Tool button is Enabled.

`Default: true`

When the Comment Tool is disabled, it can not be used to leave comments. Other ways to leave comments, such as highlighting text, will also be disabled.

<Tabs>
<Tab title="React / Next.js">
**Using Props:**
```jsx
<VeltComments commentTool={false} />
```

Using API methods:
```jsx
const commentElement = client.getCommentElement();
commentElement.enableCommentTool();
commentElement.disableCommentTool();
```
</Tab>

<Tab title="Other Frameworks">
**Using Props:**
```html
<velt-comments comment-tool="false"></velt-comments>
```

**Using API methods:**
```jsx
const commentElement = Velt.getCommentElement();
commentElement.enableCommentTool();
commentElement.disableCommentTool();
```
</Tab>
</Tabs>



#### 31. enableGhostComments

![](/images/ghost-comment-pin.png)

![](/images/ghost-comment-dialog-box.png)

Whether to show ghost comments on the DOM.

`Default: false`

Ghost comments are comments that were once linked to certain content on the DOM but that content is no longer available. If this is on, we display ghost comments in gray, close to where they were originally positioned on the DOM.
<Tabs>
<Tab title="React / Next.js">
```js
<VeltComments ghostComments={true} />
```

**Using API methods:**
```jsx
const commentElement = client.getCommentElement();
commentElement.enableGhostComments();
commentElement.disableGhostComments();
```
</Tab>

<Tab title="Other Frameworks">
```js
<velt-comments ghost-comments="true"></velt-comments>
```
**Using API methods:**
```jsx
const commentElement = Velt.getCommentElement();
commentElement.enableGhostComments();
commentElement.disableGhostComments();
```
</Tab>
</Tabs>


#### 32. enableGhostCommentsIndicator
![](/images/ghost-comment-sidebar.png)

Whether to show ghost comment labels in the comment sidebar.

`Default: true`

Ghost comments are always shown in the comments sidebar so that users can see the history of all comments. If this is on, we show a label on the comment in the sidebar indicating that the original content on which this comment was added is no longer available. This sets better expectations with the users.

<Tabs>
<Tab title="React / Next.js">
```js
<VeltComments ghostCommentsIndicator={true} />
```
**Using API methods:**
```jsx
const commentElement = client.getCommentElement();
commentElement.enableGhostCommentsIndicator();
commentElement.disableGhostCommentsIndicator();
```
</Tab>

<Tab title="Other Frameworks">
```html
<velt-comments ghost-comments-indicator="true"></velt-comments>
```
**Using API methods:**
```jsx
const commentElement = Velt.getCommentElement();
commentElement.enableGhostCommentsIndicator();
commentElement.disableGhostCommentsIndicator();
```
</Tab>

</Tabs>



#### 33. enableSidebarButtonOnCommentDialog

![](/images/sidebar-button-on-comment-dialog.png)

Whether the Sidebar Button on Comment Dialogs show up.

`Default: true`

By Default, each Comment Dialog has a button at the bottom that will open the Comments Sidebar when clicked.

To disable it, you can set it to false:

<Tabs>
<Tab title="React / Next.js">
**Using Props:**
```jsx
<VeltComments sidebarButtonOnCommentDialog={true} />
```

**Using API methods:**
```jsx
const commentElement = client.getCommentElement();
commentElement.enableSidebarButtonOnCommentDialog()
commentElement.disableSidebarButtonOnCommentDialog() 
```
</Tab>

<Tab title="Other Frameworks">
**Using Props:**
```jsx
<velt-comments sidebar-button-comment-dialog="true"></velt-comments>
```

**Using API methods:**
```jsx
const commentElement = Velt.getCommentElement();
commentElement.enableSidebarButtonOnCommentDialog()
commentElement.disableSidebarButtonOnCommentDialog() 
```
</Tab>

</Tabs>


#### 34. onSidebarButtonOnCommentDialogClick

Use this to act on clicks on the Sidebar Button at the bottom of the Comment Dialog.

![](images/customization/onSidebarOnCommentDialogClick.png)

<Tabs>
<Tab title = "React / Next.js">

**Using Props:**
```jsx
<VeltComments onSidebarButtonOnCommentDialogClick={(event)=>yourMethod(event)} />
```
**Using Hooks:**
```jsx
const commentDialogSidebarClickEvent = useCommentDialogSidebarClickHandler();
useEffect(() => {
  console.log('CommentDialog Sidebar button clicked');
}, [commentDialogSidebarClickEvent]);
```

**Using API methods:**
```jsx
const commentElement = client.getCommentElement();
let subscription = commentElement.onSidebarButtonOnCommentDialogClick().subscribe((event) => yourMethod(event));
```
To unsubscribe from the subscription:
```jsx
subscription?.unsubscribe()
```
</Tab>

<Tab title = "HTML">

**Using Props:**
```jsx
<velt-comments onsidebarbuttononcommentdialogclick="yourMethod(event)"></velt-comments>
```
**Using API Methods:**
```jsx
const commentElement = Velt.getCommentElement();
let subscription = commentElement.onSidebarButtonOnCommentDialogClick().subscribe((event) => yourMethod(event));
```
To unsubscribe from the subscription:
```jsx
subscription?.unsubscribe()
```
</Tab>
</Tabs>




#### 35. Iframe Container Support

![](/images/iframe-comment.png)


- To enable comments on an iframe, add `data-velt-iframe-container="true"` to the iframe's container element.
- Note this will not insert the comments inside the contents of the iframe, but rather on top of the iframe.

```html
<div data-velt-iframe-container="true">
	<iframe src="https://www.wikipedia.org/" width="500px" height="500px"></iframe>
</div>
```

#### 36. enableHotkey

Whether Hotkeys are enabled or not. For now, the only hotkey supported is pressing `c` to enable `comment mode`.

`Default: false`

<Tabs>
<Tab title="React / Next.js">
**Using Props:**
```jsx
<VeltComments hotkey={false} />
```
**Using API Method:**
```jsx
const commentElement = client.getCommentElement();
commentElement.enableHotkey();
commentElement.disableHotkey();
```
</Tab>

<Tab title="Other Frameworks">
**Using Props:**
```html
<velt-comments hotkey="true"></velt-comments>
```
**Using API Method:**
```jsx
const commentElement = Velt.getCommentElement();
commentElement.enableHotkey();
commentElement.disableHotkey();
```
</Tab>
</Tabs>

#### 37. PDF Viewer Support
![](/images/pdf-comments.png)

To support comments on top of a pdf viewer, add the `data-velt-pdf-viewer="true"` attribute in the container element of the pdf viewer.

```html
<!-- Add this attribute to the container of your pdf viewer -->
<div id="viewerContainer" data-velt-pdf-viewer="true">
    <!-- Your pdf viewer here -->
    <div id="viewer" class="pdfViewer"></div>
</div>
```

#### 38. excludeLocationIds

Use this to filter out Comments at a specific Location for certain Users.
<Tabs>
<Tab title="React / Next.js">
```jsx
const locationIds = ['location1', 'location2']; // list of location ids
client.excludeLocationIds(locationIds);
```

To reset it, you can pass an empty array:

```jsx
client.excludeLocationIds([]);
```
</Tab>

<Tab title="Other Frameworks">
```jsx
const locationIds = ['location1', 'location2']; // list of location ids
Velt.excludeLocationIds(locationIds);
```

To reset it, you can pass an empty array:

```jsx
Velt.excludeLocationIds([]);
```
</Tab>
</Tabs>



#### 39. enableChangeDetectionInCommentMode

- By default, DOM Change Detection is disabled in Comment Mode for better performance.
- You can enable it to automatically reposition comment pins when the DOM changes while in Comment Mode.

`Default: false`

<Tabs>
<Tab title="React / Next.js">
**Using Props:**
```jsx
<VeltComments changeDetectionInCommentMode={true} />
```

**Using API Method:**
```jsx
const commentElement = client.getCommentElement();
commentElement.enableChangeDetectionInCommentMode();
commentElement.disableChangeDetectionInCommentMode();
```
</Tab>

<Tab title="Other Frameworks">
**Using Props:**
```html
<velt-comments change-detection-in-comment-mode="true"></velt-comments>
```

**Using API Method:**
```jsx
const commentElement = Velt.getCommentElement();
commentElement.enableChangeDetectionInCommentMode();
commentElement.disableChangeDetectionInCommentMode();
```
</Tab>
</Tabs>


#### 40. enableEnterKeyToSubmit

- By default, pressing `enter` will add a new line and pressing `shift` + `enter` will submit a comment.
- You can change this default behavior so that pressing `enter` will submit a comment by setting the `enterKeyToSubmit` property to `true`.

<Tabs>
<Tab title="React / Next.js">
**Using Props:**
```jsx
<VeltComments enterKeyToSubmit={true} />
```
**Using API Method:**
```jsx
const commentElement = client.getCommentElement();
commentElement.enableEnterKeyToSubmit();
commentElement.disableEnterKeyToSubmit();
```
</Tab>

<Tab title="Other Frameworks">
**Using Props:**
```jsx
<velt-comments enter-key-to-submit="true"></velt-comments>
```
**Using API Method:**
```jsx
const commentElement = Velt.getCommentElement();
commentElement.enableEnterKeyToSubmit();
commentElement.disableEnterKeyToSubmit();
```
</Tab>
</Tabs>

#### 41. enableAreaComment

Area comments allows users to draw a rectangle and attach a comment to it.
Use this to enable or disable area comments. 

Default: `true`

![](/images/enable-disable-area-comments.png)

<Tabs>
<Tab title="React / Next.js">
**Using Props:**
```jsx
<VeltComments areaComment={false} />
```

**Using API Method:**
```jsx
const commentElement = client.getCommentElement();
commentElement.enableAreaComment();
commentElement.disableAreaComment();
```
</Tab>

<Tab title="Other Frameworks">
**Using Props:**
```jsx
<velt-comments area-comment="false"></velt-comments>
```

Using API Method:
```jsx
const commentElement = client.getCommentElement();
commentElement.enableAreaComment();
commentElement.disableAreaComment();
```
</Tab>
</Tabs>

#### 42. enablePrivateCommentMode

- Private comment mode enables admin users to add comments that are only visible to other admin users.
- Use this to enable or disable private comment mode.

Default: `false`

<Tabs>
<Tab title="React / Next.js">
**Using Props:**
```jsx
<VeltComments privateCommentMode={false} />
```

**Using API:**
```jsx
const commentElement = client.getCommentElement();
commentElement.enablePrivateComments();
commentElement.disablePrivateComments();
```

</Tab>

<Tab title="Other Frameworks">
**Using Props:**
```jsx
<velt-comments private-comment-mode="false"></velt-comments>
```

**Using API:**
```jsx
const commentElement = client.getCommentElement();
commentElement.enablePrivateCommentMode();
commentElement.disablePrivateCommentMode();
```
</Tab>
</Tabs>

#### 43. enableDeleteOnBackspace

- Use this to enable or disable deleting comments when backpsace key is pressed.

Default: `enabled`

<Tabs>
<Tab title="React / Next.js">
**Using Props:**
```jsx
<VeltComments deleteOnBackspace={false} />
```

**Using API:**
```jsx
const commentElement = client.getCommentElement();
commentElement.enableDeleteOnBackspace();
commentElement.disableDeleteOnBackspace();
```

</Tab>

<Tab title="Other Frameworks">
**Using Props:**
```jsx
<velt-comments delete-on-backspace="false"></velt-comments>
```

**Using API:**
```jsx
const commentElement = client.getCommentElement();
commentElement.enableDeleteOnBackspace();
commentElement.disableDeleteOnBackspace();
```
</Tab>
</Tabs>

#### 44. enableDeleteReplyConfirmation

You can enable a confirmation dialog before deleting a reply in comment threads. This feature helps prevent accidental deletions and improves user experience.

<Tabs>
  <Tab title="React / Next.js">
  Using Props:
    ```jsx
    <VeltComments deleteReplyConfirmation={true} />
    ```

    Using API:
    ```javascript
    const commentElement = client.getCommentElement();
    commentElement.enableDeleteReplyConfirmation();
    commentElement.disableDeleteReplyConfirmation();
    ```
  </Tab>
  
  <Tab title="Other Frameworks">
  Using Props:
    ```html
    <velt-comments delete-reply-confirmation="true"></velt-comments>
    ```
    Using API:
    ```javascript
    const commentElement = Velt.getCommentElement();
    commentElement.enableDeleteReplyConfirmation();
    commentElement.disableDeleteReplyConfirmation();
    ```
  </Tab>
</Tabs>


#### 45. sourceId

- When you have multiple elements with the same DOM ID, you can use the `sourceId` attribute to control which element displays the comment dialog when adding a new comment.
- By default, comments appear on all matching elements.
- This is useful in cases where you have multiple instances of the same data component on a page and want the comment to appear on each instance, such as Popover comments on a table.
- You can randomly generate the `sourceId`. It just needs to be unique for each element in the current session.

<Tabs>
  <Tab title="React / Next.js">
    ```jsx
    <VeltCommentTool sourceId="sourceId1" />
    ```
  </Tab>

  <Tab title="Other Frameworks">
    ```html
    <velt-comment-tool source-id="sourceId1"></velt-comment-tool>
    ```
  </Tab>
</Tabs>

#### 46. sortData

- Change the default sorting order of Comments in the Inline Comments Section.
- Default: `none`

There are three options for sorting:
 - `asc`: Show comment annotations in ascending order of when they were last updated
 - `desc`: Show comment annotations in descending order of when they were last updated
 - `none`: Show comment annotations in the sequence they were added

<Tabs>
  <Tab title="React / Next.js">
    ```jsx
    <VeltInlineCommentsSection sortData="desc" />
    ```
  </Tab>
  <Tab title="Other Frameworks">
    ```html
    <velt-inline-comments-section sort-data="desc"></velt-inline-comments-section>
    ```
  </Tab>
</Tabs>


# Modes

#### 47. Freestyle mode

<Info>For a complete setup guide for Freestyle mode, [read here](/async-collaboration/comments/setup/freestyle).</Info>

Whether Freestyle Mode is enabled.

`Default: true`

<Tabs>
<Tab title="React / Next.js">
```jsx
<VeltComments/> {/* Freestyle mode is enabled by default when you use VeltComments}
```
</Tab>

<Tab title="Other Frameworks">
```jsx
<!-- Freestyle mode is enabled by default when you use velt-comments -->
<velt-comments></velt-comments> 
```
</Tab>


</Tabs>
#### 48. enableInboxMode
<Info>For a complete setup guide for Inbox mode, [read here](/async-collaboration/comments/setup/inbox).</Info>

Whether Inbox Mode is enabled.

Default: `false`
<Tabs>
<Tab title="React / Next.js">
**Using Props:**
```jsx
<VeltComments inboxMode={true} />
```
**Using API:**
```jsx
const commentElement = client.getCommentElement();
commentElement.enableInboxMode();
commentElement.disableInboxMode();
```
</Tab>

<Tab title="Other Frameworks">
**Using Props:**
```html
<velt-comments inbox-mode="true"></velt-comments> 
```
**Using API:**
```jsx
const commentElement = Velt.getCommentElement();
commentElement.enableInboxMode();
commentElement.disableInboxMode();
```
</Tab>
</Tabs>

#### 49. enablePopoverMode
<Info>For a complete setup guide for Popover mode, [read here](/async-collaboration/comments/setup/popover).</Info>

Whether Popover Mode is enabled.

Default: `false`
<Tabs>
<Tab title="React / Next.js">
```jsx
<VeltComments popoverMode={true}/>
```

**Using API:**
```jsx
const commentElement = client.getCommentElement();
commentElement.enablePopoverMode();
commentElement.disablePopoverMode();
```
</Tab>

<Tab title="Other Frameworks">
```jsx
<velt-comments popover-mode="true"></velt-comments> 
```

**Using API:**
```jsx
const commentElement = Velt.getCommentElement();
commentElement.enablePopoverMode();
commentElement.disablePopoverMode();
```

</Tab>


</Tabs>


#### 50. enableStreamMode
<Info>For a complete setup guide for Stream mode, [read here](/async-collaboration/comments/setup/stream).</Info>

Whether Stream Mode is enabled.

Default: `false`
<Tabs>
<Tab title="React / Next.js">
```jsx
<VeltComments streamMode={true}/>
```
**Using API:**
```jsx
const commentElement = client.getCommentElement();
commentElement.enableStreamMode();
commentElement.disableStreamMode();
```
</Tab>

<Tab title="Other Frameworks">
```jsx
<velt-comments stream-mode="true"></velt-comments> 
```
**Using API:**
```jsx
const commentElement = Velt.getCommentElement();
commentElement.enableStreamMode();
commentElement.disableStreamMode();
```
</Tab>


</Tabs>


#### 51. enableTextMode
<Info>For a complete setup guide for Text mode, [read here](/async-collaboration/comments/setup/text).</Info>

Whether Text Mode is enabled.

Default: `true`

![](/images/text-comment.png)



<Tabs>
<Tab title="React / Next.js">
**Using Props:**
```jsx
<VeltComments textMode={true}/>
```

**Using API:**
```jsx
const commentElement = client.getCommentElement();
commentElement.enableTextComments();
commentElement.disableTextComments();
```
</Tab>

<Tab title="Other Frameworks">
**Using Props:**
```html
<velt-comments text-mode="true"></velt-comments> 
```

**Using API:**
```jsx
const commentElement = Velt.getCommentElement();
commentElement.enableTextComments();
commentElement.disableTextComments();
```
</Tab>
</Tabs>

#### 52. enablePersistentCommentMode
- When Persistent comment mode is enabled, you can continue leave additional comments after finishing a comment. 
- When it is disabled, you will need to reclick the Comment Tool every time when you want to make a comment.

Default: `false`

<Tabs>
<Tab title="React / Next.js">
```jsx
<VeltComments persistentCommentMode={true}/>
```

```jsx
const commentElement = client.getCommentElement();
commentElement.enablePersistentCommentMode();
commentElement.disablePersistentCommentMode();
```
</Tab>

<Tab title="Other Frameworks">
```jsx
<velt-comments persistent-comment-mode="true"></velt-comments> 
```
```jsx
const commentElement = Velt.getCommentElement();
commentElement.enablePersistentCommentMode();
commentElement.disablePersistentCommentMode();
```
</Tab>


</Tabs>


#### 53. enableInlineCommentMode
![](/images/text-comment-opened.png)

Whether In-line comment mode is enabled.

When In-line comment mode is enabled, comments will appear under the text they are associated with in the DOM, instead of as a pop up window.

Default: `false`
<Tabs>
<Tab title="React / Next.js">
```jsx
<VeltComments inlineCommentMode={true}/>
```
```jsx
const commentElement = client.getCommentElement();
commentElement.enableInlineCommentMode();
commentElement.disableInlineCommentMode();
```
</Tab>

<Tab title="Other Frameworks">
```jsx
<velt-comments inline-comment-mode="true"></velt-comments> 
```

```jsx
const commentElement = Velt.getCommentElement();
commentElement.enableInlineCommentMode();
commentElement.disableInlineCommentMode();
```

</Tab>


</Tabs>



#### 54. enableMultithread
- By default comments are single threaded.
- You can make it multithreaded by setting `multiThread` prop to `true`.
- If you had previously used a wireframe for the comment dialog, you will need to add the [multithread wireframe](/async-collaboration/comments/customize-ui/multithread-comment-dialog/overview).
- Default: `false`
<Tabs>
  <Tab title="React / Next.js">
  ```jsx
  <VeltComments multiThread={true} />
  ```
  </Tab>
  <Tab title="Other Frameworks">
  ```html
  <velt-comments multi-thread="true">
  </velt-comments>
  ```
  </Tab>
  </Tabs>


#### 55. multiThread for Inline Comments Section
- By default [inline comment section](/async-collaboration/comments/setup/inline-comments) is multithreaded.
- You can make it single threaded by setting `multiThread` prop to `false`.
- Default: `true`
<Tabs>
  <Tab title="React / Next.js">
  ```jsx
  <VeltInlineCommentsSection multiThread={false} />
  ```
  </Tab>
  <Tab title="Other Frameworks">
  ```html
  <velt-inline-comments-section multi-thread="false">
  </velt-inline-comments-section>
  ```
  </Tab>
  </Tabs>


# Multimedia Features

#### 56. enableAttachments

![](/images/file-attachment.png)

Whether file attachments are enabled.

Default: `true`

When this is on, users can attach image files to their comments. Users can download or delete an attachment. Users can attach multiple files at once.

Currently we support `.png`, `.jpg`, `.gif` (static & animated), `.svg` file types up to 15MB per file.

<Tabs>
<Tab title="React / Next.js">
```js
<VeltComments attachments={true} />
````
```jsx
const commentElement = client.getCommentElement();
commentElement.enableAttachments();
commentElement.disableAttachments();
```
</Tab>

<Tab title="Other Frameworks">
```js
<velt-comments attachments="true"></velt-comments>
````
```jsx
const commentElement = Velt.getCommentElement();
commentElement.enableAttachments();
commentElement.disableAttachments();
```
</Tab>

</Tabs>

#### 57. setAllowedRecordings

![](/images/recorder.png)

Set the Recorder media options within Comments: (`audio`, `screen`, `video`, `all`).
- `audio`: enables audio recording
- `screen`: enables screen recording
- `video`: enables video recording
- `all`: enables all recording options

Default: `"audio"`

<Tabs>
**Using Props:**
<Tab title="React / Next.js">
```jsx
<VeltComments recordings="video,screen" />
```
**Using API:**
```jsx
const commentElement = client.getCommentElement();
commentElement.setAllowedRecordings("video"); // set video mode only
commentElement.setAllowedRecordings("audio,screen"); // set audio and screen mode only
commentElement.setAllowedRecordings("all"); // set all modes
commentElement.setAllowedRecordings("none"); // disable all modes
```
</Tab>

**Using Props:**
<Tab title="Other Frameworks">
```jsx
<velt-comments recordings="video,screen"></velt-comments>
```
**Using API:**
```jsx
const commentElement = Velt.getCommentElement();
commentElement.setAllowedRecordings("video"); // set video mode only
commentElement.setAllowedRecordings("audio,screen"); // set audio and screen mode only
commentElement.setAllowedRecordings("all"); // set all modes
commentElement.setAllowedRecordings("none"); // disable all modes
```
</Tab>
</Tabs>



#### 58. enableReactions
![](/images/reactions.png)

Whether emoji reactions are enabled.

Default: `true`

<Tabs>
<Tab title="React / Next.js">
```jsx
<VeltComments reactions={true} />
```

```jsx
const commentElement = client.getCommentElement();
commentElement.enableReactions();
commentElement.disableReactions();
```
</Tab>

<Tab title="Other Frameworks">
```jsx
<velt-comments reactions="true"></velt-comments>
```

```jsx
const commentElement = Velt.getCommentElement();
commentElement.enableReactions();
commentElement.disableReactions();
```

</Tab>
</Tabs>



#### 59. enableRecordingSummary

![](/images/transcript-comment.png)
![](/images/transcript-summary.png)


Whether `Recording` summaries in `Comments` are enabled.

`Default: true`
<Tabs>
<Tab title="React / Next.js">
```jsx
<VeltComments recordingSummary={false} />
```

```jsx
const commentElement = client.getCommentElement();
commentElement.enableRecordingSummary();
commentElement.disableRecordingSummary();
```
</Tab>

<Tab title="Other Frameworks">
```jsx
<velt-comments recording-summary="false"></velt-comments>
```

```jsx
const commentElement = Velt.getCommentElement();
commentElement.enableRecordingSummary();
commentElement.disableRecordingSummary();
```
</Tab>

</Tabs>


#### 60. enableRecordingCountdown
![](/gifs/recording-countdown.gif)

Whether the Recorder countdown is enabled.

Default: `true`
<Tabs>
<Tab title="React / Next.js">
```jsx
<VeltComments recordingCountdown={false} />
```

```jsx
const recorderElement = client.getRecorderElement();
recorderElement.enableRecordingCountdown();
recorderElement.disableRecordingCountdown();
```
</Tab>

<Tab title="Other Frameworks">
```jsx
<velt-comments recording-countdown="false"></velt-comments>
```

```jsx
const recorderElement = Velt.getRecorderElement();
recorderElement.enableRecordingCountdown();
recorderElement.disableRecordingCountdown();
```
</Tab>


</Tabs>

#### 61. setCustomReactions

You can set custom reactions by passing a map that contains information about the reactions you want to add.

The map keys should be the reaction ID, and the map value should contain an object with either an `url`, `svg`, or `emoji` field to represent the reaction icon you want to use.

<Tabs>
<Tab title="React / Next.js">

**Using Props:**

```jsx
const customReactions = {
    "URL_EMOJI_ID": {
        "url": "EMOJI_URL"
    },
    "SVG_EMOJI_ID": {
        "svg": "EMOJI_SVG"
    },
    "TEXT_EMOJI_ID": {
        "emoji": "🤣" // emoji as a text
    }
};

<VeltComments customReactions={customReactions} />
```
**Using API:**
```jsx
const commentElement = client.getCommentElement();

const customReactions = {
    "URL_EMOJI_ID": {
        "url": "EMOJI_URL"
    },
    "SVG_EMOJI_ID": {
        "svg": "EMOJI_SVG"
    },
    "TEXT_EMOJI_ID": {
        "emoji": "🤣" // emoji as a text
    }
}
commentElement.setCustomReactions(customReactions);
```

</Tab>

<Tab title="Other Frameworks">
**Using Props:**
```jsx
<velt-comments
  custom-reactions='{"fire_url":{"url":"https://em-content.zobj.net/source/apple/391/fire_1f525.png"},"svg_face":{"svg":"EMOJI_SVG"},"text_emoji":{"emoji":"🤣"}}'>
</velt-comments>
```
**Using API:**
```jsx
const commentElement = Velt.getCommentElement();

const customReactions = {
    "URL_EMOJI_ID": {
        "url": "EMOJI_URL"
    },
    "SVG_EMOJI_ID": {
        "svg": "EMOJI_SVG"
    },
    "TEXT_EMOJI_ID": {
        "emoji": "🤣" // emoji as a text
    }
}
commentElement.setCustomReactions(customReactions);
```

</Tab>


</Tabs>


## 1. To retrieve comments in the frontend
<Tabs>

<Tab title="React / Next.js with Hooks">

To retreive all comments in the frontend, use the `useCommentAnnotations()` hook. The hook will return an array that contains all current comments.

Whenever there is a change to the comments structure, the hook return value will be updated to the latest change.

The hook will automatically unsubscribe from the subscription when the component dismounts.

```jsx
import { useCommentAnnotations } from '@veltdev/react';

export default function YourDocument() {

  let commentAnnotations = useCommentAnnotations()

  return (
    <div>
       {commentAnnotations.map(x => <div>{x.annotationId}</div>)}
    </div>
  )
}
```
By default, `useCommentAnnotations()` will return data for the current `documentId` and `location`.

If you pass in a `documentId` as an argument, it will return all comments in the given `documentId`.

If you pass in a `documentId` as the first argument and a `location` object as the second argument, it will return all comments in the given `documentId` and `location`.


```jsx
import { useCommentAnnotations } from '@veltdev/react';

export default function YourDocument() {

  let commentAnnotations = useCommentAnnotations('my-document-id', { id:'my-location-id',locationName:"MyLocationName"})

  return (
    <div>
       {commentAnnotations.map(x => <div>{x.annotationId}</div>)}
    </div>
  )
}
```
</Tab>

<Tab title="React / Next.js">
To retrieve all comments in the frontend, use the `commentElement.getAllCommentAnnotations()` method and subscribe with a callback function.

Whenever there is a change to the comments structure, the callback function will be triggered and will contain all current comments in an array.

```js
if (client) {
  const commentElement = client.getCommentElement();
  let subscription = commentElement.getAllCommentAnnotations().subscribe((comments) => {
    // Do something with comments
  });
}
```

To unsubscribe from the subscription:
```jsx
subscription?.unsubscribe()
```

By default, `getAllCommentAnnotations` will return data for the current `documentId` and `location`.

If you pass in a `documentId` to `getAllCommentAnnotations` as an argument, it will return all comments in the given `documentId`.

If you pass in a `documentId` as the first argument and a `location` object as the second argument, it will return all comments in the given `documentId` and `location`.


```js
if (client) {
  const commentElement = client.getCommentElement();
  let subscription = commentElement.getAllCommentAnnotations('my-document-id', { id:'my-location-id',locationName:"MainVideoPlayer",timestamp:120}).subscribe((comments) => {
    // Get comments with my-document-id and my-locaiton-id
  });
}
```
</Tab>
<Tab title="Other Frameworks">
To retrieve all comments in the frontend, call getCommentElement() on the Velt client and then `subscribe()` to `getAllCommentAnnotations()` and pass in a callback function.

Whenever there is a change to the comments structure, the callback function will be triggered and will contain all current comments in an array.

```js
if (Velt) {
  const commentElement = Velt.getCommentElement();
  let subscription = commentElement.getAllCommentAnnotations().subscribe((comments) => {
    // Do something with comments
  });
}
```

To unsubscribe from the subscription:
```jsx
subscription?.unsubscribe()
```

By default, `getAllCommentAnnotations` will return data for the current `documentId` and `location`.

If you pass in a `documentId` to `getAllCommentAnnotations` as an argument, it will return all comments in the given `documentId`.

If you pass in a `documentId` as the first argument and a `location` object as the second argument, it will return all comments in the given `documentId` and `location`.


```js
if (Velt) {
  const commentElement = Velt.getCommentElement();
  let subscription = commentElement.getAllCommentAnnotations('my-document-id', { id:'my-location-id',locationName:"MainVideoPlayer",timestamp:120}).subscribe((comments) => {
    // Get comments with my-document-id and my-locaiton-id
  });
}
```
</Tab>
</Tabs>



## 2. To retrieve comments in the backend

For this you should use our Webhook service. Let's say you want to be notified whenever a comment is added or updated, you can provide us an endpoint and we will send the comment data to that end point as and when there is an update. You can then process it further. Note that you cannot retrieve historical comments using this.

You can enable and configure webhook in your Velt Console as shown below. After you enable this, you need to provide an endpoint url. We will make a post request to that endpoint to send the comment data.

To read more about how to configure webhooks, check out the [webhooks documentation](/webhooks/overview).

## 3. Get Count of Unread CommentAnnotations On Current Document

<Tabs>
<Tab title="React / Next.js with Hooks">

You can get the number of `CommentAnnotations` that have at least 1 unread `Comment` on the current `Document` by using the `useUnreadCommentAnnotationCountOnCurrentDocument()` hook:

```jsx
const count = useUnreadCommentAnnotationCountOnCurrentDocument();
useEffect(() => {
  console.log(count, 'countObj')
}, [count])
```
</Tab>
<Tab title="React / Next.js">
You can get the number of `CommentAnnotations` that have at least 1 unread `Comment` on the current `Document` by subscribing to the `getUnreadCommentAnnotationCountOnCurrentDocument()` method:

```jsx
if (client) {
  const commentElement = client.getCommentElement();
  let subscription = commentElement.getUnreadCommentAnnotationCountOnCurrentDocument().subscribe((countObj) => {
    console.log(countObj);
  });
}
```

To unsubscribe from the subscription:
```jsx
subscription?.unsubscribe()
```
</Tab>
<Tab title="Other Frameworks">
You can get the number of `CommentAnnotations` that have at least 1 unread `Comment` on the current `Document` by subscribing to the `getUnreadCommentAnnotationCountOnCurrentDocument()` method:

```jsx
if (Velt) {
  const commentElement = Velt.getCommentElement();
  let subscription = commentElement.getUnreadCommentAnnotationCountOnCurrentDocument().subscribe((countObj) => {
    console.log(countObj);
  });
}
```

To unsubscribe from the subscription:
```jsx
subscription?.unsubscribe()
```
</Tab>
</Tabs>

## 4. Get Count Of Unread Comments On Current Document
<Tabs>
<Tab title="React / Next.js with Hooks">
You can get the number of unread `Comments` on the current `Document` by using the `useUnreadCommentCountOnCurrentDocument()` hook:

```jsx
const count = useUnreadCommentCountOnCurrentDocument();
useEffect(() => {
  console.log(count, 'countObj')
}, [count])
```
</Tab>
<Tab title="React / Next.js">
You can get the number of unread `Comments` on the current `Document` by using the `getUnreadCommentCountOnCurrentDocument()` method:

```jsx
if (client) {
  const commentElement = client.getCommentElement();
  let subscription = commentElement.getUnreadCommentCountOnCurrentDocument().subscribe((countObj) => {
    console.log(countObj);
  });
}
```

To unsubscribe from the subscription:
```jsx
subscription?.unsubscribe()
```
</Tab>

<Tab title="Other Frameworks">
You can get the number of unread `Comments` on the current `Document` by using the `getUnreadCommentCountOnCurrentDocument()` method:

```jsx
if (Velt) {
  const commentElement = Velt.getCommentElement();
  let subscription = commentElement.getUnreadCommentCountOnCurrentDocument().subscribe((countObj) => {
    console.log(countObj);
  });
}
```

To unsubscribe from the subscription:
```jsx
subscription?.unsubscribe()
```
</Tab>
</Tabs>
## 5. Get Count Of Unread CommentAnnotations By Location Id
<Tabs>
<Tab title="React / Next.js with Hooks">

You can get the number of `CommentAnnotations` with at least 1 unread `Comment` by `Location Id` by using the `useUnreadCommentAnnotationCountByLocationId()` hook:

```jsx
const count = useUnreadCommentAnnotationCountByLocationId(locationId);
useEffect(() => {
  console.log(count, 'countObj')
}, [count])
```
</Tab>
<Tab title="React / Next.js">
You can get the number of `CommentAnnotations` with at least 1 unread `Comment` by `Location Id` by using the `getUnreadCommentAnnotationCountByLocationId` method:

```jsx
if (client) {
  const commentElement = client.getCommentElement();
  let subscription = commentElement.getUnreadCommentAnnotationCountByLocationId(locationId).subscribe((countObj) => {
    console.log(countObj);
  });
}
```

To unsubscribe from the subscription:
```jsx
subscription?.unsubscribe()
```

</Tab>
<Tab title="Other Frameworks">
You can get the number of `CommentAnnotations` with at least 1 unread `Comment` by `Location Id` by using the `getUnreadCommentAnnotationCountByLocationId` method:

```jsx
if (Velt) {
  const commentElement = Velt.getCommentElement();
  let subscription = commentElement.getUnreadCommentAnnotationCountByLocationId(locationId).subscribe((countObj) => {
    console.log(countObj);
  });
}
```

To unsubscribe from the subscription:
```jsx
subscription?.unsubscribe()
```
</Tab>
</Tabs>


## 6. Get Count Of Unread Comments By Location Id
<Tabs>
<Tab title="React / Next.js with Hooks">

You can get the number of unread `Comments` by `Location Id` by using the `useUnreadCommentCountByLocationId()` hook:

```jsx
const count = useUnreadCommentCountByLocationId(locationId);
useEffect(() => {
  console.log(count, 'countObj')
}, [count])
```
</Tab>
<Tab title="React / Next.js">
You can get the number of unread `Comments` by `Location Id` by using the `getUnreadCommentCountByLocationId()` method:

```jsx
if (client) {
  const commentElement = client.getCommentElement();
  let subscription = commentElement.getUnreadCommentCountByLocationId(locationId).subscribe((countObj) => {
    console.log(countObj);
  });
}
```

To unsubscribe from the subscription:
```jsx
subscription?.unsubscribe()
```
</Tab>
<Tab title="React / HTML">
You can get the number of unread `Comments` by `Location Id` by using the `getUnreadCommentCountByLocationId()` method:

```jsx
if (Velt) {
  const commentElement = Velt.getCommentElement();
  let subscription = commentElement.getUnreadCommentCountByLocationId(locationId).subscribe((countObj) => {
    console.log(countObj);
  });
}
```

To unsubscribe from the subscription:
```jsx
subscription?.unsubscribe()
```
</Tab>
</Tabs>

## 7. Get Count Of Unread Comments By Annotation Id
<Tabs>
<Tab title="React / Next.js with Hooks">

You can get the number of unread `Comments` by annotation id by using the `useUnreadCommentCountByAnnotationId()` hook:

```jsx
const count = useUnreadCommentCountByAnnotationId(annotationId);
useEffect(() => {
   console.log(count, 'countObj')
}, [count])
```
</Tab>
<Tab title="React / Next.js">
You can get the number of unread `Comments` by annotation id by subscribing to the `getUnreadCommentCountByAnnotationId()` method:

```jsx
if (client) {
  const commentElement = client.getCommentElement();
  let subscription = commentElement.getUnreadCommentCountByAnnotationId(annotationId).subscribe((countObj) => {
    console.log(countObj);
  });
}
```

To unsubscribe from the subscription:
```jsx
subscription?.unsubscribe()
```

</Tab>

<Tab title="Other Frameworks">
You can get the number of unread `Comments` by annotation id by subscribing to the `getUnreadCommentCountByAnnotationId()` method:

```jsx
if (Velt) {
  const commentElement = Velt.getCommentElement();
  let subscription = commentElement.getUnreadCommentCountByAnnotationId(annotationId).subscribe((countObj) => {
    console.log(countObj);
  });
}
```

To unsubscribe from the subscription:
```jsx
subscription?.unsubscribe()
```
</Tab>
</Tabs>

## 8. Get Selected Comments

- Get the currently selected comment annotations.
- This returns an array of [`CommentAnnotation`](/api-reference/models/CommentAnnotation) objects.


<Tabs>
<Tab title="React / Next.js">

```jsx
const commentElement = client.getCommentElement();
const subscription = commentElement.getSelectedComments().subscribe((selectedComments) => {
  console.log('Selected comments:', selectedComments);
});

```

Unsubscribe from the subscription when you're done:
```jsx
subscription?.unsubscribe()

```

</Tab>

<Tab title="Other Frameworks">

```js
const commentElement = Velt.getCommentElement();
const subscription = commentElement.getSelectedComments().subscribe((selectedComments) => {
  console.log('Selected comments:', selectedComments);
});
```

Unsubscribe from the subscription when you're done:
```js
subscription?.unsubscribe()
```

</Tab>
</Tabs>

## 9. Get Comment Annotation by ID

- Retrieve a specific comment annotation by its ID.
- By default, it will return the comment annotation for the current `documentId`.
- If you pass in a `documentId`, it will return the comment annotation for the given `documentId`.

<Tabs>
  <Tab title="React / Next.js">
  Using Hooks:
    ```jsx
    const annotation = useCommentAnnotationById({
      annotationId: '-O6W3jD0Lz3rxuDuqQFx',  // AnnotationID
      documentId: 'document-id'              // DocumentId (Optional)
    });

    useEffect(() => {
      console.log('annotation', annotation);
    }, [annotation]);
    ```

    Using API:
    ```javascript
    const commentElement = client.getCommentElement();

    let subscription = commentElement.getCommentAnnotationById({
      annotationId: '-O6W3jD0Lz3rxuDuqQFx',  // AnnotationID
      documentId: 'document-id'              // DocumentId (Optional)
    }).subscribe((annotation) => {
      console.log('annotation', annotation);
    });
    ```

    To unsubscribe from the subscription:
    ```jsx
    subscription?.unsubscribe()
    ```
  </Tab>
  
  <Tab title="Other Frameworks">
    Using API:
    ```javascript
    const commentElement = Velt.getCommentElement();

    let subscription = commentElement.getCommentAnnotationById({
      annotationId: '-O6W3jD0Lz3rxuDuqQFx',  // AnnotationID
      documentId: 'document-id'              // DocumentId (Optional)
    }).subscribe((annotation) => {
      console.log('annotation', annotation);
    });
    ```

    To unsubscribe from the subscription:
    ```jsx
    subscription?.unsubscribe()
    ```
  </Tab>
</Tabs>

## 1. AI auto categorization of comments

![](/images/ai-categories.png)

Whether AI auto-categorization of comments is enabled.

`Default: false`

We use AI to analyze your comment content and auto-categorize it so users can filter comments easily. You can provide a list of custom categories that we should use to categorize the comments (shown below).
<Tabs>
<Tab title="React / Next.js">
```js
<VeltComments autoCategorize={true} />
```
</Tab>

<Tab title="Other Frameworks">
```js
<velt-comments auto-categorize="true"></velt-comments>
```
</Tab>


</Tabs>
API Method:
<Tabs>
<Tab title="React / Next.js">
```jsx
const commentElement = client.getCommentElement();
commentElement.enableAutoCategorize();
commentElement.disableAutoCategorize();
```
</Tab>

<Tab title="Other Frameworks">
```jsx
const commentElement = Velt.getCommentElement();
commentElement.enableAutoCategorize();
commentElement.disableAutoCategorize();
```
</Tab>
</Tabs>
## 2. Set Custom Categories

![](/images/custom-categories.png)

<Tabs>
<Tab title="React / Next.js">
Pass custom categories in the `customCategory` prop.

`Default categories: Question, Feedback, Bug, Other.`

With custom categories, you can replace the default categories with your own values.

These categories are used in the `Comments Sidebar` to filter comments by category. The AI `autoCategorize` feature uses the list of categories to determine the closest category to choose from.

The input format to the `customCategory` prop should be an array of objects with an `id`, `name`, and `color`. 

The `color` property is used to set the category pill background color.
```js
<VeltComments customCategory={[
  {
    "id": "bug",
    "name": "Bug",
    "color": "red"
  }
]}/>
```
</Tab>

<Tab title="Other Frameworks">
Pass custom categories in the `custom-category`.

`Default categories: Question, Feedback, Bug, Other.`

With custom categories, you can replace the default categories with your own values.

These categories are used in the `Comments Sidebar` to filter comments by category. The AI `auto-categorize` uses the list of categories to determine the closest category to choose from.

The input format to the `custom-category` should be an array of objects with an `id`, `name`, and `color`. 

The `color` property is used to set the category pill background color.
```js
<velt-comments customCategory='[
  {
    "id": "bug",
    "name": "Bug",
    "color": "red"
  }
]'></velt-comments>
```
</Tab>


</Tabs>
API Method:
<Tabs>
<Tab title="React / Next.js">
```jsx
const commentElement = client.getCommentElement();
commentElement.setCustomCategory([
  {
    "id": "bug",
    "name": "Bug",
    "color": "red"
  }
])
```
</Tab>

<Tab title="Other Frameworks">

```jsx
const commentElement = Velt.getCommentElement();
commentElement.setCustomCategory([
  {
    "id": "bug",
    "name": "Bug",
    "color": "red"
  }
])
```
</Tab>


</Tabs>
<Warning>
Make sure to have at least 2 categories set.
</Warning>

## 3. Priority

![](/images/priority-default.png)

Whether to enable setting priority on comments.

`Default: false`

When this is on, users can assign a priority to each comment & filter comment by priority in the sidebar. You can customize the list of priority options as shown later on this page in the Set Custom Priorities section.
<Tabs>
<Tab title="React / Next.js">
```js
<VeltComments priority={true} />
```
</Tab>

<Tab title="Other Frameworks">
```js
<velt-comments priority="true"></velt-comments>
```
</Tab>


</Tabs>
API Method:
<Tabs>
<Tab title="React / Next.js">
```jsx
const commentElement = client.getCommentElement();
commentElement.enablePriority();
commentElement.disablePriority();
```
</Tab>

<Tab title="Other Frameworks">
```jsx
const commentElement = Velt.getCommentElement();
commentElement.enablePriority();
commentElement.disablePriority();
```
</Tab>


</Tabs>
## 4. Set Custom Priorities
![](/images/custom-priority.png)


<Tabs>
<Tab title="React / Next.js">
Pass custom priorities in the `customPriority` prop.

`Default priorities: P0, P1, P2`

With custom priorities, you can replace the default priorities with your own values. These priorities are also used in the comment sidebar to filter comments by priority.

This will work if you have enabled the priority feature.

The `color` property is used to set the priority pill background color.

The `lightColor` property sets the background color of the filter.
```js

<VeltComments customPriority={[
  {
    "id": "low",
    "name": "Low",
    "color": "red",
    "lightColor": "pink",
  },
]}/>
```
</Tab>

<Tab title="Other Frameworks">
Pass custom priorities in the `custom-priority`.

`Default priorities: P0, P1, P2`

With custom priorities, you can replace the default priorities with your own values. These priorities are also used in the comment sidebar to filter comments by priority.

This will work if you have enabled the priority feature.

The `color` property is used to set the priority pill background color.

The `lightColor` property sets the background color of the filter.
```js
<velt-comments custom-priority='[
  {
    "id": "low",
    "name": "Low",
    "color": "red",
    "lightColor": "pink",
  }
]'></velt-comments>
```

</Tab>


</Tabs>

API Method:
<Tabs>
<Tab title="React / Next.js">
```jsx
const commentElement = client.getCommentElement();
commentElement.setCustomPriority([
  {
    "id": "low",
    "name": "Low",
    "color": "red",
    "lightColor": "pink",
  },
])
```
</Tab>

<Tab title="Other Frameworks">
```jsx
const commentElement = Velt.getCommentElement();
commentElement.setCustomPriority([
  {
    "id": "low",
    "name": "Low",
    "color": "red",
    "lightColor": "pink",
  },
])
```
</Tab>
</Tabs>

<Warning>
Make sure to have at least 2 categories set.
</Warning>

## 5. Status

![](/images/status-default.png)

Whether to enable the default status dropdown & filters.

`Default: true`

When this is on, users can assign a status to each comment & filter comment by status in the sidebar. You can customize the list of status options as shown below on this page.
<Tabs>
<Tab title="React / Next.js">
```js
<VeltComments status={true} />
```
</Tab>

<Tab title="Other Frameworks">
```js
<velt-comments status="true"></velt-comments>
```
</Tab>


</Tabs>

API Method:
<Tabs>
<Tab title="React / Next.js">
```jsx
const commentElement = client.getCommentElement();
commentElement.enableStatus();
commentElement.disableStatus();
```
</Tab>

<Tab title="Other Frameworks">

```jsx
const commentElement = Velt.getCommentElement();
commentElement.enableStatus();
commentElement.disableStatus();
```
</Tab>


</Tabs>
## 6. Set Custom Statuses

![](/images/custom-status.png)

<Tabs>
<Tab title="React / Next.js">
Set custom statuses in the `customStatus` prop.

`Default statuses: Open, In Progress, Resolved`

With custom statuses, you can replace the default statuses with your own values. These statuses are also used in the comment sidebar to filter comments by status.

Setting the Status type using the `type` property:
  - `default`: This will be the default status assigned to each comment.
  - `ongoing`: This is treated as an intermediary status, you can add as many statuses with type ongoing as you want.
  - `terminal`: This represents a status that is completed. Comments with this status type are no longer shown in the DOM.

Setting the Status Icon using the `svg` property:
  - You can pass in a serialized SVG. We automatically parse and colorize SVGs. If instead you pass in an icon URL, you will have to colorize each icon yourself to match the status color.

```js
<VeltComments customStatus={[
  {
    "id": "open",
    "name": "Open",
    "color": "white",
    "lightColor":"green",
    "type": "default",
    "svg": "<svg></svg>" // Pass in a serialized SVG
  }
]}/>
```
</Tab>

<Tab title="Other Frameworks">
Set custom statuses in the `custom-status` prop.

`Default statuses: Open, In Progress, Resolved`

With custom statuses, you can replace the default statuses with your own values. These statuses are also used in the comment sidebar to filter comments by status.

Setting the Status type using the `type` property:
  - `default`: This will be the default status assigned to each comment.
  - `ongoing`: This is treated as an intermediary status, you can add as many statuses with type ongoing as you want.
  - `terminal`: This represents a status that is completed. Comments with this status type are no longer shown in the DOM.

Setting the Status Icon using the `svg` property:
  - You can pass in a serialized SVG. We automatically parse and colorize SVGs. If instead you pass in an icon URL, you will have to colorize each icon yourself to match the status color.

```js
<velt-comments custom-status='[
  {
    "id": "open",
    "name": "Open",
    "color": "white",
    "lightColor":"green",
    "type": "default",
    "svg": "<svg></svg>" // Pass in a serialized SVG
  }
]'></velt-comments>
```
</Tab>


</Tabs>
API Method:
<Tabs>
<Tab title="React / Next.js">
```jsx
const commentElement = client.getCommentElement();
commentElement.setCustomStatus([
  {
    "id": "open",
    "name": "Open",
    "color": "white",
    "lightColor":"green",
    "type": "default",
    "svg": "<svg></svg>" // Pass in a serialized SVG
  }
])
```
</Tab>

<Tab title="Other Frameworks">
```jsx
const commentElement = Velt.getCommentElement();
commentElement.setCustomStatus([
  {
    "id": "open",
    "name": "Open",
    "color": "white",
    "lightColor":"green",
    "type": "default",
    "svg": "<svg></svg>" // Pass in a serialized SVG
  }
])
```
</Tab>


</Tabs>
<Warning>
Make sure to have at least 2 categories set.
</Warning>

## 7. Resolve button
![](/images/resolve-button.png)

Whether to show resolve button on comments.

`Default: true`

This adds a tick mark button on the top right corner of the comment dialog. Clicking on this button will mark the comment as resolved.
<Tabs>
<Tab title="React / Next.js">

```js
<VeltComments resolveButton={true} />
```
</Tab>

<Tab title="Other Frameworks">
```js
<velt-comments resolve-button="true"></velt-comments>
```
</Tab>


</Tabs>
API Method:
<Tabs>
<Tab title="React / Next.js">
```jsx
const commentElement = client.getCommentElement();
commentElement.enableResolveButton();
commentElement.disableResolveButton();
```
</Tab>

<Tab title="Other Frameworks">
```jsx
const commentElement = Velt.getCommentElement();
commentElement.enableResolveButton();
commentElement.disableResolveButton();
```
</Tab>


</Tabs>
## 8. Moderator mode

![](/images/moderator-mode.png)

Whether comments require moderator approval.

`Default: false`

By default, when a user adds a comment it is visible to all authenticated users on the same `document`. Moderator mode makes visibility of all comments private to only `admin` users and the comment author. Admin users will see an approve button on the comment dialog. Once approved the comment will be visible to all users who can access the `document`.

You can set some users as `admin` by setting the `isAdmin` property in the User object, during the `identify()` call.
<Tabs>
<Tab title="React / Next.js">
```js
<VeltComments moderatorMode={true} />
```
</Tab>

<Tab title="Other Frameworks">
```js
<velt-comments moderator-mode="true"></velt-comments>
```
</Tab>


</Tabs>
API Method:
<Tabs>
<Tab title="React / Next.js">
```jsx
const commentElement = client.getCommentElement();
commentElement.enableModeratorMode();
commentElement.disableModeratorMode();
```
</Tab>

<Tab title="Other Frameworks">
```jsx
const commentElement = Velt.getCommentElement();
commentElement.enableModeratorMode();
commentElement.disableModeratorMode();
```
</Tab>


</Tabs>

## 9. Ability to accept or reject comments

![](/images/accept-reject.png)

Whether to enable suggestion mode to accept or reject comments.

`Default: false`


<Tabs>
<Tab title="React / Next.js">
To accept comments, set the `suggestionMode` attribute to `true`.
```js
<VeltComments suggestionMode={true} />
```
</Tab>

<Tab title="Other Frameworks">
To accept comments, set the `suggestion-mode` attribute to `true`.
```js
<velt-comments suggestion-mode="true"></velt-comments>
```
</Tab>


</Tabs>

API Method:
<Tabs>
<Tab title="React / Next.js">
```jsx
const commentElement = client.getCommentElement();
commentElement.enableSuggestionMode();
commentElement.disableSuggestionMode();
```

</Tab>

<Tab title="Other Frameworks">
```jsx
const commentElement = Velt.getCommentElement();
commentElement.enableSuggestionMode();
commentElement.disableSuggestionMode();
```
</Tab>


</Tabs>

## 10. Listen to `onCommentAccept` and `onCommentReject` events

To listen to comments that are Accepted or Rejected in Suggestion mode, pass callbacks to the `onCommentAccept` and onCommentReject` event handlers.
<Tabs>
<Tab title="React / Next.js">
```js
<VeltComments onCommentAccept={(event)=>yourMethod(event)}/>
<VeltComments onCommentReject={(event)=>yourMethod(event)}/>
```
</Tab>

<Tab title="Other Frameworks">
```js
const veltCommentsTag = document.querySelector('velt-comments');

veltCommentsTag?.addEventListener('onCommentAccept', (event) => {
  console.log('*** onCommentAccept ***');
  console.log(event.detail);
});

veltCommentsTag?.addEventListener('onCommentReject', (event) => {
  console.log('*** onCommentReject ***');
  console.log(event.detail);
});
```
</Tab>


</Tabs>
Response:

```js
{
    "annotationId": "ANNOTATION_ID",
    "actionUser": {
        // user object
    },
    "actionType": "accept", // accept or reject
    "annotation": {
        // raw annotation object
    },
  	"replaceContentHtml": "HTML_FORMATTED_TEXT_TO_REPLACE", // optional
  	"replaceContentText": "PLAIN_TEXT_TO_REPLACE", // optional
}
```

## 11. Sign In button
![](/images/sign-in-button.png)

Whether to enable Sign In button on comment dialog when user is anonymous or signed out.

`Default: false`

This allows anonymous or signed out users to still read the comments but encourages them to sign in if they want to respond to the comments. 

<Tabs>
<Tab title="React / Next.js">
```js
<VeltComments signInButton={true} />
```
</Tab>

<Tab title="Other Frameworks">
```js
<velt-comments sign-in-button="true"></velt-comments>
```
</Tab>


</Tabs>
API Method:
<Tabs>
<Tab title="React / Next.js">
```jsx
const commentElement = client.getCommentElement();
commentElement.enableSignInButton();
commentElement.disableSignInButton();
```
</Tab>

<Tab title="Other Frameworks">

```jsx
const commentElement = Velt.getCommentElement();
commentElement.enableSignInButton();
commentElement.disableSignInButton();
```
</Tab>


</Tabs>
## 12. onSignIn
When the user clicks on the sign in button, we will emit an `onSignIn` event that you can handle with your own sign in method. 

No data is passed with the event.
<Tabs>
<Tab title="React / Next.js">
```js
<VeltComments onSignIn={() => yourSignInMethod()} />
```
</Tab>

<Tab title="Other Frameworks">
```js
const veltCommentsTag = document.querySelector('velt-comments');

veltCommentsTag?.addEventListener('onSignIn', (event) => {
  console.log('*** onCommentSignIn ***');
  console.log(event.detail);
});
```
</Tab>


</Tabs>
## 13. Enable/Disable private comment mode
![](/images/private-comment.png)


Whether private comment mode is enabled.

`Default: false`

Admin users can enable `private comment mode`. Once `private comment mode` is enabled, all the newly added comment annotations by the admin user will be private comments by default, meaning only other admins can see it.


<Tabs>
<Tab title="React / Next.js">
To enable private comment mode, set the `privateCommentMode` attribute to `true`:
```html
<VeltComments privateCommentMode={true} />
```
</Tab>

<Tab title="Other Frameworks">
To enable private comment mode, set the `private-comment-mode` attribute to `true`:
```html
<velt-comments private-comment-mode="true"></velt-comments>
```
</Tab>


</Tabs>
API Methods:
API to enable/disable private comment mode:
<Tabs>
<Tab title="React / Next.js">
```jsx
const commentElement = client.getCommentElement();
// To enable private comment mode
commentElement.enablePrivateCommentMode();
// To disable private comment mode
commentElement.disablePrivateCommentMode();
```
</Tab>

<Tab title="Other Frameworks">

```jsx
const commentElement = Velt.getCommentElement();
// To enable private comment mode
commentElement.enablePrivateCommentMode();
// To disable private comment mode
commentElement.disablePrivateCommentMode();
```
</Tab>


</Tabs>


## 14. Enable Minimap
![](/images/minimap.png)
- The minimap shows a bar on the edge of the screen with indicators that show where comments exist.
- Use this to enable/disable the minimap. By default it's disabled.
- It can be positioned `left` or `right`. By default, it's positioned on the right side of the screen.

**Option a. Enable using config:**
<Tabs>
<Tab title="React / Next.js">
```jsx
<VeltComments minimap={true} minimapPosition="left" />
```

**API Method:**
```jsx
const commentElement = client.getCommentElement();
commentElement.enableMinimap();
commentElement.disableMinimap();
```

</Tab>

<Tab title="Other Frameworks">
```jsx
<velt-comments minimap="true" minimap-position="left"></velt-comments>
```

**API Method:**
```jsx
const commentElement = Velt.getCommentElement();
commentElement.enableMinimap();
commentElement.disableMinimap();
```
</Tab>

</Tabs>


**Option b. Enable using Minimap Component:**
This offers greater flexibility to customize and position the minimap.
<Tabs>
<Tab title="React / Next.js">
```jsx
<div className="relative-container">
  <VeltCommentsMinimap targetScrollableElementId="scrollableElement" position="left" />
  <div id="scrollableElement">
      {/* scrollable content */}
  </div>
</div>

<style>
  .relative-container {
    position: relative;
  }

  #scrollableElement {
    width: 100%;
    height: 200px; /* or any value */
    overflow: auto;
  }
</style>
```
</Tab>

<Tab title="Other Frameworks">
```jsx
<div class="relative-container">
  <velt-comments-minimap target-scrollable-element-id="scrollableElement" position="left"></velt-comments-minimap>
  <div id="scrollableElement">
      <!-- scrollable content -->
  </div>
</div>

<style>
  .relative-container {
    position: relative;
  }

  #scrollableElement {
    width: 100%;
    height: 200px; /* or any value */
    overflow: auto;
  }
</style>
```
</Tab>
</Tabs>

## 15. Restrict Resolve Action to Admin Users Only

- Restrict the resolve action to admin users and the comment author only.

<Tabs>
    <Tab title="React / Next.js">
      **Using props:**
      ```jsx
      <VeltComments resolveStatusAccessAdminOnly={true} />
      ```
      **Using API:**
      ```javascript
      const commentElement = client.getCommentElement();
      // To enable resolve status access admin only
      commentElement.enableResolveStatusAccessAdminOnly();
      // To disable resolve status access admin only
      commentElement.disableResolveStatusAccessAdminOnly();
      ```
    </Tab>
    <Tab title="Other Frameworks">
      **Using props:**
      ```html
      <velt-comments resolve-status-access-admin-only="true"></velt-comments>
      ```
      **Using API:**
      ```javascript
      const commentElement = Velt.getCommentElement();
      // To enable resolve status access admin only
      commentElement.enableResolveStatusAccessAdminOnly();
      // To disable resolve status access admin only
      commentElement.disableResolveStatusAccessAdminOnly();
      ```
    </Tab>
  </Tabs>

## 16. Toggle "Seen By" Feature
Control whether the "Seen By" feature is enabled for comments. When enabled, it shows which users have seen each comment.

Default: `true`
<Tabs>
    <Tab title="React / Next.js">
      **Using Props:**
      ```jsx
      <VeltComments seenByUsers={false} />
      ```
      **Using API:**
      ```jsx
      const commentElement = client.getCommentElement();
      commentElement.enableSeenByUsers();
      commentElement.disableSeenByUsers();
      ```
    </Tab>
    <Tab title="Other Frameworks">
      **Using Props:**
      ```html
      <velt-comments seen-by-users="false"></velt-comments>
      ```
      **Using API:**
      ```javascript
      const commentElement = Velt.getCommentElement();
      commentElement.enableSeenByUsers();
      commentElement.disableSeenByUsers();
      ```
    </Tab>
  </Tabs>

  ## 1. Dark Mode
![](/images/dark-light-mode.png)

Whether dark mode is enabled.

`Default: false`
<Tabs>
<Tab title="React / Next.js">
```js
<VeltComments darkMode={true} />
````
</Tab>

<Tab title="Other Frameworks">
```js
<velt-comments dark-mode="true"></velt-comments>
````

</Tab>


</Tabs>
API Method:
<Tabs>
<Tab title="React / Next.js">
```jsx
const commentElement = client.getCommentElement();
commentElement.enableDarkMode();
commentElement.disableDarkMode();
```
</Tab>

<Tab title="Other Frameworks">
```jsx
const commentElement = Velt.getCommentElement();
commentElement.enableDarkMode();
commentElement.disableDarkMode();
```
</Tab>


</Tabs>

## 2. Mobile Mode
![](/images/mobile-mode.png)

![](/images/mobile-mode-composer.png)

Whether mobile mode is enabled.

When mobile mode is enabled and the screen width is small enough, comment windows will appear fixed to the bottom of the screen and full width instead of the usual popup window.

`Default: false`
<Tabs>
<Tab title="React / Next.js">
```js
<VeltComments mobileMode={true} />
````
</Tab>

<Tab title="Other Frameworks">
```js
<velt-comments mobile-mode="true"></velt-comments>
````
</Tab>


</Tabs>
API Method:
<Tabs>
<Tab title="React / Next.js">
```jsx
const commentElement = client.getCommentElement();
commentElement.enableMobileMode();
commentElement.disableMobileMode();
```
</Tab>

<Tab title="Other Frameworks">
```jsx
const commentElement = Velt.getCommentElement();
commentElement.enableMobileMode();
commentElement.disableMobileMode();
```
</Tab>

</Tabs>

## 3. Enable / Disable Scroll to Comment on Click

![](/gifs/scroll-on-click.gif)


Whether, users will be scrolled to the location of a `Comment` when it is clicked.

`Default: true`

By default, users will be redirected to a `Comment` if the comment id is provided in the url. But sometimes this experience is annoying, so we have provided a way to disable the option to automatically scroll users to the location of the `Comment`.


<Tabs>
<Tab title="React / Next.js">
To disable the feature, set `scrollToComment` to `false`.
```html
<VeltComments scrollToComment={false}/>
```
</Tab>

<Tab title="Other Frameworks">
To disable the feature, set `scroll-to-comment` to `false`.
```html
<velt-comments scroll-to-comment="false"></velt-comments>
```
</Tab>


</Tabs>
API methods:
<Tabs>
<Tab title="React / Next.js">
```jsx
const commentElement = client.getCommentElement();
// To enable scroll to component
commentElement.enablescrollToComment();
// To disable scroll to component
commentElement.disablescrollToComment();
```
</Tab>

<Tab title="Other Frameworks">

```jsx
const commentElement = Velt.getCommentElement();
// To enable scroll to component
commentElement.enablescrollToComment();
// To disable scroll to component
commentElement.disablescrollToComment();
```
</Tab>


</Tabs>
## 4. Enable pin highlighter outline

![](/images/pin-highlighter-outline.png)

Wheter the pin highlighter outline is enabled or not.

`Default: true`

<Tabs>
<Tab title="React / Next.js">
```jsx
<VeltComments commentPinHighlighter={false} />
```
</Tab>

<Tab title="Other Frameworks">
```jsx
<velt-comments comment-pin-highlighter="false"></velt-comments>
```
</Tab>


</Tabs>
API Methods:

<Tabs>
<Tab title="React / Next.js">
```jsx
const commentElement = client.getCommentElement();
commentElement.enableCommentPinHighlighter(); // to enable comment pin highlight
commentElement.disableCommentPinHighlighter(); // to disable comment pin highlight
```
</Tab>

<Tab title="Other Frameworks">

```jsx
const commentElement = Velt.getCommentElement();
commentElement.enableCommentPinHighlighter(); // to enable comment pin highlight
commentElement.disableCommentPinHighlighter(); // to disable comment pin highlight
```
</Tab>


</Tabs>
## 5. Disable ShadowDOM

Whether the ShadowDOM is enabled or not on certain components.

`Default: enabled`

By default, a ShadowDOM is used with certain components to ensure that your application's CSS does not interfere with the styling of the SDK components.

If you want your application's CSS to affect the styling of the SDK components, you can disable the ShadowDOM.

To disable ShadowDOM on all Comment features:
<Tabs>
<Tab title="React / Next.js">
```jsx
<VeltComments shadowDom={false} />
```
</Tab>

<Tab title="Other Frameworks">
```jsx
<velt-comments shadow-dom="false"></velt-comments>
```
</Tab>
</Tabs>

To disable ShadowDOM on individual features:
<Tabs>
<Tab title="React / Next.js">
```jsx
<VeltComments pinShadowDom={false} dialogShadowDom={false} />
<VeltCommentsSidebar shadowDom={false} />
```
</Tab>

<Tab title="Other Frameworks">
```jsx
<velt-comments pin-shadow-dom="false" dialog-shadow-dom="false"></velt-comments>
<velt-comments-sidebar shadow-dom="false"></velt-comments-sidebar>
```
</Tab>

</Tabs>
API methods:
<Tabs>
<Tab title="React / Next.js">
```jsx
const commentElement = client.getCommentElement();
commentElement.enablePinShadowDOM();
commentElement.disablePinShadowDOM();
commentElement.enableDialogShadowDOM();
commentElement.disableDialogShadowDOM();
commentElement.enableSidebarShadowDOM();
commentElement.disableSidebarShadowDOM();
```
</Tab>

<Tab title="Other Frameworks">
```jsx
const commentElement = Velt.getCommentElement();
commentElement.enablePinShadowDOM();
commentElement.disablePinShadowDOM();
commentElement.enableDialogShadowDOM();
commentElement.disableDialogShadowDOM();
commentElement.enableSidebarShadowDOM();
commentElement.disableSidebarShadowDOM();
```
</Tab>

</Tabs>
## 6. Expand Composer to show Attachments Bar
By default, the `Composer` in the `Comments Dialog` only shows the text input box and does not show the actions bar until the `Composer` is clicked on or the user starts typing.

You can modify this behavior by setting the `Composer Mode` prop to `"expanded"`. This will make the actions bar always visible. 

To keep the default behavior you can set the property to `"default"`.

`Default: "default"`
<Tabs>
<Tab title="React / Next.js">

```jsx
<VeltComments composerMode="expanded"/>
```
</Tab>
<Tab title="Other Frameworks">

```jsx
<velt-comments composer-mode="expanded"></velt-comments>
```
</Tab>

</Tabs>

## 7. Set Custom Cursor
You can set custom mouse cursor when the comment mode is on.
The custom cursor image must be **32 x 32 pixels**.

<Tabs>
<Tab title="React / Next.js">

```jsx
<VeltComments pinCursorImage={BASE64_IMAGE_STRING} />
```
</Tab>
<Tab title="Other Frameworks">

```jsx
<velt-comments pin-cursor-image="BASE64_IMAGE_STRING"></velt-comments>
```
</Tab>
</Tabs>

API Methods:
 <Tabs>
<Tab title="React / Next.js">

```jsx
const commentElement = client.getCommentElement();
commentElement.setPinCursorImage(BASE64_IMAGE_STRING);
```
</Tab>
<Tab title="Other Frameworks">

```jsx
const commentElement = Velt.getCommentElement();
commentElement.setPinCursorImage(BASE64_IMAGE_STRING);
```
</Tab>
</Tabs>

## 8. Show/Hide comments on DOM


Whether comments are shown on the DOM.

`Default: true`

By default, all the comments will be visible on DOM whenever we are able to detect to elements for that. But users can hide it from DOM if required.


There are 2 ways to show/hide comments on DOM:

Configuring attributes on the React Component:
<Tabs>
<Tab title="React / Next.js">
```js
{/* `true` to show comments, `false` to hide comments */}
<VeltComments commentsOnDom={false} />
```
</Tab>

<Tab title="Other Frameworks">
```js
<!-- `true` to show comments, `false` to hide comments -->
<velt-comments comments-on-dom="false"></velt-comments>
```

</Tab>


</Tabs>
Using API methods:
<Tabs>
<Tab title="React / Next.js">
```js
const commentElement = client.getCommentElement();
// to show comments on DOM
commentElement.showCommentsOnDom();
// to hide comments on DOM
commentElement.hideCommentsOnDom();
```
</Tab>

<Tab title="Other Frameworks">
```js
const commentElement = Velt.getCommentElement();
// to show comments on DOM
commentElement.showCommentsOnDom();
// to hide comments on DOM
commentElement.hideCommentsOnDom();
```
</Tab>

</Tabs>
## 9. Comment dialog on hover
![](/gifs/show-dialog-on-hover.gif)

Whether the comment dialog shows on hover over the comment pin or the target element.

`Default: true`
<Tabs>
<Tab title="React / Next.js">
```js
<VeltComments dialogOnHover={true} />
````
</Tab>

<Tab title="Other Frameworks">
```js
<velt-comments dialog-on-hover="true"></velt-comments>
````

</Tab>


</Tabs>
API Method:
<Tabs>
<Tab title="React / Next.js">
```jsx
const commentElement = client.getCommentElement();
commentElement.enableDialogOnHover();
commentElement.disableDialogOnHover();
```
</Tab>

<Tab title="Other Frameworks">

```jsx
const commentElement = Velt.getCommentElement();
commentElement.enableDialogOnHover();
commentElement.disableDialogOnHover();
```
</Tab>


</Tabs>
## 10. Comment dialog on target element click
![](/gifs/hover-cell-comment.gif)

Whether the comment dialog opens when target element is clicked. This is relevant only for Popover mode.

`Default: true`
<Tabs>
<Tab title="React / Next.js">
```js
<VeltComments dialogOnTargetElementClick={true} />
````
</Tab>

<Tab title="Other Frameworks">
```js
<velt-comments dialog-on-hover="true"></velt-comments>
````
</Tab>


</Tabs>
API Method:
<Tabs>
<Tab title="React / Next.js">
```jsx
const commentElement = client.getCommentElement();
commentElement.enableDialogOnTargetElementClick();
commentElement.disableDialogOnTargetElementClick();
```
</Tab>

<Tab title="Other Frameworks">
```jsx
const commentElement = Velt.getCommentElement();
commentElement.enableDialogOnTargetElementClick();
commentElement.disableDialogOnTargetElementClick();
```
</Tab>


</Tabs>
## 11. Floating comment dialog
![](/gifs/floating-comment-dialog.gif)

Whether floating comment dialog is shown next to comment pin on hover or click.

`Default: true`
<Tabs>
<Tab title="React / Next.js">
```js
<VeltComments floatingCommentDialog={true} />
````
</Tab>

<Tab title="Other Frameworks">
```js
<velt-comments floating-comment-dialog="true"></velt-comments>
````

</Tab>


</Tabs>

API Method:
<Tabs>
<Tab title="React / Next.js">
```jsx
const commentElement = client.getCommentElement();
commentElement.enableFloatingCommentDialog();
commentElement.disableFloatingCommentDialog();
```
</Tab>

<Tab title="Other Frameworks">
```jsx
const commentElement = Velt.getCommentElement();
commentElement.enableFloatingCommentDialog();
commentElement.disableFloatingCommentDialog();
```
</Tab>

</Tabs>
## 12. Enable Popover mode triangle
Whether the popover triangle appears when Popover Mode is enabled.

`Default: true`
<Tabs>
<Tab title="React / Next.js">
```jsx
<VeltComments popoverTriangleComponent={true}/>
```
</Tab>

<Tab title="Other Frameworks">
```jsx
<velt-comments popover-triangle-component="true"></velt-comments> 
```

</Tab>


</Tabs>

API Method:
<Tabs>
<Tab title="React / Next.js">
```jsx
const commentElement = client.getCommentElement();
commentElement.enablePopoverTriangleComponent();
commentElement.disablePopoverTriangleComponent();
```
</Tab>

<Tab title="Other Frameworks">
```jsx
const commentElement = Velt.getCommentElement();
commentElement.enablePopoverTriangleComponent();
commentElement.disablePopoverTriangleComponent();
```
</Tab>
</Tabs>

## 13. Show resolved comments on DOM

Whether to show resolved comments on the DOM.

`Default: false`
<Tabs>
<Tab title="React / Next.js">
```jsx
<VeltComments resolvedCommentsOnDom={true} />
```
</Tab>

<Tab title="Other Frameworks">
```html
<velt-comments resolved-comments-on-dom="true"></velt-comments>
```

</Tab>


</Tabs>
API Methods:
<Tabs>
<Tab title="React / Next.js">
```jsx
const commentElement = client.getCommentElement();
// To show resolved comments on dom
commentElement.showResolvedCommentsOnDom();
// To hide resolved comments on dom
commentElement.hideResolvedCommentsOnDom();
```
</Tab>

<Tab title="Other Frameworks">

```jsx
const commentElement = Velt.getCommentElement();
// To show resolved comments on dom
commentElement.showResolvedCommentsOnDom();
// To hide resolved comments on dom
commentElement.hideResolvedCommentsOnDom();
```
</Tab>

</Tabs>

## 14. Comment index
![](/images/index-indicator.png)

Whether comment index is enabled.

`Default: false`

This appears in the comment sidebar and on the comment pins. When this is on, we show a small icon indicating the comment index in the order of creation date. This enables users to find and navigate to the desired comment quickly.

<Tabs>
<Tab title="React / Next.js">
```js
<VeltComments commentIndex={true} />
````
</Tab>

<Tab title="Other Frameworks">
```js
<velt-comments comment-index="true"></velt-comments>
````

</Tab>
</Tabs>

API Method:
<Tabs>
<Tab title="React / Next.js">
```jsx
const commentElement = client.getCommentElement();
commentElement.enableCommentIndex();
commentElement.disableCommentIndex();
```
</Tab>

<Tab title="Other Frameworks">
```jsx
const commentElement = Velt.getCommentElement();
commentElement.enableCommentIndex();
commentElement.disableCommentIndex();
```
</Tab>
</Tabs>

## 15. Device Type Info
![](/images/device-info.png)

Whether device type indicator is enabled.

`Default: false`

When this is on, we show additional information in the `Comment Thread` indicating which device the comment was created on. This is useful especially for design tools, where additional context is needed for debugging issues.

<Tabs>
<Tab title="React / Next.js">
```js
<VeltComments deviceInfo={true} />
```
</Tab>

<Tab title="Other Frameworks">
```js
<velt-comments device-info="true"></velt-comments>
```

</Tab>
</Tabs>

API Method:
<Tabs>
<Tab title="React / Next.js">

```jsx
const commentElement = client.getCommentElement();
commentElement.enableDeviceInfo();
commentElement.disableDeviceInfo();
```
</Tab>

<Tab title="Other Frameworks">
```jsx
const commentElement = Velt.getCommentElement();
commentElement.enableDeviceInfo();
commentElement.disableDeviceInfo();
```
</Tab>
</Tabs>


## 16. Device Indicator on Comment Pins
![](/images/device-info-pin.png)


Whether the device type indicator on `Comment Pins` is enabled.

`Default: false`

When this is on, we show a small device type icon on the `Comment Pin` indicating which device the comment was created on. This is useful especially for design tools, where additional context is needed for debugging issues.
<Tabs>
<Tab title="React / Next.js">
```js
<VeltComments deviceIndicatorOnCommentPins={true} />
````
</Tab>

<Tab title="Other Frameworks">
```jsx
<velt-comments device-indicator-on-comment-pins="true"></velt-comments>
```
</Tab>
</Tabs>


API Method:
<Tabs>
<Tab title="React / Next.js">
```jsx
const commentElement = client.getCommentElement();
commentElement.enableDeviceIndicatorOnCommentPins();
commentElement.disableDeviceIndicatorOnCommentPins();
```
</Tab>

<Tab title="Other Frameworks">
```jsx
const commentElement = Velt.getCommentElement();
commentElement.enableDeviceIndicatorOnCommentPins();
commentElement.disableDeviceIndicatorOnCommentPins();
```
</Tab>
</Tabs>


## 17. Enable Verbose Mode for Unread Comments

Whether `verbose` mode is enabled for unread `Comments`. 

`Default: 'minimal'`

Unread `Comments` can be in `minimal` mode or `verbose` mode.

In `minimal` mode, a small red dot indicator appears for unread `Comments`.

In `verbose` mode, a larger badge with the text "UNREAD" will appear for unread `Comments`.


<Frame>
![](/images/unread-compare.png)
</Frame>

<Tabs>
<Tab title="React / Next.js">
```jsx
<VeltComments unreadIndicatorMode={"verbose"} />
```
</Tab>

<Tab title="Other Frameworks">
```jsx
<velt-comments unread-indicator-mode="verbose"></velt-comments>
```

</Tab>
</Tabs>

API Method:
<Tabs>
<Tab title="React / Next.js">
```jsx
const commentElement = client.getCommentElement();
commentElement.setUnreadIndicatorMode("verbose"); // use badge with text UNREAD
commentElement.setUnreadIndicatorMode("minimal"); // use small red dot indicator
```
</Tab>

<Tab title="Other Frameworks">
```jsx
const commentElement = Velt.getCommentElement();
commentElement.setUnreadIndicatorMode("verbose"); // use badge with text UNREAD
commentElement.setUnreadIndicatorMode("minimal"); // use small red dot indicator
```
</Tab>
</Tabs>


## 18. Show Unread Comments Count on Comment Bubble Component

Whether to show unread or total comment replies count on Comment Bubble Component. 

`Default: 'total'`
<Frame>
![](/images/popover-bubble.png)
</Frame>

<Tabs>
<Tab title="React / Next.js">
`commentCountType`: This prop allows you to decide which count to display.
- `total`: Shows the total number of replies. (default)
- `unread`: Shows the number of unread replies.
```jsx
<VeltCommentBubble commentCountType={"unread"} />
```
</Tab>

<Tab title="Other Frameworks">
`comment-count-type`: This prop allows you to decide which count to display.
- `total`: Shows the total number of replies. (default)
- `unread`: Shows the number of unread replies.
```jsx
<velt-comment-bubble comment-count-type="unread">
</velt-comment-bubble>
```
</Tab>


</Tabs>

## 19. Enable Comment Bubble on Comment Pin

Show a Comment Bubble when user hovers or clicks on the Comment Pin vs showing the Comment Dialog.
The comment dialog will open only on clicking the comment bubble.

`Default: 'false'`

<Tabs>
<Tab title="React / Next.js with Hooks">
**Using Props:**
```jsx
<VeltComments bubbleOnPin={true} />
```
**Using API Method:**
```jsx
const commentElement = useCommentUtils();
commentElement.enableBubbleOnPin();
commentElement.disableBubbleOnPin();
```

</Tab>

<Tab title="React / Next.js">
**Using Props:**
```jsx
<VeltComments bubbleOnPin={true} />
```
**Using API Method:**
```jsx
const commentElement = client.getCommentElement();
commentElement.enableBubbleOnPin();
commentElement.disableBubbleOnPin();
```
</Tab>

<Tab title="Other Frameworks">
**Using Props:**
```jsx
<velt-comments bubble-on-pin="true">
</velt-comments>
```
**Using API Method:**
```jsx
const commentElement = Velt.getCommentElement();
commentElement.enableBubbleOnPin();
commentElement.disableBubbleOnPin();
```

</Tab>
</Tabs>

## 20. Enable showing Comment Bubble when hovering on the Comment Pin

Show a Comment Bubble when user hovers on the Comment Pin vs clicks on it.

`Default: 'true'`

<Tabs>
<Tab title="React / Next.js with Hooks">
**Using Props:**
```jsx
<VeltComments bubbleOnPin={true} bubbleOnPinHover={false} />
```
**Using API Method:**
```jsx
const commentElement = useCommentUtils();

// To enable/disable showing bubble on pin
commentElement.enableBubbleOnPin();
commentElement.disableBubbleOnPin();

// To enable/disable showing bubble on hover
commentElement.enableBubbleOnPinHover();
commentElement.disableBubbleOnPinHover();
```

</Tab>

<Tab title="React / Next.js">
**Using Props:**
```jsx
<VeltComments bubbleOnPin={true} bubbleOnPinHover={false} />
```
**Using API Method:**
```jsx
const commentElement = client.getCommentElement();
// To enable/disable showing bubble on pin
commentElement.enableBubbleOnPin();
commentElement.disableBubbleOnPin();

// To enable/disable showing bubble on hover
commentElement.enableBubbleOnPinHover();
commentElement.disableBubbleOnPinHover();
```
</Tab>

<Tab title="Other Frameworks">
**Using Props:**
```jsx
<velt-comments bubble-on-pin="true" bubble-on-pin-hover="false"></velt-comments>
```
**Using API Method:**
```jsx
const commentElement = Velt.getCommentElement();
// To enable/disable showing bubble on pin
commentElement.enableBubbleOnPin();
commentElement.disableBubbleOnPin();

// To enable/disable showing bubble on hover
commentElement.enableBubbleOnPinHover();
commentElement.disableBubbleOnPinHover();
```

</Tab>
</Tabs>

## 21. Control Collapsed Comments

You can control whether comments inside the annotation should be collapsed.

`Default: true`

<Tabs>
  <Tab title="React / Next.js">
  Using Props:
    ```jsx
    <VeltComments collapsedComments={false} />
    ```

    Using API:
    ```javascript
    const commentElement = client.getCommentElement();
    // To enable collapsed comments
    commentElement.enableCollapsedComments();
    // To disable collapsed comments
    commentElement.disableCollapsedComments();
    ```
  </Tab>
  
  <Tab title="Other Frameworks">
  Using Props:
    ```html
    <velt-comments collapsed-comments="false"></velt-comments>
    ```
    Using API:
    ```javascript
    const commentElement = Velt.getCommentElement();
    // To enable collapsed comments
    commentElement.enableCollapsedComments();
    // To disable collapsed comments
    commentElement.disableCollapsedComments();
    ```
  </Tab>
</Tabs>