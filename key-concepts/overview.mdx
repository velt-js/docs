
## Overview

Velt organizes your collaborative data in a clear hierarchy. This structure helps control Velt feature data access with precision.
The hierarchy is: Organization → Folders → Documents → Locations.

Here are the core concepts:
- [Organizations](#organizations): The top-level container for everything. Think of it as your customer's entire account (e.g., Meta). It holds all their users, groups, and collaborative data.

- [Folders](#folders): A way to group and organize documents, just like in a file system. Folders can contain other folders and documents, inheriting permissions.

- [Documents](#documents): The primary collaborative space. This is where features like comments, presence, and cursors come alive. A document could be a design file, a dashboard, a spreadsheet, or a specific page in your app.

- [Locations](#locations): An optional, granular subspace within a document. If a document is a slide deck, a location is a single slide. If a document is a video, a location could be a specific timestamp.

- [Users](#users): Your end users who use your app.

- [Access Control](#access-control): The rules that control who can access what Velt feature data.

- [Authentication](#authenticate-a-user): The process of authenticating a user in Velt.


## Organizations

### Overview
An **Organization** is the top-level entity.
- It contains folders, documents, locations and users.
- Think of an `organization` as the account belonging to a company (e.g., Company A). This account may have several `users` (Company A employees). A `document` will be any file created within the organization (e.g., document, spreadsheet, slides, etc.). A `location` will be any child section within the document (e.g., slide within a presentation).

### Properties
- By default, Users within the organization can access all of it's resources like folder, documents, contact list etc. This can be modified using access control settings. 
- A user can be added to multiple organizations but can only log in to one organization at a time.
- Access to resources can be restricted by setting controls at the individual resource level.

### APIs

### Frontend APIs
#### Sign in User into an Organization
- Sign in the user into an organization using [these options](/key-concepts/overview#sign-in-a-user). 
- User needs to sign in to an organization in order to perform CRUD operations on it.

### Backend APIs
#### Create Organization
- When the user signs into an organization it will be created automatically if it doesn't exist.
- Explicitly create an organization using the REST API. [Learn more](/api-reference/rest-apis/v2/organizations/add-organizations)

#### Update Organization
- Update organization using the REST API. [Learn more](/api-reference/rest-apis/v2/organizations/update-organizations)

#### Delete Organization
- Delete organization using the REST API. [Learn more](/api-reference/rest-apis/v2/organizations/delete-organizations)
- It will delete all the data (folders, documents, locations and users) within the organization.

#### Get Organization
- Get organization and it's metadata using the REST API. [Learn more](/api-reference/rest-apis/v2/organizations/get-organizations-v2)

#### Disable Organization
- Disable CRUD access to an organization using the REST API. [Learn more](/api-reference/rest-apis/v2/organizations/update-organization-disable-state)

#### Provision Access to an Organization
- Provision access to an organization using [access control APIs](/key-concepts/overview#access-control)



## Folders
### Overview
Folders help you organize documents in a hierarchical way, like a traditional file system.

### Properties
- Folders can contain both documents and subfolders.
- Folders use the same permission model as Organizations and Documents.
- By default, folders inherits the permission from it's organization.
- A user can be added to multiple Folders but can only initialize one Folder at a time.
- By default, all Folder users have access to all Folder resources including sub folders, documents, locations and user contacts.
- Access to individual resources within the Folder **cannot** be restricted by setting controls at the individual resource level.
- Access of the Folder cascades to all resources within the Folder.

### APIs

### Frontend APIs
#### Subscribe to a folder
- Subscribe to a folder and its documents using the `setDocuments` method.
- Subscribe to all documents in the folder or a specific set of documents. If you want to subscribe to specific documents in the folder then you can pass upto 30 documents at a time.

<Note>
**Filtering Behavior:** When using `setDocuments` with the `allDocuments` flag, the method automatically filters out documents the user doesn't have access to instead of failing the entire operation. The folder document limit is set to 50 documents when using `allDocuments: true`. Any documents the user doesn't have access to are silently filtered from the result.
</Note>

<Tabs>
<Tab title="React / Next.js">

**Using Hooks:**
```jsx
const { setDocuments } = useSetDocuments();

{/* Subscribe to a folder and all its documents */}
const rootDocument = [
  {
    id: 'document-1',
    metadata: {
      documentName: 'Document 1'
    }
  }
];

setDocuments(
  rootDocument,
  {
    folderId: 'folder1',
    allDocuments: true
  }
);


{/* Subscribe to a folder and some documents */}
const documents = [
  {
    id: 'document-1',
    metadata: {
      documentName: 'Document 1'
    }
  },
  {
    id: 'document-2',
    metadata: {
      documentName: 'Document 2'
    }
  }
];

setDocuments(
  documents,
  {
    folderId: 'folder1',
  }
);
```

**Using API:**
```jsx
{/* Subscribe to a folder and all its documents */}
await client.setDocuments(
  rootDocument,
  {
    folderId: 'folder1',
    allDocuments: true
  }
);

{/* Subscribe to a folder and some documents */}
await client.setDocuments(
  documents,
  {
    folderId: 'folder1',
  }
);
```
</Tab>
<Tab title="Other Frameworks">
```js
// Subscribe to a folder and all its documents
const rootDocument = [
  {
    id: 'document-1',
    metadata: {
      documentName: 'Document 1'
    }
  }
];

await Velt.setDocuments(
  rootDocument,
  {
    folderId: 'folder1',
    allDocuments: true
  }
);

// Subscribe to a folder and some documents

const documents = [
  {
    id: 'document-1',
    metadata: {
      documentName: 'Document 1'
    }
  },
  {
    id: 'document-2',
    metadata: {
      documentName: 'Document 2'
    }
  }
];

await Velt.setDocuments(
  documents,
  {
    folderId: 'folder1',
  }
);
``` 
</Tab>
</Tabs>

#### Fetch folder metadata
- Retrieve folder metadata and its subfolders using either `organizationId` or `folderId`, with support for pagination.

<Tabs>
<Tab title="React / Next.js">
```jsx
// Get all folders for a specific organization
const folderMetadata = await client.fetchFolders({
  organizationId: 'org1'
});

// Get a specific folder's metadata with its immediate subfolders
const folderMetadata = await client.fetchFolders({
  organizationId: 'org1',
  folderId: 'folder1'
});

console.log(folderMetadata); // { data: { folder1: { ... } }, nextPageToken: '...' }
```
</Tab>
<Tab title="Other Frameworks">
```js
// Get all folders for a specific organization
const folderMetadata = await Velt.fetchFolders({
  organizationId: 'org1'
});

// Get a specific folder's metadata with its immediate subfolders
const folderMetadata = await Velt.fetchFolders({
  organizationId: 'org1',
  folderId: 'folder1'
});

console.log(folderMetadata); // { data: { folder1: { ... } }, nextPageToken: '...' }
```
</Tab>
</Tabs>

### Backend APIs
#### Create Folder
- Create a folder using the REST API. [Learn more](/api-reference/rest-apis/v2/folders/add-folder)

#### Update Folder
- Update folder using the REST API. [Learn more](/api-reference/rest-apis/v2/folders/update-folder)

#### Move Documents to Folder
- Move documents to a folder using the REST API. [Learn more](/api-reference/rest-apis/v2/documents/move-documents)

#### Delete Folder
- Delete folder using the REST API. [Learn more](/api-reference/rest-apis/v2/folders/delete-folder)
- It will delete all the data (subfolders, documents, locations and users) within the folder.

#### Get Folder
- Get folder and it's metadata using the REST API. [Learn more](/api-reference/rest-apis/v2/folders/get-folders)

#### Update Folder Access Type
- Update the access type of a folder using the REST API. [Learn more](/api-reference/rest-apis/v2/folders/update-folder-access)

#### Provision Access to a Folder
Provision access to a folder using [access control APIs](/key-concepts/overview#access-control)


## Documents

### Overview
A **Document** is a collaborative space within an Organization where users work together in real time. Each document includes:

- Feature data (such as Comments, Presence, Cursors, etc.)
- Locations
- Users (distinct from Organization users; see Access Control for details)

For example, in a slide presentation app, the whole slide deck would be a single document.

### Properties
- Anyone connected to the same `documentId` can see and interact with each other's activity, like presence, cursors, comments etc.
- Users can subscribe to a single document or multiple documents at the same time.
- Document inherits the permission from it's organization and parent folder.
- A user can be added to multiple Documents.
- You can set Document level access control to override the Organization's access control it inherited but not the Folder's access control.

<Note>
**Document Access Priority:** Document-level access settings now take priority over folder-level access settings. If a document has its own explicit access configuration, those settings will be used. If the document doesn't have explicit access settings, it will inherit from its parent folder or organization.
</Note>


### APIs

### Frontend APIs
#### Subscribe to Documents
- Use this to set and subscribe to one or multiple documents at the same time.
- You can specify 30 documents at a time.
- The first document in the list will be considered as the root document.
- For features like comments, notifications, recorder, reactions etc. you will be able to read and write to multiple documents at the same time.
- For features like cursors, presence, huddle, live state sync etc. it will default to the root document.
- Sidebar will automatically show data from all the documents.

<Warning>
**Access Filtering:** The `setDocuments` method now filters out documents the user doesn't have access to instead of failing the entire operation. Previously, if any document in the array was inaccessible, the entire query would fail. Now only accessible documents are subscribed, and inaccessible ones are silently filtered out.
</Warning>

**Params:**
- `documents`: [Document[]](/api-reference/sdk/models/data-models#document)
- `options?`: [SetDocumentsRequestOptions](/api-reference/sdk/models/data-models#setdocumentsrequestoptions)

<Tabs>
<Tab title="React / Next.js">

**Using Hooks:**
```jsx
const documents = [
  {
    id: 'document-1',
    metadata: {
      documentName: 'Document 1'
    }
  },
  {
    id: 'document-2',
    metadata: {
      documentName: 'Document 2'
    }
  }
];
const { setDocuments } = useSetDocuments();
setDocuments(documents);
```

**Using API:**
```jsx
const documents = [
  {
    id: 'document-1',
    metadata: {
      documentName: 'Document 1'
    }
  },
  {
    id: 'document-2',
    metadata: {
      documentName: 'Document 2'
    }
  }
];
await client.setDocuments(documents);
```

</Tab>
<Tab title="Other Frameworks">
  **Using API:**
```js
const documents = [
  {
    id: 'document-1',
    metadata: {
      documentName: 'Document 1'
    }
  },
  {
    id: 'document-2',
    metadata: {
      documentName: 'Document 2'
    }
  }
];
await Velt.setDocuments(documents);
```
</Tab>
</Tabs>

##### Read/Write data from multiple documents on the same page
- If you want to display data (eg: comments) from multiple documents on the same page, add `data-velt-document-id` attribute to the container that contains the `document`.
- It will be used to identify which part of the DOM belongs to which document.

```html
<div class="document-container" data-velt-document-id="document-1">
  ...
</div>

<div class="document-container" data-velt-document-id="document-2">
  ...
</div>

<div class="document-container" data-velt-document-id="document-3">
  ...
</div>
```

#### Subscribe to Documents from Other Organizations
- By default, users can only access documents within their own organization.
- Enable cross-organization access by passing the target `organizationId` in the options parameter to `setDocument`/`setDocuments` (see Hook & API Example below).
- Ensure that the user has access to the target document in the target organization.

<Tabs>
    <Tab title="React / Next.js">
    **Using Hook:**
      ```jsx
      {/* Single Document */}
      useSetDocument("DOCUMENT_ID", {
        organizationId: 'ANOTHER_ORGANIZATION_ID'
      });

      {/* Multiple Documents */}
      const documents = [
        {
          id: 'document-1',
          metadata: {
            documentName: 'Document 1'
          }
        },
        {
          id: 'document-2',
          metadata: {
            documentName: 'Document 2'
          }
        }
      ];
      useSetDocuments(documents, {
        organizationId: 'ANOTHER_ORGANIZATION_ID'
      });
      ```
      **Using API:**
      ```jsx
      {/* Single Document */}
      await client.setDocument("DOCUMENT_ID", {
        organizationId: 'ANOTHER_ORGANIZATION_ID'
      });

      {/* Multiple Documents */}
      const documents = [
        {
          id: 'document-1',
          metadata: {
            documentName: 'Document 1'
          }
        },
        {
          id: 'document-2',
          metadata: {
            documentName: 'Document 2'
          }
        }
      ];
      await client.setDocuments(documents, {
        organizationId: 'ANOTHER_ORGANIZATION_ID'
      });
      ```
    </Tab>
    <Tab title="Other Frameworks">
      ```javascript
      {/* Single Document */}
      await Velt.setDocument(DOCUMENT_ID, {
        organizationId: 'ANOTHER_ORGANIZATION_ID'
      });

      {/* Multiple Documents */}
      const documents = [
        {
          id: 'document-1',
          metadata: {
            documentName: 'Document 1'
          }
        },
        {
          id: 'document-2',
          metadata: {
            documentName: 'Document 2'
          }
        }
      ];
      await Velt.setDocuments(documents, {
        organizationId: 'ANOTHER_ORGANIZATION_ID'
      });
      ```
    </Tab>
  </Tabs>

#### Set Root Document
- Set the root document.
- This is useful when you have multiple documents subscribed in your app and you want change the root document during the session.

<Tabs>
  <Tab title="React / Next.js">
    ```jsx
    await client.setRootDocument({id:'DOCUMENT_ID'})
    ```
  </Tab>
  <Tab title="Other Frameworks">
    ```javascript
   await Velt.setRootDocument({id:'DOCUMENT_ID'})
    ```
  </Tab>
</Tabs>


#### Unsubscribe from Documents

- Use this to unsubscribe from all documents at once.
<Tabs>
<Tab title="React / Next.js">

**Using Hooks:**
```jsx
useUnsetDocuments();
```

**Using API:**
```jsx
await client.unsetDocuments();
```
</Tab>

<Tab title="Other Frameworks">
```jsx
await Velt.unsetDocuments();
```
</Tab>
</Tabs>


#### Get Document Metadata

- Use this to get the metadata of a Document.
- This is useful when you want to display the document name in your app or any custom metadata that you have set.
- This returns a subscription with [`DocumentMetadata`](/api-reference/sdk/models/data-models#documentmetadata) object.

<Tabs>
<Tab title="React / Next.js">
```jsx
client.getDocumentMetadata().subscribe((documentMetadata) => {
  console.log("Current document metadata: ", documentMetadata);
});
```
</Tab>

<Tab title="Other Frameworks">
```jsx
Velt.getDocumentMetadata().subscribe((documentMetadata) => {
    console.log("Current document metadata: ", documentMetadata);
});
```
</Tab>
</Tabs>


#### [Fetch Documents](/api-reference/sdk/api/api-methods#fetchdocuments)

- Fetch documents by organization, folder, or specific document IDs.
- Use `allDocuments: true` to fetch all documents for an organization or a specific folder.
- Supports pagination via `nextPageToken` in the response.
- When specifying individual `documentIds`, you can **pass up to 30 IDs at a time**.
<Warning>
This is a one-time fetch, not a realtime subscription. You will need to call again to refresh results.
</Warning>

**Params:**
- `request`: [FetchDocumentsRequest](/api-reference/sdk/models/data-models#fetchdocumentsrequest)
- Returns: [FetchDocumentsResponse](/api-reference/sdk/models/data-models#fetchdocumentsresponse)

<Tabs>
<Tab title="React / Next.js">
```ts
// Gets all documents for given org id
await client.fetchDocuments({ organizationId: 'org1', allDocuments: true });

// Gets all documents for the given folderId
await client.fetchDocuments({ organizationId: 'org1', folderId: 'folder1', allDocuments: true });

// Gets specified documents
await client.fetchDocuments({ organizationId: 'org1', documentIds: ['doc1', 'doc2'] });
```
</Tab>

<Tab title="Other Frameworks">
```js
// Gets all documents for given org id
await Velt.fetchDocuments({ organizationId: 'org1', allDocuments: true });

// Gets all documents for the given folderId
await Velt.fetchDocuments({ organizationId: 'org1', folderId: 'folder1', allDocuments: true });

// Gets specified documents
await Velt.fetchDocuments({ organizationId: 'org1', documentIds: ['doc1', 'doc2'] });
```
</Tab>
</Tabs>

### Backend APIs
#### Create Document
- Create a document using the REST API. [Learn more](/api-reference/rest-apis/v2/documents/add-documents)

#### Update Document
- Update document using the REST API. [Learn more](/api-reference/rest-apis/v2/documents/update-documents)

#### Delete Document
- Delete document using the REST API. [Learn more](/api-reference/rest-apis/v2/documents/delete-documents)
- It will delete all the data (locations and users) within the document.

#### Get Document
- Get document and it's metadata using the REST API. [Learn more](/api-reference/rest-apis/v2/documents/get-documents-v2)

#### Update Document Access Type
- Update the access type of a document using the REST API. [Learn more](/api-reference/rest-apis/v2/documents/update-document-access)

#### Provision Access to a Document
Provision access to a document using [access control APIs](/key-concepts/overview#access-control)

#### Disable Document
- Disable CRUD access to a document using the REST API. [Learn more](/api-reference/rest-apis/v2/documents/update-document-disable-state)

#### Legacy APIs
##### **Subscribe to a Single Document**
- Use this to initialize and subscribe to a single Document.
- Once you set the document, you will start receiving realtime updates from the document.
- **Params:**
  - `documentId`: The unique identifier for the document.
  - `metadata`: (optional) This is a key/value pair object where you can set metadata about the document such as `documentName`. documentName is a special field that we use to display the document name in some Velt Components.

<Tabs>
<Tab title="React / Next.js">

**Using Hooks:**
```jsx
useSetDocument('unique-document-id', {documentName: 'Document Name'});
```

**Using API:**
```jsx
await client.setDocument('unique-document-id', {documentName: 'Document Name'});
```
</Tab>

<Tab title="Other Frameworks">
```jsx
await Velt.setDocument('unique-document-id', {documentName: 'Document Name'});
```
</Tab>

</Tabs>

##### **Unsubscribe from a Single Document**

- Use this to unsubscribe from the root Document
- Once you unset the document, you will no longer receive realtime updates from the document.
- For some parts of your app, you may not need Velt. In such cases, you can unset the document.

<Tabs>
<Tab title="React / Next.js">

**Using Hooks:**
```jsx
useUnsetDocumentId();
```

**Using API:**
```jsx
await client.unsetDocumentId();
```
</Tab>

<Tab title="Other Frameworks">
```jsx
await Velt.unsetDocumentId();
```
</Tab>

</Tabs>


## Locations

### Overview
**Locations** are optional subspaces (JSON object) within a document, providing finer partitioning of data.

Locations can represent:
- Pages
- Sections 
- Video frames
- Data points on maps/charts
- Any other contextual area

For instance:
- In a slide presentation, the entire slide presentation will be a document each individual slide will be a location.
- In a dashboard, the entire dashboard is a document but various filters applied will be locations;
- In a video player, the entire video will be the document and timestamps will be locations.

<Tip> If a **Document** is like a house, a **Location** is like a room within the house. </Tip>

### Properties
- Any user with access to the document will have access to all locations in the document.
- Access controls cannot be set at the location level.
- Locations automatically generate location groups in the sidebar and organizes the comments within the group.
- The location object has these fields:
  - `id` (required): A unique identifier for the location that can be used to reference it later
  - `locationName` (recommended): A human-readable name displayed in Velt components like the `VeltCommentsSideBar`
  - You can add any number of custom fields to the location object.

### APIs

### Frontend APIs
#### Subscribe to Locations
- Use this to set and subscribe to one or multiple locations at the same time.
- The first location in the list will be considered as the root location.
- Features will by default add data to the root location unless you use the location boundaries.
- Sidebar will automatically show data from all the documents.

**Params:**
- `locations`: [Location[]](/api-reference/sdk/models/data-models#location)
- `options?`: [SetLocationsRequestOptions](/api-reference/sdk/models/data-models#setlocationsrequestoptions)
  - `rootLocationId`: The id of the location that will be set as the root location. If you don't specify this, the first location will be set as the root location.
  - `appendLocation`: If you want to append new locations to the existing locations, set this to `true`.

<Tabs>
<Tab title="React / Next.js">

**Using Hooks:**
```jsx
const locations = [
  {id:'location1', locationName:'Location 1'},
  {id:'location2', locationName:'Location 2'}
];
const { setLocations } = useSetLocations();
setLocations(locations);
```

**Using API:**
```jsx
  await client.setLocations([
    {id:'location1', locationName:'Location 1'},
    {id:'location2', locationName:'Location 2'}
  ], {rootLocationId: 'location2'}); // By default 1st location will be set as root location unless rootLocationId is specified.

  // Append new locations
  await client.setLocations([
    {id:'location3', locationName:'Location 3'},
    {id:'location4', locationName:'Location 4'}
  ], {appendLocation: true})
```

</Tab>
<Tab title="Other Frameworks">
```js
  await Velt.setLocations([
    {id:'location1', locationName:'Location 1'},
    {id:'location2', locationName:'Location 2'}
  ], {rootLocationId: 'location2'}); // By default 1st location will be set as root location unless rootLocationId is specified.

  // Append new locations
  await Velt.setLocations([
    {id:'location3', locationName:'Location 3'},
    {id:'location4', locationName:'Location 4'}
  ], {appendLocation: true})
```
</Tab>
</Tabs>

##### Read/Write data from multiple locations on the same page using Location Boundaries
- If you want to display data (eg: comments) from multiple locations on the same page, add `data-velt-location-id` attribute to the container that contains the `location`.
- It will be used to identify which part of the DOM belongs to which location.
- This ensures that the comment added within the location is associated with the correct location.

```html
<div class="location-container" data-velt-location-id="location-1">
  ...
</div>

<div class="location-container" data-velt-location-id="location-2">
  ...
</div>

<div class="location-container" data-velt-location-id="location-3">
  ...
</div>
```


#### Set Root Location
- Set the root location.
- This is useful when you have multiple locations subscribed in your app and you want change the root location during the session.
<Tabs>
  <Tab title="React / Next.js">
    ```jsx
    await client.setRootLocation({id:'LOCATION_ID'})
    ```
  </Tab>
  <Tab title="Other Frameworks">
    ```javascript
    await Velt.setRootLocation({id:'LOCATION_ID'})
    ```
  </Tab>
</Tabs>


#### Unsubscribe from Locations
- Unset locations by ids or all of them if you don't specify any parameters.
<Tabs>

<Tab title="React / Next.js">
```jsx
// remove specific locations
await client.unsetLocationsIds(['location1', 'location2', 'location3'])

// remove all locations
await client.unsetLocationsIds()
```
</Tab>

<Tab title="Other Frameworks">
```jsx
// remove specific locations
await Velt.unsetLocationsIds(['location1', 'location2', 'location3'])

// remove all locations
await Velt.unsetLocationsIds()
```

</Tab>
</Tabs>

#### Legacy APIs

##### **Subscribe to a Single Location**
- Use this to initialize and subscribe to a single Location.
<Tabs>
<Tab title="React / Next.js">

**Using Hooks:**
```jsx
useSetLocation({
  'id': 'locationId1',
  'locationName': 'MainVideoPlayer',
  'videoFrame': '120'
})
```

**Using API:**
```jsx
client.setLocation({
  'id': 'locationId1',
  'locationName': 'MainVideoPlayer',
  'videoFrame': '120'
})
```

</Tab>

<Tab title="Other Frameworks">
```jsx
Velt.setLocation({
  'id': 'locationId1',
  'locationName': 'MainVideoPlayer',
  'videoFrame': '120'
})
```

</Tab>
</Tabs>

##### **Subscribe to Multiple Locations**
- Use this to subscribe to multiple locations at the same time.
- Add additional locations on the page by using set location with the `true` parameter.

<Tabs>
<Tab title="React / Next.js">

**Using Hooks:**
```jsx
useSetLocation({
  'id': 'locationId1',
  'locationName': 'MainVideoPlayer',
  'videoFrame': '120'
  // You can keep adding more field to make the location very specific.
  // The field names can be anything.
})

useSetLocation({
  'id': 'locationId1',
  'locationName': 'MainVideoPlayer',
  'videoFrame': '120'
  // You can keep adding more field to make the location very specific.
  // The field names can be anything.
}, true)
```

**Using API:**
```jsx
client.setLocation({
  'id': 'locationId1',
  'locationName': 'MainVideoPlayer',
  'videoFrame': '120'
  // You can keep adding more field to make the location very specific.
  // The field names can be anything.
});

client.setLocation({
  'id': 'locationId2',
  'locationName': 'MainVideoPlayer2',
  'videoFrame': '120'
  // You can keep adding more field to make the location very specific.
  // The field names can be anything.
}, true);
```

</Tab>

<Tab title="Other Frameworks">
```jsx
Velt.setLocation({
  'id': 'locationId1',
  'locationName': 'MainVideoPlayer',
  'videoFrame': '120'
  // You can keep adding more field to make the location very specific.
  // The field names can be anything.
});

Velt.setLocation({
  'id': 'locationId2',
  'locationName': 'MainVideoPlayer2',
  'videoFrame': '120'
  // You can keep adding more field to make the location very specific.
  // The field names can be anything.
}, true);
```

</Tab>
</Tabs>

## Users
### Overview
- A `User` is anyone authenticated with the Velt SDK.
- After authentication, a user's profile appears in Velt's collaboration features. For example, their name is shown next to their comments, in `@mentions`, and alongside their avatar in presence and cursor features.

### Contact List
When the user is on a document, they can `@mention` other users. By default, the contact list for the `@mention` feature includes users from:

- Organization.
- Folder.
- Document.
- User Groups.
- `@here`: This is a special group that includes only the users explicitly added on the document. This doesn't include organization users or organization user groups.

### User Groups
User Groups let you organize users into teams (like "engineering" or "marketing") for easier management and access control.
- Mention an entire group (e.g., @engineering) instead of individual users, similar to Slack.
- Organization users can be in multiple groups.
- Only organization users can join user groups.

### Properties
- Uniqueness of the user is determined by its `userId`.
- A user can be part of multiple organizations.

### APIs

### Frontend APIs
#### Authenticate a User
There are two ways to authenticate a user in Velt.

1. Using an Auth Provider (recommended)
2. Using Identify method


##### **1. Use Auth Provider**
- With this approach, you configure an authentication provider by specifying the user you want to authenticate and a function that returns a Velt JWT token. 
- This function is automatically called by Velt whenever a token is required—such as during the initial sign-in or when the token expires.
- You should define this authentication provider within the Velt Provider during your app's initialization.
- Use this to [generate a Velt JWT token.](/api-reference/rest-apis/v2/auth/generate-token)
- **Params**:
  - `user`: [User](/api-reference/sdk/models/data-models#user)
  - `retryConfig`: [AuthRetryConfig](/api-reference/sdk/models/data-models#authretryconfig)
  - `generateToken`: `() => Promise<string>`

<Tabs>
<Tab title="React / Next.js">
```js
<VeltProvider authProvider={{
  user,
  retryConfig: { retryCount: 3, retryDelay: 1000 },
  generateToken: async () => {
    // See generateVeltAuthToken() tab for example implementation
    const token = await generateVeltAuthToken();
    return token;
  }
}} />
```

</Tab>
<Tab title="Other Frameworks">
```js
Velt.setVeltAuthProvider({
  user,
  retryConfig: { retryCount: 3, retryDelay: 1000 },
  generateToken: async () => {
    // See generateVeltAuthToken() tab for example implementation
    const token = await generateVeltAuthToken();
    return token;
  }
});

```
</Tab>
<Tab title="generateVeltAuthToken()">
```ts
// Backend example: minimal token generator
export async function generateVeltAuthToken({
  userId,
  organizationId,
  email,
}: {
  userId: string;
  organizationId: string;
  email?: string;
}) {
  const res = await fetch('https://api.velt.dev/v2/auth/generate_token', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'x-velt-api-key': YOUR_VELT_API_KEY_HERE,
      'x-velt-auth-token': YOUR_VELT_AUTH_TOKEN_HERE,
    },
    body: JSON.stringify({
      data: {
        userId,
        userProperties: {
          organizationId,
          ...(email ? { email } : {}),
        },
      },
    }),
  });

  const json = await res.json();
  return json?.result?.data?.token as string | undefined;
}
```
</Tab>
</Tabs>


##### **2. Use Identify with JWT Token**
- In this approach, you will call the `identify` method with the `user` object and a JWT token.
- Here you are responsible for re-generating a JWT token whenever it expires.
- This gives you more flexibility on when and where to initialize the user and generate the token.
- **Params**:
  - `user`: [User](/api-reference/sdk/models/data-models#user)
  - `options`: [Options](/api-reference/sdk/models/data-models#options)
    - `authToken`: `string`
    - `forceReset`: `boolean`

<Tabs>
<Tab title="React / Next.js">
**Using Hook:**
```js
  const user = {
    userId: uid,
    organizationId: organizationId, // this is the organization id the user belongs to. You should always use this.
    name: displayName,
    email: email,
    photoUrl: photoURL,
    color: colorCode, // Use valid Hex code value. Used in the background color of the user's avatar.
    textColor: textColor // Use valid Hex code value. Used in the text color of the user's intial when photoUrl is not present.
  };

  useIdentify(user, {
    authToken: authToken, // this is optional but highly recommended.
  });
```

**Using API:**
```js
await client.identify(user, {
    authToken: authToken, // this is optional but highly recommended.
});
```

</Tab>
<Tab title="Other Frameworks">
**Using API:**
```js
await Velt.identify(user, {
    authToken: authToken, // this is optional but highly recommended.
});
```
</Tab>
</Tabs>

##### Sign in with force reset
- By default, when you identify a user, their authentication state is preserved in the browser until you explicitly sign them out.
- If you update a user's metadata or default access settings in the console and want those changes to take effect right away, you should call the `identify` method again with the `forceReset` option set to `true`.
- `Default: false`

```js
await client.identify(user, {
  forceReset: true
});

```

#### Sign out a User
In a given session or browser tab, if you want to switch users, 
you need to first signout the current user and then sign in using `identify` method again.
This will ensure we clean up the current user session and start a new session with the new user.

```jsx
client.signOutUser();
```

#### Contact List:
In this case, the contact list can be updated on the fly in the frontend. This will not save the list in Velt. You can also search the list directly from your backend and display it in Velt Components.
- [Add/Update Users](/async-collaboration/comments/customize-behavior#updatecontactlist)
- [Search Users](/async-collaboration/comments/customize-behavior#customautocompletesearch)

### Backend APIs
#### Contact List:
This will save the list in Velt.
- [Add Users](/api-reference/rest-apis/v2/users/add-users)
- [Delete Users](/api-reference/rest-apis/v2/users/delete-users)

#### User Groups:
- [Add User Groups](/api-reference/rest-apis/v2/user-groups/add-groups)
- [Add Users to User Groups](/api-reference/rest-apis/v2/user-groups/add-users-to-group)
- [Delete Users from User Groups](/api-reference/rest-apis/v2/user-groups/delete-users-from-group)


## Access Control

### Overview
Velt's access control system is built around four main concepts:

1. **Resources** - The hierarchical structure of your app (Organizations → Folders → Documents)
2. **Access Types** - This is applied to a resource to determine who can access it (public, organizationPrivate, or restricted)
3. **Roles** - This is applied to a user to determine what they can do on a resource (editor or viewer)
4. **Permissions** – Define whether a user can access a resource, based on the resource's access type, the user's role, and explicit permission grants. Access can be temporary or permanent.

### Access Control Model
- **Inheritance (default)**:  Similar to Google Drive, Velt Resources (Organizations, Folders, and Documents) follow a hierarchical permission model. By default, child resources inherit access control settings from their parents.
- **Overrides**: If a resource defines its own access type or user permissions, those explicit settings **override** the inherited values. This precedence applies during both permission evaluation and access enforcement.

**Example: Think of it like folders in Google Drive**
- You create a **folder** and set it to "Anyone with the link can view"
- Any **document** you add to that folder automatically inherits those same sharing settings
- If you want, you can override a specific document's sharing settings to be more restrictive or more open

**In Velt, this works the same way:**
- All **Folders** in that org automatically inherit `organizationPrivate` access
- All **Documents** in those folders also inherit `organizationPrivate` access
- If you explicitly set a specific Document to `restricted` access, that override takes precedence

### 1. Resources
Velt permissions apply to these resources:
- **Organization** – top-level container that groups users, folders, and documents.
- **Folder** – groups documents under an organization.
- **Document** – individual collaborative unit (e.g., a canvas, page, or file).

<Note>
Most permission changes occur at the **Folder** and **Document** level, but Organizations can set defaults that flow down hierarchically.
</Note>

### 2. Access Types
Access types define **who** can access a resource:
- **`public`** **(default)**: Any authenticated user in your app who initializes Velt can access the resource’s collaboration layer.
- **`organizationPrivate`**: Only users in the same organization as the resource can access it.
- **`restricted`**: Only explicitly permitted users can access the resource.

#### APIs (backend)
- **Folder:** Use [Update Folder Access Type](/api-reference/rest-apis/v2/folders/update-folder-access).
- **Document:** Use [Update Document Access Type](/api-reference/rest-apis/v2/documents/update-document-access).
- **Defaults:** Update default access across your app.

<Steps>
<Step title="Open Velt Console">
  Go to the App Config in the Velt Console: [console.velt.dev](https://console.velt.dev/dashboard/config/appconfig)
</Step>
<Step title="Choose default access type">
  Select the desired default access type for new resources and save your changes.
</Step>
</Steps>

<Tip>
**Access Types = who can access. Roles = what they can do once they have access.** These controls are orthogonal and compose together.
</Tip>

### 3. Roles
Roles define **what** an allowed user can do on a resource:
- **Editor:** Read and write access to collaboration features data for the given resource. **This is the default role.**
- **Viewer:** Read-only access to collaboration features data for the given resource.

<Note>
Assign or override roles per resource via your backend when granting permissions. Frontend SDK methods cannot set or change `accessRole`.
</Note>

#### APIs
- [**Add users**](/api-reference/rest-apis/v2/users/add-users)
- [**Remove users**](/api-reference/rest-apis/v2/users/delete-users)
- [**Generate token**](/api-reference/rest-apis/v2/auth/generate-token) (to be used during login)
- [**Add permissions**](/api-reference/rest-apis/v2/auth/add-permissions)
- [**Remove permissions**](/api-reference/rest-apis/v2/auth/remove-permissions)

### 4. Permissions
Permissions control which users can access and collaborate on specific resources in your app. They determine what actions users can perform on organizations, folders, and documents.
Permissions are determined by a combination of the resource's **access type** and the user's **role**.

There are 3 ways to configure permissions in Velt. Choose the approach that best fits your app's architecture:

a. [On-Demand Permissions](#a-on-demand-permissions)

b. [Synced Permissions](#b-synced-permissions)

c. [Real-time Permission Provider](#c-real-time-permission-provider)

#### a. On-Demand Permissions
Grant or revoke permissions **at runtime** when a user logs in or navigates to a resource.
- Best when your app has a very complex and granular permissioning system and you want to keep your system as the source of truth.
- Supports temporary (time-bound) access and permanent access, enabling ad‑hoc sharing and expiring invites.

##### **Temporary vs. Permanent Access**
- **Temporary access**: Grant permissions with an expiry or revoke after session/end of task (e.g., guest reviewers, contractors). Use this when access should automatically end or be short‑lived.
- **Permanent access**: Grant durable permissions for members or long‑term collaborators. Use this when roles rarely change and should persist across sessions.

##### **APIs**
- [**Add Permissions**](/api-reference/rest-apis/v2/auth/add-permissions)
  - **When user logs in**: Use an auth provider with JWT. In the frontend, set the auth provider to fetch a JWT from your backend ([Generate token](/api-reference/rest-apis/v2/auth/generate-token)).
  - **When user switches resources**: Call [Add Permissions API](/api-reference/rest-apis/v2/auth/add-permissions) to grant or adjust access for the newly active resource(s) (folders/documents).
- [**Remove Permissions**](/api-reference/rest-apis/v2/auth/remove-permissions)
  - Revoke access when the user signs out, loses membership, or navigates away from sensitive resources using [Remove Permissions API](/api-reference/rest-apis/v2/auth/remove-permissions).
- [**Get Permissions**](/api-reference/rest-apis/v2/auth/get-permissions)
  - [**Backend API:**](/api-reference/rest-apis/v2/auth/get-permissions) Used to query a user’s effective permissions/roles for the given resources. This returns what permissions your user has according to Velt.
  - **Frontend API:** Use `getUserPermissions` to return the current logged-in user’s permissions on the currently set resources in Velt (e.g., organization, folder, documents).

- **Params:**
  - `request?`: [GetUserPermissionsRequest](/api-reference/sdk/models/data-models#getuserpermissionsrequest)
  - Returns: [GetUserPermissionsResponse](/api-reference/sdk/models/data-models#getuserpermissionsresponse)

<Tabs>
<Tab title="React / Next.js">

**Using API:**
```ts
// Build the request (all fields optional)
const request = {
  organizationId: 'org_123',
  folderIds: ['folder_1', 'folder_2'],
  documentIds: ['doc_1', 'doc_2']
};

// Fetch effective permissions for the current user
const permissions = await client.getUserPermissions(request);

console.log(permissions)

// Example Output:
// {
//   "user_123": {
//     "organization": {
//       "org_123": { "accessRole": "editor", "expiresAt": 1735689600 }
//     },
//     "folders": {
//       "folder_1": { "accessRole": "viewer" },
//       "folder_2": { "errorCode": "permission_denied", "error": "User does not have access to Folder." }
//     },
//     "documents": {
//       "doc_1": { "accessRole": "editor" },
//       "doc_2": { "errorCode": "does_not_exist", "error": "Document does not exist." }
//     }
//   }
// }
```

</Tab>
<Tab title="Other Frameworks">
  **Using API:**
```js
// Build the request (all fields optional)
const request = {
  organizationId: 'org_123',
  folderIds: ['folder_1', 'folder_2'],
  documentIds: ['doc_1', 'doc_2']
};

// Fetch effective permissions for the current user
const permissions = await Velt.getUserPermissions(request);

console.log(permissions)

// Example Output:
// {
//   "user_123": {
//     "organization": {
//       "org_123": { "accessRole": "editor", "expiresAt": 1735689600 }
//     },
//     "folders": {
//       "folder_1": { "accessRole": "viewer" },
//       "folder_2": { "errorCode": "permission_denied", "error": "User does not have access to Folder." }
//     },
//     "documents": {
//       "doc_1": { "accessRole": "editor" },
//       "doc_2": { "errorCode": "does_not_exist", "error": "Document does not exist." }
//     }
//   }
// }
```
</Tab>
</Tabs>

<Note>
When you include `organizationId` in the identify/auth payload, Velt automatically creates and associates the user with that organization. This happens because the "Auto-create Organization Users" console setting is **enabled by default**. To change this default behavior, [go to Console under App Configuration -> Auto-create Organization User](https://console.velt.dev/dashboard/config/appconfig)
</Note>

#### b. Synced Permissions
- Periodically or event‑driven sync between your app and Velt.
- Do an initial bulk load, then keep up with adds/removes/role changes.

##### **APIs (backend)**
- [**Add users**](/api-reference/rest-apis/v2/users/add-users)
  - **Initial sync:** Bulk add existing users so they appear in mentions and can be permissioned.
  - **Ongoing sync:** When a user is added or granted permissions to additional resources in your app, call this API to sync that change in Velt.
- [**Remove users**](/api-reference/rest-apis/v2/users/delete-users)
  - **Ongoing sync:** When a user is removed or their permissions are revoked to resources in your app, call this API to sync that change in Velt.
- [**Get Permissions**](/api-reference/rest-apis/v2/auth/get-permissions)
  - [**Backend API:**](/api-reference/rest-apis/v2/auth/get-permissions) Used to query a user’s effective permissions/roles for the given resources. This returns what permissions your user has according to Velt.
  - **Frontend API:** Use `getUserPermissions` to return the current logged-in user’s permissions on the currently set resources in Velt (e.g., organization, folder, documents).

- **Params:**
  - `request?`: [GetUserPermissionsRequest](/api-reference/sdk/models/data-models#getuserpermissionsrequest)
  - Returns: [GetUserPermissionsResponse](/api-reference/sdk/models/data-models#getuserpermissionsresponse)

<Tabs>
<Tab title="React / Next.js">

**Using API:**
```ts
// Build the request (all fields optional)
const request = {
  organizationId: 'org_123',
  folderIds: ['folder_1', 'folder_2'],
  documentIds: ['doc_1', 'doc_2']
};

// Fetch effective permissions for the current user
const permissions = await client.getUserPermissions(request);

console.log(permissions)

// Example Output:
// {
//   "user_123": {
//     "organization": {
//       "org_123": { "accessRole": "editor", "expiresAt": 1735689600 }
//     },
//     "folders": {
//       "folder_1": { "accessRole": "viewer" },
//       "folder_2": { "errorCode": "permission_denied", "error": "User does not have access to Folder." }
//     },
//     "documents": {
//       "doc_1": { "accessRole": "editor" },
//       "doc_2": { "errorCode": "does_not_exist", "error": "Document does not exist." }
//     }
//   }
// }
```

</Tab>
<Tab title="Other Frameworks">
  **Using API:**
```js
// Build the request (all fields optional)
const request = {
  organizationId: 'org_123',
  folderIds: ['folder_1', 'folder_2'],
  documentIds: ['doc_1', 'doc_2']
};

// Fetch effective permissions for the current user
const permissions = await Velt.getUserPermissions(request);

console.log(permissions)

// Example Output:
// {
//   "user_123": {
//     "organization": {
//       "org_123": { "accessRole": "editor", "expiresAt": 1735689600 }
//     },
//     "folders": {
//       "folder_1": { "accessRole": "viewer" },
//       "folder_2": { "errorCode": "permission_denied", "error": "User does not have access to Folder." }
//     },
//     "documents": {
//       "doc_1": { "accessRole": "editor" },
//       "doc_2": { "errorCode": "does_not_exist", "error": "Document does not exist." }
//     }
//   }
// }
```
</Tab>
</Tabs>

<Note>
When you include `organizationId` in the identify/auth payload, Velt automatically creates and associates the user with that organization. The Auto-create Organization Users console setting is **enabled by default**, so you don't need to pre-create users for on-demand flows. [Go to Console under App Configuration -> Auto-create Organization User](https://console.velt.dev/dashboard/config/appconfig)
</Note>

#### c. Real-time Permission Provider
With this approach, Velt pings your defined endpoint to verify whether a user should be granted access to a resource (organization, folder, or document). This ensures that your backend is still the source of truth and you don't have to sync the permissions into Velt directly.

##### **How it works**
1. You define a permission provider in your frontend that calls an endpoint in your backend.
2. When a user logs in with an organization ID or accesses a folder or document, Velt calls your permission provider with the requested resource details.
3. Your endpoint determines whether the user should be allowed access and generates a signed response using Velt's [Generate Signature API](/api-reference/rest-apis/v2/auth/generate-signature).
4. Velt validates the signature in the backend and updates the user's access accordingly.

##### **When to use**
- Your app has complex, dynamic permissions that change frequently
- You want to avoid syncing permission data to an external system
- You need real-time permission validation without backend synchronization overhead

##### **Implementation**

Use [`setPermissionProvider()`](/api-reference/sdk/api/api-methods#setpermissionprovider) to configure the permission provider in your frontend.

**Params:**
- `onResourceAccessRequired`:
  - Params: [`PermissionQuery[]`](/api-reference/sdk/models/data-models#permissionquery)
  - Returns: [`Promise<ResolverResponse<PermissionResult[]>>`](/api-reference/sdk/models/data-models#permissionresult). In the response, we expect `statusCode` to be `200` and `success` to be `true` as shown in the example response below otherwise we will retry the request.
- `retryConfig`: [`AuthRetryConfig`](/api-reference/sdk/models/data-models#authretryconfig) - Configuration for retry behavior on failures
- `forceRefresh`: `boolean` - Set to true if access control changes frequently. This forces re-validation on each access check in the current session only. Default: `false`


<Warning>
Never expose your Velt API key or Auth Token on the frontend. Always call the [Generate Signature API](/api-reference/rest-apis/v2/auth/generate-signature) from your backend to ensure the security and integrity of permission responses.
</Warning>

<Warning>
If you are using the [identify() method](#2-use-identify-with-jwt-token) for Velt authentication, you **must call the Permission Provider before the `identify()` method is invoked**.
</Warning>

<Tabs>
<Tab title="Frontend">

<Tabs>
<Tab title="React / Next.js">

You can configure the Permission Provider in two ways:

**Option 1: In VeltProvider (Recommended)**

```jsx
<VeltProvider 
  apiKey="YOUR_API_KEY"
  permissionProvider={{
    onResourceAccessRequired: async (requests) => {
      // Example requests array received from Velt:
      // [
      //   {
      //     userId: "user_123",
      //     resource: { type: "document", id: "doc_456", source: "setDocuments" }
      //   },
      //   {
      //     userId: "user_123",
      //     resource: { type: "folder", id: "folder_789", source: "identify" }
      //   }
      // ]
      
      // Call your backend endpoint
      const response = await fetch('/api/check-permissions', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ requests })
      });
      
      const result = await response.json();
      
      // Return format expected by Velt
      return {
        data: result.permissions,
        success: result.success,
        statusCode: result.statusCode,
        signature: result.signature
      };
      
      // Example response:
      // {
      //   data: [
      //     {
      //       userId: "user_123",
      //       resourceId: "doc_456",
      //       type: "document",
      //       hasAccess: true,
      //       accessRole: "editor",
      //       expiresAt: 1735689600
      //     },
      //     {
      //       userId: "user_123",
      //       resourceId: "folder_789",
      //       type: "folder",
      //       hasAccess: true
      //     }
      //   ],
      //   success: true,
      //   statusCode: 200,
      //   signature: "03638f2191bf59c0e536e5b31cbde86df5f44b03fc8e82ee9a8bed7eb324f252"
      // }
    },
    retryConfig: { retryCount: 3, retryDelay: 2000 },
    forceRefresh: false,
  }}
>
  {/* Your app */}
</VeltProvider>
```

**Option 2: Using setPermissionProvider()**

```jsx
const { client } = useVeltClient();

client.setPermissionProvider({
  onResourceAccessRequired: async (requests) => {
    // Example requests array received from Velt:
    // [
    //   {
    //     userId: "user_123",
    //     resource: { type: "document", id: "doc_456", source: "setDocuments" }
    //   },
    //   {
    //     userId: "user_123",
    //     resource: { type: "folder", id: "folder_789", source: "identify" }
    //   }
    // ]
    
    // Call your backend endpoint
    const response = await fetch('/api/check-permissions', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ requests })
    });
    
    const result = await response.json();
    
    // Return format expected by Velt
    return {
      data: result.permissions,
      success: result.success,
      statusCode: result.statusCode,
      signature: result.signature
    };
    
    // Example response:
    // {
    //   data: [
    //     {
    //       userId: "user_123",
    //       resourceId: "doc_456",
    //       type: "document",
    //       hasAccess: true,
    //       accessRole: "editor",
    //       expiresAt: 1735689600
    //     },
    //     {
    //       userId: "user_123",
    //       resourceId: "folder_789",
    //       type: "folder",
    //       hasAccess: true
    //     }
    //   ],
    //   success: true,
    //   statusCode: 200,
    //   signature: "03638f2191bf59c0e536e5b31cbde86df5f44b03fc8e82ee9a8bed7eb324f252"
    // }
  },
  retryConfig: { retryCount: 3, retryDelay: 2000 },
  forceRefresh: false,
});
```

</Tab>
<Tab title="Other Frameworks">
```js
Velt.setPermissionProvider({
  onResourceAccessRequired: async (requests) => {
    // Example requests array received from Velt:
    // [
    //   {
    //     userId: "user_123",
    //     resource: { type: "document", id: "doc_456", source: "setDocuments" }
    //   },
    //   {
    //     userId: "user_123",
    //     resource: { type: "folder", id: "folder_789", source: "identify" }
    //   }
    // ]
    
    // Call your backend endpoint
    const response = await fetch('/api/check-permissions', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ requests })
    });
    
    const result = await response.json();
    
    // Return format expected by Velt
    return {
      data: result.permissions,
      success: result.success,
      statusCode: result.statusCode,
      signature: result.signature
    };
    
    // Example response:
    // {
    //   data: [
    //     {
    //       userId: "user_123",
    //       resourceId: "doc_456",
    //       type: "document",
    //       hasAccess: true,
    //       accessRole: "editor",
    //       expiresAt: 1735689600
    //     },
    //     {
    //       userId: "user_123",
    //       resourceId: "folder_789",
    //       type: "folder",
    //       hasAccess: true
    //     }
    //   ],
    //   success: true,
    //   statusCode: 200,
    //   signature: "03638f2191bf59c0e536e5b31cbde86df5f44b03fc8e82ee9a8bed7eb324f252"
    // }
  },
  retryConfig: { retryCount: 3, retryDelay: 2000 },
  forceRefresh: false,
});
```
</Tab>
</Tabs>

</Tab>
<Tab title="Backend">

Your backend endpoint receives permission requests, checks your authorization system, generates a cryptographic signature, and returns the access decision.

**Flow:**
1. **Receive requests:** Frontend sends permission queries for resources
2. **Find user access:** Check your authorization system to determine if user should have access
3. **Create signature:** Call Velt's [Generate Signature API](/api-reference/rest-apis/v2/auth/generate-signature) with the permissions
4. **Return result:** Send back permissions with signature to frontend

<CodeGroup>

```javascript Node.js / Express
app.post('/api/check-permissions', async (req, res) => {
  // Step 1: Receive requests from frontend
  const { requests } = req.body;
  
  // Step 2: Find user access - Check your authorization system and build permissions array
  const permissions = [];
  
  for (const request of requests) {
    // Query your authorization system (database, auth service, etc.)
    const hasAccess = await yourAuthSystem.checkUserAccess(
      request.userId, 
      request.resource.id, 
      request.resource.type
    );
    
    const permission = {
      userId: request.userId,
      resourceId: request.resource.id,
      type: request.resource.type,
      hasAccess: hasAccess,
    };
    
    // For documents, add access role
    if (request.resource.type === 'document' && hasAccess) {
      permission.accessRole = await yourAuthSystem.getUserRole(
        request.userId, 
        request.resource.id
      ); // 'viewer' or 'editor'
      permission.expiresAt = Date.now() + 10 * 60 * 1000; // Optional: 10 min expiry
    }
    
    permissions.push(permission);
  }

  // Step 3: Create signature using Velt's API
  const signatureResponse = await fetch('https://api.velt.dev/v2/auth/generate_signature', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'x-velt-api-key': process.env.VELT_API_KEY,
      'x-velt-auth-token': process.env.VELT_AUTH_TOKEN,
    },
    body: JSON.stringify({ 
      data: { 
        permissions 
      } 
    })
  });

  const signatureResult = await signatureResponse.json();
  
  // Example signatureResult:
  // {
  //   "result": {
  //     "status": "success",
  //     "message": "Signature generated successfully.",
  //     "data": {
  //       "signature": "03638f2191bf59c0e536e5b31cbde86df5f44b03fc8e82ee9a8bed7eb324f252"
  //     }
  //   }
  // }
  
  // Step 4: Return result - Send back permissions with signature
  res.json({
    permissions: permissions,
    success: true,
    statusCode: 200,
    signature: signatureResult?.result?.data?.signature
  });
});
```

```python Python / Flask
@app.route('/api/check-permissions', methods=['POST'])
def check_permissions():
    # Step 1: Receive requests from frontend
    requests_data = request.json.get('requests', [])
    
    # Step 2: Find user access - Check your authorization system and build permissions array
    permissions = []
    
    for req in requests_data:
        # Query your authorization system (database, auth service, etc.)
        has_access = your_auth_system.check_user_access(
            req['userId'], 
            req['resource']['id'], 
            req['resource']['type']
        )
        
        permission = {
            'userId': req['userId'],
            'resourceId': req['resource']['id'],
            'type': req['resource']['type'],
            'hasAccess': has_access
        }
        
        # For documents, add access role
        if req['resource']['type'] == 'document' and has_access:
            permission['accessRole'] = your_auth_system.get_user_role(
                req['userId'], 
                req['resource']['id']
            )  # 'viewer' or 'editor'
            permission['expiresAt'] = int(time.time() * 1000) + 10 * 60 * 1000  # Optional: 10 min expiry
        
        permissions.append(permission)
    
    # Step 3: Create signature using Velt's API
    signature_response = requests.post(
        'https://api.velt.dev/v2/auth/generate_signature',
        headers={
            'Content-Type': 'application/json',
            'x-velt-api-key': os.getenv('VELT_API_KEY'),
            'x-velt-auth-token': os.getenv('VELT_AUTH_TOKEN'),
        },
        json={
            'data': {
                'permissions': permissions
            }
        }
    )
    
    signature_result = signature_response.json()
    
    # Example signature_result:
    # {
    #   "result": {
    #     "status": "success",
    #     "message": "Signature generated successfully.",
    #     "data": {
    #       "signature": "03638f2191bf59c0e536e5b31cbde86df5f44b03fc8e82ee9a8bed7eb324f252"
    #     }
    #   }
    # }
    
    # Step 4: Return result - Send back permissions with signature
    return jsonify({
        'permissions': permissions,
        'success': True,
        'statusCode': 200,
        'signature': signature_result.get('result', {}).get('data', {}).get('signature')
    })
```

</CodeGroup>

<Note>
Replace `yourAuthSystem.checkUserAccess()` and `yourAuthSystem.getUserRole()` with your actual authorization system calls (e.g., database queries, third-party auth services like Auth0, Clerk, etc.).
</Note>

</Tab>
</Tabs>

### Subscribe to Permission Provider Events

Subscribe to Permission Provider events to monitor the sequence of permission check events. This is useful for debugging, analytics, and tracking access control flows in your application.

<Tabs>
<Tab title="React / Next.js">
```jsx
// Using Hooks
const { client } = useVeltClient();

client.on('permissionProvider').subscribe(e => {
  console.log('Permission Provider Event:', e);
});

// Using API methods
client.on('permissionProvider').subscribe(e => {
  console.log('Permission Provider Event:', e);
});
```
</Tab>
<Tab title="Other Frameworks">
```html
<script>
Velt.on('permissionProvider').subscribe(e => {
  console.log('Permission Provider Event:', e);
});
</script>
```
</Tab>
</Tabs>

#### Available Event Types

The Permission Provider emits the following event types to track the lifecycle of permission checks:

| Event Type | Description |
|-----------|-------------|
| `resourceAccessRequestFormed` | Fired when a permission request is formed internally before being sent |
| `resourceAccessRequestTriggered` | Fired when a permission request is actually triggered and sent |
| `resourceAccessResult` | Fired when a permission check result is received from your server |
| `resourceAccessError` | Fired when an error occurs during permission checking |
| `resourceAccessResultFromCache` | Fired when a permission result is retrieved from cache instead of making a new request |

#### Event Payload Examples

Each event contains structured data about the permission check process:

**resourceAccessRequestFormed**
```json
{
  "event": "resourceAccessRequestFormed",
  "methodName": "identify",
  "timestamp": 1761580810137,
  "source": "internal",
  "payload": {
    "requests": [
      {
        "userId": "1.1",
        "resource": {
          "id": "org1",
          "type": "organization",
          "source": "identify"
        }
      }
    ]
  }
}
```

**resourceAccessRequestTriggered**
```json
{
  "event": "resourceAccessRequestTriggered",
  "timestamp": 1761580810137,
  "methodName": "onResourceAccessRequired",
  "source": "internal",
  "payload": {
    "requests": [
      {
        "userId": "1.1",
        "resource": {
          "id": "org1",
          "type": "organization",
          "source": "identify"
        }
      }
    ],
    "fromCache": false
  }
}
```

**resourceAccessResult**
```json
{
  "event": "resourceAccessResult",
  "timestamp": 1761580811228,
  "methodName": "onResourceAccessRequired",
  "source": "internal",
  "payload": {
    "result": {
      "data": [
        {
          "userId": "1.1",
          "resourceId": "org1",
          "type": "organization",
          "hasAccess": true
        }
      ],
      "success": true,
      "statusCode": 200,
      "signature": "811824052c1ea76f22fc67b36ca5dd867b89d4efeb85cf648bbbc0d2c0675545"
    }
  }
}
```

#### Use Cases

Monitor Permission Provider events to:
- **Debug access control issues**: Track the sequence of permission checks to identify where access is being granted or denied
- **Analytics and monitoring**: Measure permission check latency and cache hit rates
- **Access auditing**: Log all permission requests for security and compliance purposes
- **Performance optimization**: Identify opportunities to optimize caching or reduce redundant permission checks


<Check>
### Quick sanity test
Use this short flow to validate your end-to-end access control setup (roles and access types):
1. Change a user's role to **viewer** for a document on the backend.
2. Refresh the client and confirm they can read but not write comments/annotations.
3. Switch the document's access type to **restricted** and remove the user's explicit permission.
4. Confirm the user can no longer access collaboration data for that document.
</Check>