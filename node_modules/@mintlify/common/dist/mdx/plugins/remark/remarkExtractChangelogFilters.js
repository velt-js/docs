export function remarkExtractChangelogFilters(mdxExtracts) {
    return (tree) => {
        const tagCounts = new Map();
        for (let nodeIndex = 0; nodeIndex < tree.children.length; nodeIndex++) {
            const node = tree.children[nodeIndex];
            if (node.type === 'mdxJsxFlowElement' && node.name === 'Update') {
                const tagsAttribute = node.attributes.find((attr) => attr.name === 'tags');
                if (tagsAttribute &&
                    tagsAttribute.value &&
                    tagsAttribute.value.type === 'mdxJsxAttributeValueExpression') {
                    let tags = [];
                    try {
                        tags = JSON.parse(tagsAttribute.value.value);
                    }
                    catch (_a) {
                        const isProgram = tagsAttribute.value.data.estree.type === 'Program';
                        if (isProgram && tagsAttribute.value.data.estree.body.length === 1) {
                            const body = tagsAttribute.value.data.estree.body[0];
                            if (body.type === 'ExpressionStatement' &&
                                body.expression.type === 'ArrayExpression') {
                                tags = body.expression.elements
                                    .map((element) => {
                                    if (element.type === 'Literal') {
                                        return element.value;
                                    }
                                    return null;
                                })
                                    .filter(Boolean);
                            }
                        }
                    }
                    if (Array.isArray(tags)) {
                        tags.forEach((tag) => {
                            if (!!tag.trim()) {
                                tagCounts.set(tag, (tagCounts.get(tag) || 0) + 1);
                            }
                        });
                    }
                }
            }
        }
        const filters = Array.from(tagCounts.entries())
            .map(([tag, count]) => ({
            tag,
            count,
        }))
            .sort((a, b) => b.count - a.count);
        if (mdxExtracts && filters.length) {
            mdxExtracts.changelogFilters = filters;
        }
    };
}
