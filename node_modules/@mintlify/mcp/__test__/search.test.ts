import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import axios from 'axios';
import { describe, expect, test, vi, beforeEach, afterEach } from 'vitest';

import {
  fetchSearchConfigurationAndOpenApi,
  createSearchTool,
} from '../src/mcp-template/src/search.js';

vi.mock('axios');

vi.mock('trieve-ts-sdk', () => {
  return {
    TrieveSDK: vi.fn().mockImplementation(() => ({
      autocomplete: vi.fn().mockResolvedValue({
        chunks: [
          {
            chunk: {
              id: '1',
              link: '/docs/getting-started',
              chunk_html: 'Getting started with our API',
              metadata: {
                title: 'Getting Started',
              },
            },
          },
        ],
      }),
    })),
  };
});

vi.mock('../src/mcp-template/src/config.readonly.js', () => ({
  SUBDOMAIN: 'test-subdomain',
  SERVER_URL: 'https://test-server.com',
}));

describe('Search Functionality', () => {
  describe('fetchSearchConfigurationAndOpenApi', () => {
    beforeEach(() => {
      vi.clearAllMocks();
    });

    afterEach(() => {
      vi.clearAllMocks();
    });

    test('should fetch configuration successfully', async () => {
      const mockConfig = {
        name: 'Test API',
        trieveApiKey: 'test-key',
        trieveDatasetId: 'test-dataset',
      };

      (axios.get as ReturnType<typeof vi.fn>).mockResolvedValueOnce({
        data: mockConfig,
      });

      const config = await fetchSearchConfigurationAndOpenApi('test-subdomain');
      expect(config).toEqual(mockConfig);
      expect(axios.get).toHaveBeenCalledWith('https://test-server.com/api/mcp/cli/test-subdomain');
    });

    test('should handle fetch errors', async () => {
      const mockError = new Error('Request failed');
      (axios.get as ReturnType<typeof vi.fn>).mockRejectedValueOnce(mockError);

      await expect(fetchSearchConfigurationAndOpenApi('invalid-subdomain')).rejects.toThrow(
        "Error fetching invalid-subdomain's MCP config"
      );
    });
  });

  describe('createSearchTool', () => {
    test('should create search tool with correct configuration', async () => {
      const mockServer = {
        tool: vi.fn(),
      } as unknown as McpServer;

      const mockConfig = {
        name: 'Test API',
        trieveApiKey: 'test-key',
        trieveDatasetId: 'test-dataset',
      };

      (axios.get as ReturnType<typeof vi.fn>).mockResolvedValueOnce({
        data: mockConfig,
      });

      await createSearchTool(mockServer);

      expect(mockServer.tool).toHaveBeenCalledWith(
        'search',
        expect.stringContaining('Search across the Test API documentation'),
        expect.any(Object),
        expect.any(Function)
      );
    });

    test('should handle search execution', async () => {
      const mockServer = {
        tool: vi.fn(),
      } as unknown as McpServer;

      const mockConfig = {
        name: 'Test API',
        trieveApiKey: 'test-key',
        trieveDatasetId: 'test-dataset',
      };

      (axios.get as ReturnType<typeof vi.fn>).mockResolvedValueOnce({
        data: mockConfig,
      });

      await createSearchTool(mockServer);

      const searchHandler = (mockServer.tool as ReturnType<typeof vi.fn>).mock.calls[0]![3]!;

      const result = await searchHandler({ query: 'test query' });

      expect(result).toHaveProperty('content');
      expect(result.content).toHaveLength(1);
      expect(result.content[0]).toEqual({
        type: 'text',
        text: expect.stringContaining('Getting Started'),
      });
    });
  });
});
