import { DataSchema, DataSchemaArray } from '@mintlify/validation';
import { z } from 'zod';

import { dataSchemaToZod } from '../src/mcp-template/src/openapi/zod.js';

describe('dataSchemaToZod', () => {
  it('should handle empty schemas', () => {
    const schema: DataSchema = {} as DataSchema;
    const zodSchema = dataSchemaToZod(schema);

    expect(zodSchema).toBeInstanceOf(z.ZodType);
    expect(() => zodSchema.parse('anything')).not.toThrow();
  });

  it('should convert null schema to z.null()', () => {
    const schema: DataSchema = { type: 'null' };
    const zodSchema = dataSchemaToZod(schema);

    expect(() => zodSchema.parse(null)).not.toThrow();
    expect(() => zodSchema.parse('not null')).toThrow();
  });

  it('should convert boolean schema to z.boolean()', () => {
    const schema: DataSchema = { type: 'boolean' };
    const zodSchema = dataSchemaToZod(schema);

    expect(() => zodSchema.parse(true)).not.toThrow();
    expect(() => zodSchema.parse(false)).not.toThrow();
    expect(() => zodSchema.parse('not boolean')).toThrow();
  });

  it('should convert string enum schema to z.enum()', () => {
    const schema: DataSchema = {
      type: 'enum<string>',
      enum: ['option1', 'option2', 'option3'],
    };
    const zodSchema = dataSchemaToZod(schema);

    expect(() => zodSchema.parse('option1')).not.toThrow();
    expect(() => zodSchema.parse('option2')).not.toThrow();
    expect(() => zodSchema.parse('option3')).not.toThrow();
    expect(() => zodSchema.parse('option4')).toThrow();
  });

  it('should convert number enum schema to transformed z.enum()', () => {
    const schema: DataSchema = {
      type: 'enum<number>',
      enum: [1, 2, 3],
    };
    const zodSchema = dataSchemaToZod(schema);

    expect(() => zodSchema.parse('1')).not.toThrow();
    expect(() => zodSchema.parse('2')).not.toThrow();
    expect(() => zodSchema.parse('3')).not.toThrow();
    expect(() => zodSchema.parse('4')).toThrow();

    expect(() => zodSchema.parse(1)).toThrow();
    expect(() => zodSchema.parse(2)).toThrow();
    expect(() => zodSchema.parse(3)).toThrow();
    expect(() => zodSchema.parse(4)).toThrow();
  });

  it('should convert file schema to z.instanceof(File)', () => {
    const schema: DataSchema = { type: 'file' };
    const zodSchema = dataSchemaToZod(schema);

    const mockFile = new File(['content'], 'filename.txt');
    expect(() => zodSchema.parse(mockFile)).not.toThrow();
    expect(() => zodSchema.parse('not a file')).toThrow();
  });

  it('should convert any schema to z.any()', () => {
    const schema: DataSchema = { type: 'any' };
    const zodSchema = dataSchemaToZod(schema);

    expect(() => zodSchema.parse('string')).not.toThrow();
    expect(() => zodSchema.parse(123)).not.toThrow();
    expect(() => zodSchema.parse(true)).not.toThrow();
    expect(() => zodSchema.parse(null)).not.toThrow();
  });

  describe('string schema', () => {
    it('should convert basic string schema to z.string()', () => {
      const schema: DataSchema = { type: 'string' };
      const zodSchema = dataSchemaToZod(schema);

      expect(() => zodSchema.parse('valid string')).not.toThrow();
      expect(() => zodSchema.parse(123)).toThrow();
    });

    it('should handle string schema with min/max length', () => {
      const schema: DataSchema = {
        type: 'string',
        minLength: 3,
        maxLength: 10,
      };
      const zodSchema = dataSchemaToZod(schema);

      expect(() => zodSchema.parse('abc')).not.toThrow();
      expect(() => zodSchema.parse('abcdefghij')).not.toThrow();
      expect(() => zodSchema.parse('ab')).toThrow();
      expect(() => zodSchema.parse('abcdefghijk')).toThrow();
    });

    it('should handle string schema with pattern', () => {
      const schema: DataSchema = {
        type: 'string',
        pattern: '^[A-Z]{3}\\d{2}$',
      };
      const zodSchema = dataSchemaToZod(schema);

      expect(() => zodSchema.parse('ABC12')).not.toThrow();
      expect(() => zodSchema.parse('XYZ99')).not.toThrow();
      expect(() => zodSchema.parse('abc12')).toThrow();
      expect(() => zodSchema.parse('AB123')).toThrow();
    });

    it('should handle string schema with email format', () => {
      const schema: DataSchema = {
        type: 'string',
        format: 'email',
      };
      const zodSchema = dataSchemaToZod(schema);

      expect(() => zodSchema.parse('test@example.com')).not.toThrow();
      expect(() => zodSchema.parse('invalid-email')).toThrow();
    });

    it('should handle string schema with url format', () => {
      const schema: DataSchema = {
        type: 'string',
        format: 'url',
      };
      const zodSchema = dataSchemaToZod(schema);

      expect(() => zodSchema.parse('https://example.com')).not.toThrow();
      expect(() => zodSchema.parse('not a url')).toThrow();
    });

    it('should handle string schema with uuid format', () => {
      const schema: DataSchema = {
        type: 'string',
        format: 'uuid',
      };
      const zodSchema = dataSchemaToZod(schema);

      expect(() => zodSchema.parse('123e4567-e89b-12d3-a456-426614174000')).not.toThrow();
      expect(() => zodSchema.parse('not-a-uuid')).toThrow();
    });

    it('should handle string schema with date-time format', () => {
      const schema: DataSchema = {
        type: 'string',
        format: 'date-time',
      };
      const zodSchema = dataSchemaToZod(schema);

      expect(() => zodSchema.parse(new Date().toISOString())).not.toThrow();
      expect(() => zodSchema.parse('2023-01-01')).not.toThrow();
    });
  });

  describe('number schema', () => {
    it('should convert basic number schema to z.number()', () => {
      const schema: DataSchema = { type: 'number' };
      const zodSchema = dataSchemaToZod(schema);

      expect(() => zodSchema.parse(123)).not.toThrow();
      expect(() => zodSchema.parse(123.45)).not.toThrow();
      expect(() => zodSchema.parse('123')).toThrow();
    });

    it('should handle integer schema', () => {
      const schema: DataSchema = { type: 'integer' };
      const zodSchema = dataSchemaToZod(schema);

      expect(() => zodSchema.parse(123)).not.toThrow();
      expect(() => zodSchema.parse(123.45)).toThrow();
    });

    it('should handle number schema with min/max', () => {
      const schema: DataSchema = {
        type: 'number',
        minimum: 5,
        maximum: 10,
      };
      const zodSchema = dataSchemaToZod(schema);

      expect(() => zodSchema.parse(5)).not.toThrow();
      expect(() => zodSchema.parse(7.5)).not.toThrow();
      expect(() => zodSchema.parse(10)).not.toThrow();
      expect(() => zodSchema.parse(4.9)).toThrow();
      expect(() => zodSchema.parse(10.1)).toThrow();
    });

    it('should handle number schema with exclusive min/max', () => {
      const schema: DataSchema = {
        type: 'number',
        minimum: 5,
        maximum: 10,
        exclusiveMinimum: true,
        exclusiveMaximum: true,
      };
      const zodSchema = dataSchemaToZod(schema);

      expect(() => zodSchema.parse(5.1)).not.toThrow();
      expect(() => zodSchema.parse(9.9)).not.toThrow();
      expect(() => zodSchema.parse(5)).toThrow();
      expect(() => zodSchema.parse(10)).toThrow();
    });
  });

  describe('array schema', () => {
    it('should convert basic array schema to z.array()', () => {
      const schema: DataSchema = {
        type: 'array',
        items: [{ type: 'string' }],
      };
      const zodSchema = dataSchemaToZod(schema);

      expect(() => zodSchema.parse(['a', 'b', 'c'])).not.toThrow();
      expect(() => zodSchema.parse([123])).toThrow();
    });

    it('should handle array schema with min/max items', () => {
      const schema: DataSchema = {
        type: 'array',
        items: [{ type: 'number' }],
        minItems: 2,
        maxItems: 4,
      };
      const zodSchema = dataSchemaToZod(schema);

      expect(() => zodSchema.parse([1, 2])).not.toThrow();
      expect(() => zodSchema.parse([1, 2, 3, 4])).not.toThrow();
      expect(() => zodSchema.parse([1])).toThrow();
      expect(() => zodSchema.parse([1, 2, 3, 4, 5])).toThrow();
    });

    it('should handle array with multiple item types', () => {
      const schema: DataSchema = {
        type: 'array',
        items: [{ type: 'string' }, { type: 'number' }] as DataSchemaArray,
      };
      const zodSchema = dataSchemaToZod(schema);

      expect(() => zodSchema.parse(['abc', 123])).not.toThrow();
    });
  });

  describe('object schema', () => {
    it('should convert basic object schema', () => {
      const schema: DataSchema = {
        type: 'object',
        properties: {
          name: [{ type: 'string', required: true }],
          age: [{ type: 'number' }],
        },
        requiredProperties: ['name'],
      };
      const zodSchema = dataSchemaToZod(schema);

      expect(() => zodSchema.parse({ name: 'John' })).not.toThrow();
      expect(() => zodSchema.parse({ name: 'John', age: 30 })).not.toThrow();
      expect(() => zodSchema.parse({ age: 30 })).toThrow();
      expect(() => zodSchema.parse({ name: 123 })).toThrow();
    });

    it('should handle object schema with no properties', () => {
      const schema: DataSchema = {
        type: 'object',
        properties: {},
      };
      const zodSchema = dataSchemaToZod(schema);

      expect(() => zodSchema.parse({ person: { name: 'John' } })).not.toThrow();
      expect(() => zodSchema.parse({ person: { name: 'John', age: 30 } })).not.toThrow();
      expect(() => zodSchema.parse({})).not.toThrow();
      expect(() => zodSchema.parse({ person: { age: 30 } })).not.toThrow();
    });

    it('should handle required object schema with no properties', () => {
      const schema: DataSchema = {
        type: 'object',
        properties: {},
        required: true,
      };
      const zodSchema = dataSchemaToZod(schema);

      expect(() => zodSchema.parse({ person: { name: 'John' } })).not.toThrow();
      expect(() => zodSchema.parse({ person: { name: 'John', age: 30 } })).not.toThrow();
      expect(() => zodSchema.parse({})).not.toThrow();
      expect(() => zodSchema.parse({ person: { age: 30 } })).not.toThrow();
      expect(() => zodSchema.parse(null)).toThrow();
      expect(() => zodSchema.parse(undefined)).not.toThrow();
      expect(zodSchema.safeParse(undefined).data).toEqual({});
      expect(() => zodSchema.parse('')).toThrow();
      expect(() => zodSchema.parse(0)).toThrow();
    });

    it('should handle nested object schema', () => {
      const schema: DataSchema = {
        type: 'object',
        required: true,
        properties: {
          person: [
            {
              type: 'object',
              properties: {
                name: [{ type: 'string', required: true }],
                age: [{ type: 'number' }],
              },
              requiredProperties: ['name'],
              required: true,
            },
          ],
        },
        requiredProperties: ['person'],
      };
      const zodSchema = dataSchemaToZod(schema);

      expect(() => zodSchema.parse({ person: { name: 'John' } })).not.toThrow();
      expect(() => zodSchema.parse({ person: { name: 'John', age: 30 } })).not.toThrow();
      expect(() => zodSchema.parse({})).toThrow();
      expect(() => zodSchema.parse({ person: { age: 30 } })).toThrow();
    });

    it('should handle object with array property', () => {
      const schema: DataSchema = {
        type: 'object',
        properties: {
          name: [{ type: 'string', required: true }],
          tags: [
            {
              type: 'array',
              items: [{ type: 'string' }],
              required: true,
            },
          ],
        },
        requiredProperties: ['name', 'tags'],
      };
      const zodSchema = dataSchemaToZod(schema);

      expect(() => zodSchema.parse({ name: 'John', tags: ['a', 'b', 'c'] })).not.toThrow();
      expect(() => zodSchema.parse({ name: 'John', tags: [] })).not.toThrow();
      expect(() => zodSchema.parse({ name: 'John' })).toThrow();
      expect(() => zodSchema.parse({})).toThrow();
      expect(() => zodSchema.parse({ name: 'John', tags: [1, 2, 3] })).toThrow();
    });

    it('should handle complex nested object with various types', () => {
      const schema: DataSchema = {
        type: 'object',
        properties: {
          id: [{ type: 'string', format: 'uuid', required: true }],
          name: [{ type: 'string', required: true }],
          age: [{ type: 'integer', minimum: 0 }],
          email: [{ type: 'string', format: 'email', required: true }],
          isActive: [{ type: 'boolean' }],
          role: [{ type: 'enum<string>', enum: ['admin', 'user', 'guest'] }],
          metadata: [
            {
              type: 'object',
              properties: {
                createdAt: [{ type: 'string', format: 'date-time' }],
                tags: [
                  {
                    type: 'array',
                    items: [{ type: 'string' }],
                  },
                ],
              },
            },
          ],
        },
        requiredProperties: ['id', 'name', 'email'],
      };
      const zodSchema = dataSchemaToZod(schema);

      const validObject = {
        id: '123e4567-e89b-12d3-a456-426614174000',
        name: 'John Doe',
        email: 'john@example.com',
        age: 30,
        isActive: true,
        role: 'admin',
        metadata: {
          createdAt: new Date().toISOString(),
          tags: ['important', 'verified'],
        },
      };

      expect(() => zodSchema.parse(validObject)).not.toThrow();

      const missingRequired = { ...validObject, name: undefined };
      delete missingRequired.name;
      expect(() => zodSchema.parse(missingRequired)).toThrow();

      const invalidEmail = { ...validObject, email: 'not-an-email' };
      expect(() => zodSchema.parse(invalidEmail)).toThrow();

      const invalidRole = { ...validObject, role: 'superadmin' };
      expect(() => zodSchema.parse(invalidRole)).toThrow();

      expect(() => zodSchema.parse({})).toThrow();
    });
  });

  it('should handle union of schemas in dataSchemaArrayToZod', () => {
    const stringSchema: DataSchema = { type: 'string' };
    const numberSchema: DataSchema = { type: 'number' };
    const schemaArray: DataSchemaArray = [stringSchema, numberSchema];

    const arraySchema: DataSchema = {
      type: 'array',
      items: schemaArray,
    };

    const zodSchema = dataSchemaToZod(arraySchema);

    expect(() => zodSchema.parse(['abc', 123, 'def', 456])).not.toThrow();
    expect(() => zodSchema.parse([true, false])).toThrow();
  });
});
