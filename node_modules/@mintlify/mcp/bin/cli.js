var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { colors, log } from '@mintlify/scraping';
import fs from 'fs';
import { exec } from 'node:child_process';
import os from 'os';
import path from 'path';
import prompts from 'prompts';
import { fileURLToPath } from 'url';
import yargs from 'yargs';
import { hideBin } from 'yargs/helpers';
import { getEndpointsFromOpenApi } from './mcp-template/src/openapi/helpers.js';
import { fetchSearchConfigurationAndOpenApi } from './mcp-template/src/search.js';
import { generatePackageJson, LOGGING_CONFIG, modifyAllMcpConfigs, possiblyFetchOpenApi, } from './utils.js';
export const cli = () => yargs(hideBin(process.argv))
    .command('add <subdomain>', 'Add a new subdomain', (yargs) => {
    return yargs
        .positional('subdomain', {
        describe: 'The subdomain to install the MCP server from',
        type: 'string',
        demandOption: true,
    })
        .option('client', {
        describe: 'Specify which configs to modify',
        type: 'string',
        choices: ['cursor', 'windsurf', 'claude'],
        array: true,
    });
}, (argv) => __awaiter(void 0, void 0, void 0, function* () {
    const { subdomain, client } = argv;
    const configsToModify = client && client.length ? client : undefined;
    try {
        const homeDir = os.homedir();
        const mcpBaseDir = path.join(homeDir, '.mcp');
        const mcpDir = path.join(mcpBaseDir, subdomain);
        if (!fs.existsSync(mcpBaseDir)) {
            fs.mkdirSync(mcpBaseDir, { recursive: true });
        }
        if (fs.existsSync(mcpDir)) {
            fs.rmSync(mcpDir, { recursive: true, force: true });
        }
        fs.mkdirSync(mcpDir, { recursive: true });
        const packageJson = generatePackageJson(subdomain);
        fs.writeFileSync(path.join(mcpDir, 'package.json'), JSON.stringify(packageJson, undefined, 2));
        const filename = fileURLToPath(import.meta.url);
        const cpPath = path.join(path.dirname(filename), 'mcp-template');
        fs.cpSync(cpPath, mcpDir, { recursive: true });
        const configFile = path.join(mcpDir, 'src', 'config.readonly.js');
        const configContent = fs.readFileSync(configFile, 'utf8');
        const updatedConfigContent = configContent.replace('mintlify', subdomain);
        fs.writeFileSync(configFile, updatedConfigContent);
        const config = yield fetchSearchConfigurationAndOpenApi(subdomain);
        const openapiFile = yield possiblyFetchOpenApi(config);
        if (openapiFile) {
            const openapiFilePath = path.join(mcpDir, 'src', 'openapi', 'openapi.json');
            fs.writeFileSync(openapiFilePath, JSON.stringify(openapiFile, null, 2));
            log('Loaded OpenAPI file', 'info');
            const endpoints = getEndpointsFromOpenApi(openapiFile);
            const envVars = {};
            endpoints.forEach((endpoint) => {
                const security = endpoint.request.security;
                security.forEach((securityOption) => {
                    Object.entries(securityOption.parameters).forEach(([paramLocation, value]) => {
                        if (Object.keys(value).length === 0) {
                            return;
                        }
                        Object.entries(value).forEach(([paramName, paramValue]) => {
                            if (paramValue.type === 'oauth2') {
                                return;
                            }
                            if (paramValue.type === 'apiKey') {
                                envVars[`${paramLocation}_${paramName}_APIKEY`] = `${paramName} (API key)`;
                            }
                            if (paramValue.type === 'http') {
                                envVars[`${paramLocation}_${paramName}_HTTP_${paramValue.scheme}`] =
                                    `${paramName} (${paramValue.scheme} token)`;
                            }
                        });
                    });
                });
            });
            const envVarsToPrompt = Object.entries(envVars).map(([key, value]) => ({
                type: 'password',
                name: key,
                message: `What is the ${config.name} ${value}?`,
            }));
            if (Object.keys(envVarsToPrompt).length) {
                console.log();
                const response = yield prompts(envVarsToPrompt);
                const envContent = Object.entries(response)
                    .map(([key, value]) => `${key}=${value}`)
                    .join('\n');
                const envPath = path.join(mcpDir, '.env');
                fs.writeFileSync(envPath, envContent);
                log(`Created ${colors.blue}.env${colors.default} file with authentication variables`, 'info', LOGGING_CONFIG);
            }
        }
        log(`Created new MCP server at ${colors.green}${mcpDir}${colors.default}`, 'success', LOGGING_CONFIG);
        const gitignorePath = path.join(mcpDir, '.gitignore');
        fs.writeFileSync(gitignorePath, 'node_modules/');
        const execPath = path.join(mcpDir, 'src', 'index.js');
        try {
            process.chdir(mcpDir);
            exec('npm install');
            exec('git init');
            yield modifyAllMcpConfigs(subdomain, execPath, configsToModify);
        }
        catch (err) {
            log(`Error running ${colors.red}npm install && git init${colors.default}, please navigate to ${colors.blue}${mcpDir}${colors.default} and run ${colors.blue}npm install${colors.default} and initialize the git repo (if you'd like to save your changes)`, 'error', LOGGING_CONFIG);
        }
        finally {
            log(`To start your MCP server, run the following command:\n${colors.green}node ${execPath}${colors.default}`, 'success', LOGGING_CONFIG);
        }
    }
    catch (err) {
        log(err instanceof Error ? err.message : err, 'error', LOGGING_CONFIG);
    }
}))
    .help().argv;
