var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { colors, log } from '@mintlify/scraping';
import axios from 'axios';
import fs from 'fs';
import os from 'os';
import path from 'path';
import prompts from 'prompts';
import { formatErr } from './mcp-template/src/utils.js';
const availableConfigMap = {
    cursor: 'Cursor',
    claude: 'Claude Desktop',
    windsurf: 'Windsurf',
};
export const LOGGING_CONFIG = {
    leadingNewLine: true,
    omitStatusMessage: true,
};
export function sleep(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
}
export function possiblyFetchOpenApi(config) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!config.openApiUrls || config.openApiUrls[0] == undefined) {
            return;
        }
        try {
            const { data } = yield axios.get(config.openApiUrls[0]);
            if (!data) {
                throw new Error('Empty response received');
            }
            return data;
        }
        catch (err) {
            throw new Error(`Error fetching OpenAPI file: ${formatErr(err)}`);
        }
    });
}
export function generatePackageJson(subdomain) {
    return {
        name: `${subdomain}-mcp`,
        version: '1.0.0',
        type: 'module',
        description: `MCP server generated for the ${subdomain} subdomain from Mintlify`,
        engines: {
            node: '>=18.0.0',
        },
        main: `src/index.js`,
        scripts: {
            start: 'node src/index.js',
        },
        author: 'Mintlify',
        dependencies: {
            '@mintlify/openapi-parser': '^0.0.7',
            '@mintlify/validation': '^0.1.320',
            '@modelcontextprotocol/sdk': '^1.6.1',
            axios: '^1.8.1',
            dashify: '^2.0.0',
            dotenv: '^16.4.7',
            'trieve-ts-sdk': '^0.0.62',
        },
    };
}
export function modifyMcpConfig(configDir, filename, subdomain, execPath) {
    return __awaiter(this, void 0, void 0, function* () {
        const configPath = path.join(configDir, filename);
        try {
            if (!fs.existsSync(configDir)) {
                return false;
            }
            const rawConfig = fs.existsSync(configPath) ? fs.readFileSync(configPath, 'utf8') : '{}';
            const config = JSON.parse(rawConfig);
            if (config.mcpServers === undefined) {
                config.mcpServers = {};
            }
            config.mcpServers[subdomain] = {
                command: 'node',
                args: [execPath],
            };
            fs.writeFileSync(configPath, JSON.stringify(config, undefined, 2), 'utf8');
            return true;
        }
        catch (err) {
            log(`Error parsing config at ${colors.red}${configPath}${colors.default}: ${err instanceof Error ? err.message : JSON.stringify(err, undefined, 2)}`, 'error', LOGGING_CONFIG);
            return false;
        }
    });
}
function updateConfig(config, subdomain, execPath) {
    return __awaiter(this, void 0, void 0, function* () {
        yield sleep(500);
        const configPath = path.join(config.dir, config.filename).replace(os.homedir(), '~');
        const updated = yield modifyMcpConfig(config.dir, config.filename, subdomain, execPath);
        if (updated) {
            log(`Updated ${config.name} config at ${colors.green}${configPath}`, 'success', LOGGING_CONFIG);
            log(config.docs, 'info', { omitStatusMessage: true });
            return 1;
        }
        return 0;
    });
}
export function modifyAllMcpConfigs(subdomain, execPath, configsToModify) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const configPaths = [
                {
                    dir: path.join(os.homedir(), '.cursor'),
                    filename: 'mcp.json',
                    name: 'Cursor',
                    docs: 'Cursor docs for MCP servers: https://docs.cursor.com/context/model-context-protocol',
                },
                {
                    dir: path.join(os.homedir(), '.codeium', 'windsurf'),
                    filename: 'mcp_config.json',
                    name: 'Windsurf',
                    docs: 'Cursor docs for MCP servers: https://docs.codeium.com/windsurf/mcp',
                },
                {
                    dir: getClaudeConfigPath(),
                    filename: 'claude_desktop_config.json',
                    name: 'Claude Desktop',
                    docs: 'MCP docs for Claude Desktop: https://modelcontextprotocol.io/quickstart/user',
                },
            ];
            const existingConfigs = configPaths.filter((config) => fs.existsSync(config.dir));
            if (configsToModify) {
                configsToModify = configsToModify.filter((config) => {
                    const configName = availableConfigMap[config];
                    if (!existingConfigs.find((existingConfig) => existingConfig.name === configName)) {
                        log(`Failed to modify config for ${configName}. ${configName} has not been installed`, 'error', LOGGING_CONFIG);
                        return false;
                    }
                    return true;
                });
            }
            if (existingConfigs.length === 0 || (configsToModify && configsToModify.length === 0)) {
                log('No supported MCP configs found on this system', 'info');
                return;
            }
            const choices = existingConfigs.map((config) => ({
                title: `${config.name}`,
                value: config,
                selected: true,
            }));
            let response;
            if (configsToModify) {
                response = {
                    selectedConfigs: configPaths.filter((config) => configsToModify === null || configsToModify === void 0 ? void 0 : configsToModify.find((configToModify) => availableConfigMap[configToModify] === config.name)),
                };
            }
            else if (choices.length > 1) {
                console.log();
                response = yield prompts({
                    type: 'multiselect',
                    name: 'selectedConfigs',
                    message: ' Add new MCP server to configs:',
                    choices,
                    hint: 'Space to select (all selected by default). Return to submit.',
                    instructions: false,
                });
            }
            else if (choices[0]) {
                console.log();
                response = yield prompts({
                    type: 'confirm',
                    name: 'selectedConfigs',
                    message: ` Add MCP server to ${choices[0].title} config?`,
                    initial: true,
                });
            }
            if (!response ||
                !response.selectedConfigs ||
                (Array.isArray(response.selectedConfigs) && response.selectedConfigs.length === 0) ||
                !choices[0]) {
                log('No configs selected for update', 'warn', LOGGING_CONFIG);
                return;
            }
            let numUpdates = 0;
            if (Array.isArray(response.selectedConfigs)) {
                for (const config of response.selectedConfigs) {
                    numUpdates += yield updateConfig(config, subdomain, execPath);
                }
            }
            else {
                const config = choices[0].value;
                numUpdates += yield updateConfig(config, subdomain, execPath);
            }
            yield sleep(500);
            if (numUpdates > 0) {
                log(`Added the following MCP to ${numUpdates} config${numUpdates > 1 ? 's' : ''}:\n${colors.grey}${JSON.stringify({
                    mcpServers: {
                        [subdomain]: {
                            command: 'node',
                            args: [execPath],
                        },
                    },
                }, undefined, 2)
                    .split('\n')
                    .map((line, index) => (index > 1 && index < 8 ? `${colors.green}+ ${line}` : `  ${line}`))
                    .join('\n')
                    .replace('\n    }', `\n${colors.grey}    }`)}`, 'info', LOGGING_CONFIG);
            }
        }
        catch (err) {
            log(`Error modifying config files with MCP servers:\n${err instanceof Error ? err.message : JSON.stringify(err, undefined, 2)}`, 'error', LOGGING_CONFIG);
        }
    });
}
export function getClaudeConfigPath() {
    const homeDir = os.homedir();
    const platform = process.platform;
    switch (platform) {
        case 'darwin':
            return path.join(homeDir, 'Library', 'Application Support', 'Claude');
        case 'win32':
            const appData = process.env.APPDATA;
            if (!appData) {
                throw new Error('APPDATA environment variable is not defined.');
            }
            return path.join(appData, 'Claude', 'claude_desktop_config.json');
        case 'linux':
            return path.join(homeDir, '.config', 'Claude');
        default:
            throw new Error(`Unsupported platform: ${platform}`);
    }
}
