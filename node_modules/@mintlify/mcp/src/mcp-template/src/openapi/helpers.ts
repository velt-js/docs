import { OpenAPI } from '@mintlify/openapi-types';
import {
  HttpMethod,
  OpenApiToEndpointConverter,
  SecurityParameterGroup,
  SecurityParameterSections,
} from '@mintlify/validation';
import { Endpoint } from '@mintlify/validation';
import { ParameterSections } from '@mintlify/validation';
import { IncrementalDataSchemaArray } from '@mintlify/validation';
import { ParameterGroup } from '@mintlify/validation';
import { DataSchemaArray } from '@mintlify/validation';
import dotenv from 'dotenv';
import fs from 'node:fs';
import path from 'node:path';
import { fileURLToPath } from 'node:url';
import { OpenAPIV3_1 } from 'openapi-types';
import { z } from 'zod';

import { dataSchemaArrayToZod, dataSchemaToZod } from './zod.js';

type ServerParams = Record<string, z.ZodSchema>;

export function convertStrToTitle(str: string): string {
  const spacedString = str.replace(/[-_]/g, ' ');
  const words = spacedString.split(/(?=[A-Z])|\s+/);
  const titleCasedWords = words.map((word) => {
    return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
  });
  return titleCasedWords.join(' ');
}

export function findNextIteration(set: Set<string>, str: string): number {
  let count = 1;
  set.forEach((val) => {
    if (val.startsWith(`${str}---`)) {
      count = Number(val.replace(`${str}---`, ''));
    }
  });
  return count + 1;
}

export function getEndpointsFromOpenApi(specification: OpenAPI.Document) {
  const endpoints = [];
  const paths = specification.paths;

  for (const path in paths) {
    const operations = paths[path];
    for (const method in operations) {
      if (method === 'parameters' || method === 'trace') {
        continue;
      }
      const endpoint = OpenApiToEndpointConverter.convert(
        specification as OpenAPIV3_1.Document,
        path,
        method as HttpMethod,
        true
      );
      endpoints.push(endpoint);
    }
  }

  return endpoints;
}

export function loadEnv(): Record<string, string> {
  try {
    const envPath = path.join(fileURLToPath(import.meta.url), '../../..', '.env');
    if (fs.existsSync(envPath)) {
      const vars = dotenv.parse(fs.readFileSync(envPath));
      return vars;
    }
  } catch (error) {
    // if there's no env, the user will be prompted
    // for their auth info at runtime if necessary
    // (shouldn't happen either way)
  }
  return {};
}

function convertParameterSection(
  parameters: ParameterGroup<DataSchemaArray | IncrementalDataSchemaArray>,
  paramSection: ServerParams
): void {
  Object.entries(parameters).forEach(([key, value]) => {
    const schema = value.schema;
    paramSection[key] = dataSchemaArrayToZod(schema);
  });
}

function convertParametersAndAddToRelevantParamGroups(
  parameters: ParameterSections,
  paths: ServerParams,
  queries: ServerParams,
  headers: ServerParams,
  cookies: ServerParams
): void {
  convertParameterSection(parameters.path, paths);
  convertParameterSection(parameters.query, queries);
  convertParameterSection(parameters.header, headers);
  convertParameterSection(parameters.cookie, cookies);
}

function convertSecurityParameterSection(
  securityParameters: SecurityParameterGroup,
  securityParamSection: ServerParams,
  envVariables: Record<string, string>,
  location: string
): void {
  Object.entries(securityParameters).forEach(([key, value]) => {
    if (value.type === 'oauth2') {
      return;
    }

    let envKey: string;
    if (value.type === 'apiKey') {
      envKey = `${location}_${key}_APIKEY`;
    } else {
      envKey = `${location}_${key}_HTTP_${value.scheme}`;
    }

    if (envKey && !(envKey in envVariables)) {
      securityParamSection[key] = z.string();
    }
  });
}

function convertSecurityParametersAndAddToRelevantParamGroups(
  securityParameters: SecurityParameterSections,
  queries: ServerParams,
  headers: ServerParams,
  cookies: ServerParams,
  envVariables: Record<string, string>
): void {
  convertSecurityParameterSection(securityParameters.query, queries, envVariables, 'query');
  convertSecurityParameterSection(securityParameters.header, headers, envVariables, 'header');
  convertSecurityParameterSection(securityParameters.cookie, cookies, envVariables, 'cookie');
}

export function convertEndpointToCategorizedZod(endpoint: Endpoint): {
  url: string;
  method: HttpMethod;
  paths: ServerParams;
  queries: ServerParams;
  body: ServerParams | undefined;
  headers: ServerParams;
  cookies: ServerParams;
} {
  const envVariables = loadEnv();
  const url = `${endpoint.servers?.[0]?.url || ''}${endpoint.path}`;
  const method = endpoint.method;
  const paths: ServerParams = {};
  const queries: ServerParams = {};
  const headers: ServerParams = {};
  const cookies: ServerParams = {};
  let body: ServerParams | undefined = undefined;

  convertParametersAndAddToRelevantParamGroups(
    endpoint.request.parameters,
    paths,
    queries,
    headers,
    cookies
  );

  if (endpoint.request.security[0]?.parameters) {
    convertSecurityParametersAndAddToRelevantParamGroups(
      endpoint.request.security[0].parameters,
      queries,
      headers,
      cookies,
      envVariables
    );
  }

  const jsonBodySchema = endpoint.request.body['application/json'];
  const bodySchemaArray = jsonBodySchema?.schemaArray;
  const bodySchema = bodySchemaArray?.[0];

  if (bodySchema) {
    const zodBodySchema = dataSchemaToZod(bodySchema);
    body = { body: zodBodySchema };
  }

  return { url, method, paths, queries, body, headers, cookies };
}
