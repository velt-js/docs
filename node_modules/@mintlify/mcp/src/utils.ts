import { colors, log } from '@mintlify/scraping';
import axios from 'axios';
import fs from 'fs';
import os from 'os';
import path from 'path';
import prompts from 'prompts';

import { InitializationConfiguration } from './mcp-template/src/types.js';
import { formatErr } from './mcp-template/src/utils.js';

type AvailableConfig = 'cursor' | 'claude' | 'windsurf';
const availableConfigMap = {
  cursor: 'Cursor',
  claude: 'Claude Desktop',
  windsurf: 'Windsurf',
} as const;

export const LOGGING_CONFIG = {
  leadingNewLine: true,
  omitStatusMessage: true,
} as const;

export function sleep(ms: number) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

export async function possiblyFetchOpenApi(config: InitializationConfiguration) {
  if (!config.openApiUrls || config.openApiUrls[0] == undefined) {
    return;
  }

  try {
    const { data } = await axios.get(config.openApiUrls[0]);
    if (!data) {
      throw new Error('Empty response received');
    }
    return data;
  } catch (err) {
    throw new Error(`Error fetching OpenAPI file: ${formatErr(err)}`);
  }
}

export function generatePackageJson(
  subdomain: string
): Record<string, string | Record<string, string>> {
  return {
    name: `${subdomain}-mcp`,
    version: '1.0.0',
    type: 'module',
    description: `MCP server generated for the ${subdomain} subdomain from Mintlify`,
    engines: {
      node: '>=18.0.0',
    },
    main: `src/index.js`,
    scripts: {
      start: 'node src/index.js',
    },
    author: 'Mintlify',
    dependencies: {
      '@mintlify/openapi-parser': '^0.0.7',
      '@mintlify/validation': '^0.1.320',
      '@modelcontextprotocol/sdk': '^1.6.1',
      axios: '^1.8.1',
      dashify: '^2.0.0',
      dotenv: '^16.4.7',
      'trieve-ts-sdk': '^0.0.62',
    },
  };
}

export async function modifyMcpConfig(
  configDir: string,
  filename: string,
  subdomain: string,
  execPath: string
): Promise<boolean> {
  const configPath = path.join(configDir, filename);
  try {
    if (!fs.existsSync(configDir)) {
      return false;
    }

    const rawConfig = fs.existsSync(configPath) ? fs.readFileSync(configPath, 'utf8') : '{}';
    const config = JSON.parse(rawConfig);
    if (config.mcpServers === undefined) {
      config.mcpServers = {};
    }

    config.mcpServers[subdomain] = {
      command: 'node',
      args: [execPath],
    };

    fs.writeFileSync(configPath, JSON.stringify(config, undefined, 2), 'utf8');
    return true;
  } catch (err) {
    log(
      `Error parsing config at ${colors.red}${configPath}${colors.default}: ${
        err instanceof Error ? err.message : JSON.stringify(err, undefined, 2)
      }`,
      'error',
      LOGGING_CONFIG
    );
    return false;
  }
}

async function updateConfig(
  config: {
    dir: string;
    filename: string;
    name: string;
    docs: string;
  },
  subdomain: string,
  execPath: string
): Promise<number> {
  await sleep(500);
  const configPath = path.join(config.dir, config.filename).replace(os.homedir(), '~');
  const updated = await modifyMcpConfig(config.dir, config.filename, subdomain, execPath);
  if (updated) {
    log(`Updated ${config.name} config at ${colors.green}${configPath}`, 'success', LOGGING_CONFIG);
    log(config.docs, 'info', { omitStatusMessage: true });
    return 1;
  }
  return 0;
}

export async function modifyAllMcpConfigs(
  subdomain: string,
  execPath: string,
  configsToModify?: AvailableConfig[]
) {
  try {
    const configPaths = [
      {
        dir: path.join(os.homedir(), '.cursor'),
        filename: 'mcp.json',
        name: 'Cursor',
        docs: 'Cursor docs for MCP servers: https://docs.cursor.com/context/model-context-protocol',
      },
      {
        dir: path.join(os.homedir(), '.codeium', 'windsurf'),
        filename: 'mcp_config.json',
        name: 'Windsurf',
        docs: 'Cursor docs for MCP servers: https://docs.codeium.com/windsurf/mcp',
      },
      {
        dir: getClaudeConfigPath(),
        filename: 'claude_desktop_config.json',
        name: 'Claude Desktop',
        docs: 'MCP docs for Claude Desktop: https://modelcontextprotocol.io/quickstart/user',
      },
    ];

    const existingConfigs = configPaths.filter((config) => fs.existsSync(config.dir));

    if (configsToModify) {
      configsToModify = configsToModify.filter((config) => {
        const configName = availableConfigMap[config];
        if (!existingConfigs.find((existingConfig) => existingConfig.name === configName)) {
          log(
            `Failed to modify config for ${configName}. ${configName} has not been installed`,
            'error',
            LOGGING_CONFIG
          );
          return false;
        }
        return true;
      });
    }

    if (existingConfigs.length === 0 || (configsToModify && configsToModify.length === 0)) {
      log('No supported MCP configs found on this system', 'info');
      return;
    }

    const choices = existingConfigs.map((config) => ({
      title: `${config.name}`,
      value: config,
      selected: true,
    }));

    let response;
    if (configsToModify) {
      response = {
        selectedConfigs: configPaths.filter(
          (config) =>
            configsToModify?.find(
              (configToModify) => availableConfigMap[configToModify] === config.name
            )
        ),
      };
    } else if (choices.length > 1) {
      console.log();
      response = await prompts({
        type: 'multiselect',
        name: 'selectedConfigs',
        message: ' Add new MCP server to configs:',
        choices,
        hint: 'Space to select (all selected by default). Return to submit.',
        instructions: false,
      });
    } else if (choices[0]) {
      console.log();
      response = await prompts({
        type: 'confirm',
        name: 'selectedConfigs',
        message: ` Add MCP server to ${choices[0].title} config?`,
        initial: true,
      });
    }

    if (
      !response ||
      !response.selectedConfigs ||
      (Array.isArray(response.selectedConfigs) && response.selectedConfigs.length === 0) ||
      !choices[0]
    ) {
      log('No configs selected for update', 'warn', LOGGING_CONFIG);
      return;
    }

    let numUpdates = 0;
    if (Array.isArray(response.selectedConfigs)) {
      for (const config of response.selectedConfigs) {
        numUpdates += await updateConfig(config, subdomain, execPath);
      }
    } else {
      const config = choices[0].value;
      numUpdates += await updateConfig(config, subdomain, execPath);
    }

    await sleep(500);
    if (numUpdates > 0) {
      log(
        `Added the following MCP to ${numUpdates} config${numUpdates > 1 ? 's' : ''}:\n${
          colors.grey
        }${JSON.stringify(
          {
            mcpServers: {
              [subdomain]: {
                command: 'node',
                args: [execPath],
              },
            },
          },
          undefined,
          2
        )
          .split('\n')
          .map((line, index) => (index > 1 && index < 8 ? `${colors.green}+ ${line}` : `  ${line}`))
          .join('\n')
          .replace('\n    }', `\n${colors.grey}    }`)}`,
        'info',
        LOGGING_CONFIG
      );
    }
  } catch (err) {
    log(
      `Error modifying config files with MCP servers:\n${
        err instanceof Error ? err.message : JSON.stringify(err, undefined, 2)
      }`,
      'error',
      LOGGING_CONFIG
    );
  }
}

export function getClaudeConfigPath(): string {
  const homeDir = os.homedir();
  const platform = process.platform;

  switch (platform) {
    case 'darwin':
      return path.join(homeDir, 'Library', 'Application Support', 'Claude');
    case 'win32':
      const appData = process.env.APPDATA;
      if (!appData) {
        throw new Error('APPDATA environment variable is not defined.');
      }
      return path.join(appData, 'Claude', 'claude_desktop_config.json');
    case 'linux':
      return path.join(homeDir, '.config', 'Claude');
    default:
      throw new Error(`Unsupported platform: ${platform}`);
  }
}
