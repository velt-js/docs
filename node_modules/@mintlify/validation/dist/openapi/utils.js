export const stringFileFormats = ['binary', 'base64'];
export const structuredDataContentTypes = [
    'multipart/form-data',
    'application/json',
    'application/x-www-form-urlencoded',
];
// the number of times a $ref can point to another $ref before we give up
const MAX_DEREFERENCE_DEPTH = 5;
export function dereference(section, $ref, components, maxDepth = MAX_DEREFERENCE_DEPTH) {
    const sectionPrefix = `#/components/${section}/`;
    if (!$ref.startsWith(sectionPrefix))
        return undefined;
    const key = $ref.slice(sectionPrefix.length);
    const value = components === null || components === void 0 ? void 0 : components[key];
    // if a $ref points to another $ref, keep resolving until we hit our max depth
    if (value && '$ref' in value) {
        if (maxDepth > 0 && typeof value.$ref === 'string') {
            return dereference(section, value.$ref, components, maxDepth - 1);
        }
        return undefined;
    }
    return value;
}
export const addKeyIfDefined = (key, value, destination) => {
    if (value !== undefined) {
        destination[key] = value;
    }
};
export const copyKeyIfDefined = (key, source, destination) => {
    // eslint does not recognize that D[K] could be undefined
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    if (source[key] !== undefined) {
        destination[key] = source[key];
    }
};
export const copyExampleIfDefined = (source, destination) => {
    var _a;
    const example = ((_a = source.examples) === null || _a === void 0 ? void 0 : _a[0]) !== undefined ? source.examples[0] : source.example;
    if (example !== undefined) {
        destination.example = example;
    }
};
export function recursivelyFindDescription(schema, name) {
    var _a;
    if (typeof schema !== 'object' || name === undefined) {
        return undefined;
    }
    if (schema.discriminator && schema.discriminator.mapping) {
        const mapping = schema.discriminator.mapping;
        if (name in mapping && ((_a = mapping[name]) === null || _a === void 0 ? void 0 : _a.description)) {
            return mapping[name].description;
        }
    }
    if (Array.isArray(schema)) {
        for (const subschema of schema) {
            const description = recursivelyFindDescription(subschema, name);
            if (description)
                return description;
        }
        return undefined;
    }
    if ('type' in schema &&
        schema.type === name &&
        'description' in schema &&
        typeof schema.description === 'string') {
        return schema.description;
    }
    for (const [key, value] of Object.entries(schema)) {
        if (key === name &&
            typeof value === 'object' &&
            value !== null &&
            'description' in value &&
            typeof value.description === 'string') {
            return value.description;
        }
        const description = recursivelyFindDescription(value, name);
        if (description)
            return description;
    }
    return undefined;
}
