var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// src/fetch-client.ts
function camelcaseToSnakeCase(str) {
  return str.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`);
}
function replacePathParams(path, params) {
  for (const [key, value] of Object.entries(params)) {
    path = path.replaceAll(`{${camelcaseToSnakeCase(key)}}`, value);
  }
  return path;
}
function isObject(value) {
  return typeof value === "object" && value !== null;
}
var TrieveFetchClient = class {
  apiKey;
  baseUrl;
  debug = false;
  organizationId;
  omitCredentials;
  constructor(opts) {
    this.apiKey = opts.apiKey;
    this.baseUrl = opts.baseUrl;
    this.debug = opts.debug || false;
    this.organizationId = opts.organizationId;
    this.omitCredentials = opts.omitCredentials;
  }
  async fetch(path, method, params, signal, parseHeaders) {
    let requestBody;
    const headers = {
      "Content-Type": "application/json"
    };
    if (this.apiKey) {
      headers["Authorization"] = `Bearer ${this.apiKey}`;
    }
    const pathParams = {};
    if (isObject(params)) {
      if ("data" in params && isObject(params.data)) {
        requestBody = params.data;
      }
      for (const [key, value] of Object.entries(params)) {
        if (key === "datasetId" && typeof value === "string") {
          headers["TR-Dataset"] = value;
        } else if (key === "organizationId" && typeof value === "string") {
          headers["TR-Organization"] = value;
        } else if (key === "xApiVersion" && typeof value === "string") {
          headers["X-API-VERSION"] = value;
        }
        const snakedKey = camelcaseToSnakeCase(key);
        if (path.includes(`{${snakedKey}}`) && (typeof value === "string" || typeof value === "number")) {
          pathParams[key] = value.toLocaleString();
        }
      }
      if (!headers["TR-Organization"] && this.organizationId) {
        headers["TR-Organization"] = this.organizationId;
      }
    }
    const updatedPath = replacePathParams(path, pathParams);
    if (this.debug) {
      console.info("Sending request: ", {
        url: this.baseUrl + updatedPath,
        method,
        headers,
        body: requestBody
      });
    }
    const response = await fetch(this.baseUrl + updatedPath, {
      credentials: this.omitCredentials ? "omit" : "include",
      method,
      headers,
      body: requestBody ? JSON.stringify(requestBody) : void 0,
      signal
    });
    if (!response.ok) {
      throw new Error(
        `HTTP error! status: ${await response.text()} 
Payload ${JSON.stringify(
          requestBody
        )} 
route: ${method} ${this.baseUrl + updatedPath}`
      );
    }
    let responseObject;
    try {
      if (parseHeaders) {
        parseHeaders(Object.fromEntries(response.headers.entries()));
      }
      responseObject = await response.clone().json();
    } catch {
      if (parseHeaders) {
        parseHeaders(Object.fromEntries(response.headers.entries()));
      }
      responseObject = await response.clone().text();
    }
    if (this.debug) {
      console.info("Response: ", responseObject);
    }
    return responseObject;
  }
};

// src/functions/chunks/index.ts
var chunks_exports = {};
__export(chunks_exports, {
  autocomplete: () => autocomplete,
  countChunksAboveThreshold: () => countChunksAboveThreshold,
  createChunk: () => createChunk,
  deleteChunkById: () => deleteChunkById,
  deleteChunkByTrackingId: () => deleteChunkByTrackingId,
  getChunkById: () => getChunkById,
  getChunkByTrackingId: () => getChunkByTrackingId,
  getChunksByIds: () => getChunksByIds,
  getChunksByTrackingIds: () => getChunksByTrackingIds,
  getRecommendedChunks: () => getRecommendedChunks,
  ragOnChunk: () => ragOnChunk,
  ragOnChunkReader: () => ragOnChunkReader,
  ragOnChunkReaderWithQueryId: () => ragOnChunkReaderWithQueryId,
  scroll: () => scroll,
  search: () => search,
  splitChunkHtml: () => splitChunkHtml,
  suggestedQueries: () => suggestedQueries,
  updateChunk: () => updateChunk,
  updateChunkByTrackingId: () => updateChunkByTrackingId
});

// src/functions/message/index.ts
var message_exports = {};
__export(message_exports, {
  createMessage: () => createMessage,
  createMessageReader: () => createMessageReader,
  createMessageReaderWithQueryId: () => createMessageReaderWithQueryId,
  editMessage: () => editMessage,
  editMessageReader: () => editMessageReader,
  editMessageReaderWithQueryId: () => editMessageReaderWithQueryId,
  getAllMessagesForTopic: () => getAllMessagesForTopic,
  getCleanFetch: () => getCleanFetch,
  getMessageById: () => getMessageById,
  getToolCallFunctionParams: () => getToolCallFunctionParams,
  regenerateMessage: () => regenerateMessage,
  regenerateMessageReader: () => regenerateMessageReader,
  regenerateMessageReaderWithQueryId: () => regenerateMessageReaderWithQueryId
});
async function createMessage(data, signal, parseHeaders) {
  if (!this.datasetId) {
    throw new Error("datasetId is required");
  }
  return await this.trieve.fetch(
    "/api/message",
    "post",
    {
      data,
      datasetId: this.datasetId
    },
    signal,
    parseHeaders
  );
}
var getCleanFetch = () => {
  const iframe = document.createElement("iframe");
  iframe.style.display = "none";
  document.body.appendChild(iframe);
  const cleanFetch = iframe.contentWindow?.fetch.bind(window);
  document.body.removeChild(iframe);
  return cleanFetch;
};
async function createMessageReader(data, signal, parseHeaders) {
  if (!this.datasetId) {
    throw new Error("datasetId is required");
  }
  const cleanFetch = getCleanFetch();
  const fetchToUse = cleanFetch ?? fetch;
  const response = await fetchToUse(this.trieve.baseUrl + "/api/message", {
    method: "post",
    headers: {
      "Content-Type": "application/json",
      "TR-Dataset": this.datasetId,
      Authorization: `Bearer ${this.trieve.apiKey}`
    },
    body: JSON.stringify(data),
    signal
  });
  if (parseHeaders) {
    parseHeaders(Object.fromEntries(response.headers.entries()));
  }
  const reader = response.body?.getReader();
  if (!reader) {
    throw new Error("Failed to get reader from response body");
  }
  return reader;
}
async function createMessageReaderWithQueryId(data, signal, parseHeaders) {
  if (!this.datasetId) {
    throw new Error("datasetId is required");
  }
  const cleanFetch = getCleanFetch();
  const fetchToUse = cleanFetch ?? fetch;
  const response = await fetchToUse(this.trieve.baseUrl + "/api/message", {
    method: "post",
    headers: {
      "Content-Type": "application/json",
      "TR-Dataset": this.datasetId,
      Authorization: `Bearer ${this.trieve.apiKey}`
    },
    body: JSON.stringify(data),
    signal
  });
  if (parseHeaders) {
    parseHeaders(Object.fromEntries(response.headers.entries()));
  }
  const reader = response.body?.getReader();
  if (!reader) {
    throw new Error("Failed to get reader from response body");
  }
  const queryId = response.headers.get("TR-QueryID");
  return {
    reader,
    queryId
  };
}
async function editMessage(data, signal) {
  if (!this.datasetId) {
    throw new Error("datasetId is required");
  }
  return await this.trieve.fetch(
    "/api/message",
    "put",
    {
      data,
      datasetId: this.datasetId
    },
    signal
  );
}
async function editMessageReader(data, signal) {
  if (!this.datasetId) {
    throw new Error("datasetId is required");
  }
  const response = await fetch(this.trieve.baseUrl + "/api/message", {
    method: "put",
    headers: {
      "Content-Type": "application/json",
      "TR-Dataset": this.datasetId,
      Authorization: `Bearer ${this.trieve.apiKey}`
    },
    body: JSON.stringify(data),
    signal
  });
  const reader = response.body?.getReader();
  if (!reader) {
    throw new Error("Failed to get reader from response body");
  }
  return reader;
}
async function editMessageReaderWithQueryId(data, signal) {
  if (!this.datasetId) {
    throw new Error("datasetId is required");
  }
  const response = await fetch(this.trieve.baseUrl + "/api/message", {
    method: "put",
    headers: {
      "Content-Type": "application/json",
      "TR-Dataset": this.datasetId,
      Authorization: `Bearer ${this.trieve.apiKey}`
    },
    body: JSON.stringify(data),
    signal
  });
  const reader = response.body?.getReader();
  if (!reader) {
    throw new Error("Failed to get reader from response body");
  }
  const queryId = response.headers.get("TR-QueryID");
  return {
    reader,
    queryId
  };
}
async function regenerateMessage(data, signal) {
  if (!this.datasetId) {
    throw new Error("datasetId is required");
  }
  return await this.trieve.fetch(
    "/api/message",
    "delete",
    {
      data,
      datasetId: this.datasetId
    },
    signal
  );
}
async function regenerateMessageReader(data, signal) {
  if (!this.datasetId) {
    throw new Error("datasetId is required");
  }
  const response = await fetch(this.trieve.baseUrl + "/api/message", {
    method: "delete",
    headers: {
      "Content-Type": "application/json",
      "TR-Dataset": this.datasetId,
      Authorization: `Bearer ${this.trieve.apiKey}`
    },
    body: JSON.stringify(data),
    signal
  });
  const reader = response.body?.getReader();
  if (!reader) {
    throw new Error("Failed to get reader from response body");
  }
  return reader;
}
async function regenerateMessageReaderWithQueryId(data, signal) {
  if (!this.datasetId) {
    throw new Error("datasetId is required");
  }
  const response = await fetch(this.trieve.baseUrl + "/api/message", {
    method: "delete",
    headers: {
      "Content-Type": "application/json",
      "TR-Dataset": this.datasetId,
      Authorization: `Bearer ${this.trieve.apiKey}`
    },
    body: JSON.stringify(data),
    signal
  });
  const reader = response.body?.getReader();
  if (!reader) {
    throw new Error("Failed to get reader from response body");
  }
  const queryId = response.headers.get("TR-QueryID");
  return {
    reader,
    queryId
  };
}
async function getAllMessagesForTopic(data, signal) {
  if (!this.datasetId) {
    throw new Error("datasetId is required");
  }
  return await this.trieve.fetch(
    "/api/messages/{messages_topic_id}",
    "get",
    {
      ...data,
      datasetId: this.datasetId
    },
    signal
  );
}
async function getMessageById(data, signal) {
  if (!this.datasetId) {
    throw new Error("datasetId is required");
  }
  return await this.trieve.fetch(
    "/api/message/{message_id}",
    "get",
    {
      ...data,
      datasetId: this.datasetId
    },
    signal
  );
}
async function getToolCallFunctionParams(data, signal, parseHeaders) {
  if (!this.datasetId) {
    throw new Error("datasetId is required");
  }
  return await this.trieve.fetch(
    "/api/message/get_tool_function_params",
    "post",
    {
      data,
      datasetId: this.datasetId
    },
    signal,
    parseHeaders
  );
}

// src/functions/chunks/index.ts
async function search(props, signal, parseHeaders) {
  if (!this.datasetId) {
    throw new Error("datasetId is required");
  }
  return this.trieve.fetch(
    "/api/chunk/search",
    "post",
    {
      xApiVersion: "V2",
      data: props,
      datasetId: this.datasetId
    },
    signal,
    parseHeaders
  );
}
async function createChunk(props, signal) {
  if (!this.datasetId) {
    throw new Error("datasetId is required");
  }
  return this.trieve.fetch(
    "/api/chunk",
    "post",
    {
      data: props,
      datasetId: this.datasetId
    },
    signal
  );
}
async function autocomplete(props, signal, parseHeaders) {
  if (!this.datasetId) {
    throw new Error("datasetId is required");
  }
  return this.trieve.fetch(
    "/api/chunk/autocomplete",
    "post",
    {
      data: props,
      datasetId: this.datasetId,
      xApiVersion: "V2"
    },
    signal,
    parseHeaders
  );
}
async function getRecommendedChunks(props, signal) {
  if (!this.datasetId) {
    throw new Error("datasetId is required");
  }
  return this.trieve.fetch(
    "/api/chunk/recommend",
    "post",
    {
      data: props,
      datasetId: this.datasetId
    },
    signal
  );
}
async function ragOnChunk(props, signal) {
  if (!this.datasetId) {
    throw new Error("datasetId is required");
  }
  return this.trieve.fetch(
    "/api/chunk/generate",
    "post",
    {
      data: props,
      datasetId: this.datasetId
    },
    signal
  );
}
async function ragOnChunkReader(props, signal) {
  if (!this.datasetId) {
    throw new Error("datasetId is required");
  }
  const response = await fetch(this.trieve.baseUrl + "/api/chunk/generate", {
    method: "post",
    headers: {
      "Content-Type": "application/json",
      "TR-Dataset": this.datasetId,
      Authorization: `Bearer ${this.trieve.apiKey}`
    },
    body: JSON.stringify(props),
    signal
  });
  const reader = response.body?.getReader();
  if (!reader) {
    throw new Error("Failed to get reader from response body");
  }
  return reader;
}
async function ragOnChunkReaderWithQueryId(props, signal, parseHeaders) {
  if (!this.datasetId) {
    throw new Error("datasetId is required");
  }
  const cleanFetch = getCleanFetch();
  const fetchToUse = cleanFetch ?? fetch;
  const response = await fetchToUse(
    this.trieve.baseUrl + "/api/chunk/generate",
    {
      method: "post",
      headers: {
        "Content-Type": "application/json",
        "TR-Dataset": this.datasetId,
        Authorization: `Bearer ${this.trieve.apiKey}`
      },
      body: JSON.stringify(props),
      signal
    }
  );
  if (parseHeaders) {
    parseHeaders(Object.fromEntries(response.headers.entries()));
  }
  const reader = response.body?.getReader();
  if (!reader) {
    throw new Error("Failed to get reader from response body");
  }
  const queryId = response.headers.get("TR-QueryID");
  return {
    reader,
    queryId
  };
}
async function suggestedQueries(props, signal) {
  if (!this.datasetId) {
    throw new Error("datasetId is required");
  }
  return this.trieve.fetch(
    "/api/chunk/suggestions",
    "post",
    {
      data: props,
      datasetId: this.datasetId
    },
    signal
  );
}
async function countChunksAboveThreshold(props, signal) {
  if (!this.datasetId) {
    throw new Error("datasetId is required");
  }
  return this.trieve.fetch(
    "/api/chunk/count",
    "post",
    {
      data: props,
      datasetId: this.datasetId
    },
    signal
  );
}
async function scroll(props, signal) {
  if (!this.datasetId) {
    throw new Error("datasetId is required");
  }
  return this.trieve.fetch(
    "/api/chunks/scroll",
    "post",
    {
      data: props,
      datasetId: this.datasetId
    },
    signal
  );
}
async function updateChunk(props, signal) {
  if (!this.datasetId) {
    throw new Error("datasetId is required");
  }
  return this.trieve.fetch(
    "/api/chunk",
    "put",
    {
      data: props,
      datasetId: this.datasetId
    },
    signal
  );
}
async function updateChunkByTrackingId(props, signal) {
  if (!this.datasetId) {
    throw new Error("datasetId is required");
  }
  return this.trieve.fetch(
    "/api/chunk/tracking_id/update",
    "put",
    {
      data: props,
      datasetId: this.datasetId
    },
    signal
  );
}
async function getChunkByTrackingId(props, signal) {
  if (!this.datasetId) {
    throw new Error("datasetId is required");
  }
  return this.trieve.fetch(
    "/api/chunk/tracking_id/{tracking_id}",
    "get",
    {
      trackingId: props.trackingId,
      datasetId: this.datasetId,
      xApiVersion: props.xApiVersion ?? "V2"
    },
    signal
  );
}
async function deleteChunkByTrackingId(props, signal) {
  if (!this.datasetId) {
    throw new Error("datasetId is required");
  }
  return this.trieve.fetch(
    "/api/chunk/tracking_id/{tracking_id}",
    "delete",
    {
      trackingId: props.trackingId,
      datasetId: this.datasetId
    },
    signal
  );
}
async function getChunkById(props, signal) {
  if (!this.datasetId) {
    throw new Error("datasetId is required");
  }
  return this.trieve.fetch(
    "/api/chunk/{chunk_id}",
    "get",
    {
      chunkId: props.chunkId,
      xApiVersion: props.xApiVersion ?? "V2",
      datasetId: this.datasetId
    },
    signal
  );
}
async function deleteChunkById(props, signal) {
  if (!this.datasetId) {
    throw new Error("datasetId is required");
  }
  return this.trieve.fetch(
    "/api/chunk/{chunk_id}",
    "delete",
    {
      chunkId: props.chunkId,
      datasetId: this.datasetId
    },
    signal
  );
}
async function getChunksByIds(props, signal) {
  if (!this.datasetId) {
    throw new Error("datasetId is required");
  }
  return this.trieve.fetch(
    "/api/chunks",
    "post",
    {
      data: props,
      datasetId: this.datasetId
    },
    signal
  );
}
async function getChunksByTrackingIds(props, signal) {
  if (!this.datasetId) {
    throw new Error("datasetId is required");
  }
  return this.trieve.fetch(
    "/api/chunks/tracking",
    "post",
    {
      data: props,
      datasetId: this.datasetId
    },
    signal
  );
}
async function splitChunkHtml(props, signal) {
  return this.trieve.fetch(
    "/api/chunk/split",
    "post",
    {
      data: props
    },
    signal
  );
}

// src/functions/groups/index.ts
var groups_exports = {};
__export(groups_exports, {
  addChunkToGroup: () => addChunkToGroup,
  addChunkToGroupByTrackingId: () => addChunkToGroupByTrackingId,
  createChunkGroup: () => createChunkGroup,
  deleteGroup: () => deleteGroup,
  deleteGroupByTrackingId: () => deleteGroupByTrackingId,
  getChunksGroupByTrackingId: () => getChunksGroupByTrackingId,
  getChunksInGroup: () => getChunksInGroup,
  getGroup: () => getGroup,
  getGroupByTrackingId: () => getGroupByTrackingId,
  getGroupsForChunks: () => getGroupsForChunks,
  getGroupsForDataset: () => getGroupsForDataset,
  recommendedGroups: () => recommendedGroups,
  removeChunkFromGroup: () => removeChunkFromGroup,
  searchInGroup: () => searchInGroup,
  searchOverGroups: () => searchOverGroups,
  updateGroup: () => updateGroup
});
async function createChunkGroup(data) {
  if (!this.datasetId) {
    throw new Error("datasetId is required");
  }
  return this.trieve.fetch("/api/chunk_group", "post", {
    data,
    datasetId: this.datasetId
  });
}
async function searchOverGroups(data, signal, parseHeaders) {
  if (!this.datasetId) {
    throw new Error("datasetId is required");
  }
  return this.trieve.fetch(
    "/api/chunk_group/group_oriented_search",
    "post",
    {
      data,
      datasetId: this.datasetId
    },
    signal,
    parseHeaders
  );
}
async function searchInGroup(data, signal, parseHeaders) {
  if (!this.datasetId) {
    throw new Error("datasetId is required");
  }
  return this.trieve.fetch(
    "/api/chunk_group/search",
    "post",
    {
      data,
      datasetId: this.datasetId
    },
    signal,
    parseHeaders
  );
}
async function recommendedGroups(data, signal) {
  if (!this.datasetId) {
    throw new Error("datasetId is required");
  }
  return this.trieve.fetch(
    "/api/chunk_group/recommend",
    "post",
    {
      data,
      datasetId: this.datasetId
    },
    signal
  );
}
async function updateGroup(data, signal) {
  if (!this.datasetId) {
    throw new Error("datasetId is required");
  }
  return this.trieve.fetch(
    "/api/chunk_group",
    "put",
    {
      data,
      datasetId: this.datasetId
    },
    signal
  );
}
async function addChunkToGroup(data, signal) {
  if (!this.datasetId) {
    throw new Error("datasetId is required");
  }
  return this.trieve.fetch(
    "/api/chunk_group/chunk/{group_id}",
    "post",
    {
      data,
      groupId: data.group_id,
      datasetId: this.datasetId
    },
    signal
  );
}
async function removeChunkFromGroup(data, signal) {
  if (!this.datasetId) {
    throw new Error("datasetId is required");
  }
  return this.trieve.fetch(
    "/api/chunk_group/chunk/{group_id}",
    "delete",
    {
      data,
      groupId: data.group_id,
      datasetId: this.datasetId
    },
    signal
  );
}
async function getGroupsForChunks(data, signal) {
  if (!this.datasetId) {
    throw new Error("datasetId is required");
  }
  return this.trieve.fetch(
    "/api/chunk_group/chunks",
    "post",
    {
      data,
      datasetId: this.datasetId
    },
    signal
  );
}
async function getChunksGroupByTrackingId(data, signal) {
  if (!this.datasetId) {
    throw new Error("datasetId is required");
  }
  return this.trieve.fetch(
    "/api/chunk_group/tracking_id/{group_tracking_id}/{page}",
    "get",
    {
      ...data,
      xApiVersion: data.xApiVersion || "V2",
      datasetId: this.datasetId
    },
    signal
  );
}
async function getGroupByTrackingId(data, signal) {
  if (!this.datasetId) {
    throw new Error("datasetId is required");
  }
  return this.trieve.fetch(
    "/api/chunk_group/tracking_id/{tracking_id}",
    "get",
    {
      ...data,
      datasetId: this.datasetId
    },
    signal
  );
}
async function addChunkToGroupByTrackingId(data, signal) {
  if (!this.datasetId) {
    throw new Error("datasetId is required");
  }
  return this.trieve.fetch(
    "/api/chunk_group/tracking_id/{tracking_id}",
    "post",
    {
      data,
      datasetId: this.datasetId,
      trackingId: data.tracking_id
    },
    signal
  );
}
async function deleteGroupByTrackingId(data, signal) {
  if (!this.datasetId) {
    throw new Error("datasetId is required");
  }
  return this.trieve.fetch(
    "/api/chunk_group/tracking_id/{tracking_id}",
    "delete",
    {
      ...data,
      trackingId: data.tracking_id,
      datasetId: this.datasetId
    },
    signal
  );
}
async function getGroup(data, signal) {
  if (!this.datasetId) {
    throw new Error("datasetId is required");
  }
  return this.trieve.fetch(
    "/api/chunk_group/{group_id}",
    "get",
    {
      ...data,
      datasetId: this.datasetId
    },
    signal
  );
}
async function deleteGroup(data, signal) {
  if (!this.datasetId) {
    throw new Error("datasetId is required");
  }
  return this.trieve.fetch(
    "/api/chunk_group/{group_id}",
    "delete",
    {
      ...data,
      datasetId: this.datasetId
    },
    signal
  );
}
async function getChunksInGroup(data, signal) {
  if (!this.datasetId) {
    throw new Error("datasetId is required");
  }
  return this.trieve.fetch(
    "/api/chunk_group/{group_id}/{page}",
    "get",
    {
      ...data,
      datasetId: this.datasetId
    },
    signal
  );
}
async function getGroupsForDataset(data, signal) {
  if (!this.datasetId) {
    throw new Error("datasetId is required");
  }
  return this.trieve.fetch(
    "/api/dataset/groups/{dataset_id}/{page}",
    "get",
    {
      ...data,
      datasetId: this.datasetId
    },
    signal
  );
}

// src/functions/analytics/index.ts
var analytics_exports = {};
__export(analytics_exports, {
  getAllAnalyticsEvents: () => getAllAnalyticsEvents,
  getCTRAnalytics: () => getCTRAnalytics,
  getClusterAnalytics: () => getClusterAnalytics,
  getRagAnalytics: () => getRagAnalytics,
  getRecommendationAnalytics: () => getRecommendationAnalytics,
  getSearchAnalytics: () => getSearchAnalytics,
  getTopDatasets: () => getTopDatasets,
  rateRagQuery: () => rateRagQuery,
  rateSearchQuery: () => rateSearchQuery,
  sendAnalyticsEvent: () => sendAnalyticsEvent,
  sendCTRAnalytics: () => sendCTRAnalytics
});
async function getCTRAnalytics(data, signal) {
  if (!this.datasetId) {
    throw new Error("datasetId is required");
  }
  return await this.trieve.fetch(
    "/api/analytics/events/ctr",
    "post",
    {
      data,
      datasetId: this.datasetId
    },
    signal
  );
}
async function sendCTRAnalytics(data, signal) {
  if (!this.datasetId) {
    throw new Error("datasetId is required");
  }
  return await this.trieve.fetch(
    "/api/analytics/ctr",
    "put",
    {
      data,
      datasetId: this.datasetId
    },
    signal
  );
}
async function sendAnalyticsEvent(data, signal) {
  if (!this.datasetId) {
    throw new Error("datasetId is required");
  }
  return await this.trieve.fetch(
    "/api/analytics/events",
    "put",
    {
      data,
      datasetId: this.datasetId
    },
    signal
  );
}
async function getRagAnalytics(data, signal) {
  if (!this.datasetId) {
    throw new Error("datasetId is required");
  }
  return this.trieve.fetch(
    "/api/analytics/rag",
    "post",
    {
      data,
      datasetId: this.datasetId
    },
    signal
  );
}
async function getRecommendationAnalytics(data, signal) {
  if (!this.datasetId) {
    throw new Error("datasetId is required");
  }
  return this.trieve.fetch(
    "/api/analytics/recommendations",
    "post",
    {
      data,
      datasetId: this.datasetId
    },
    signal
  );
}
async function getSearchAnalytics(data, signal) {
  if (!this.datasetId) {
    throw new Error("datasetId is required");
  }
  return this.trieve.fetch(
    "/api/analytics/search",
    "post",
    {
      data,
      datasetId: this.datasetId
    },
    signal
  );
}
async function getClusterAnalytics(data, signal) {
  if (!this.datasetId) {
    throw new Error("datasetId is required");
  }
  return this.trieve.fetch(
    "/api/analytics/search/cluster",
    "post",
    {
      data,
      datasetId: this.datasetId
    },
    signal
  );
}
async function rateRagQuery(data, signal) {
  if (!this.datasetId) {
    throw new Error("datasetId is required");
  }
  return this.trieve.fetch(
    "/api/analytics/rag",
    "put",
    {
      data,
      datasetId: this.datasetId
    },
    signal
  );
}
async function rateSearchQuery(data, signal) {
  if (!this.datasetId) {
    throw new Error("datasetId is required");
  }
  return this.trieve.fetch(
    "/api/analytics/search",
    "put",
    {
      data,
      datasetId: this.datasetId
    },
    signal
  );
}
async function getTopDatasets(data, signal) {
  return this.trieve.fetch(
    "/api/analytics/top",
    "post",
    {
      data,
      organizationId: data.organizationId
    },
    signal
  );
}
async function getAllAnalyticsEvents(data, signal) {
  return await this.trieve.fetch(
    "/api/analytics/events/all",
    "post",
    {
      data
    },
    signal
  );
}

// src/functions/topic/index.ts
var topic_exports = {};
__export(topic_exports, {
  cloneTopic: () => cloneTopic,
  createTopic: () => createTopic,
  deleteTopic: () => deleteTopic,
  getAllTopics: () => getAllTopics,
  updateTopic: () => updateTopic
});
async function createTopic(data, signal) {
  if (!this.datasetId) {
    throw new Error("datasetId is required");
  }
  return await this.trieve.fetch(
    "/api/topic",
    "post",
    {
      data,
      datasetId: this.datasetId
    },
    signal
  );
}
async function cloneTopic(data, signal) {
  if (!this.datasetId) {
    throw new Error("datasetId is required");
  }
  return await this.trieve.fetch(
    "/api/topic/clone",
    "post",
    {
      data,
      datasetId: this.datasetId
    },
    signal
  );
}
async function updateTopic(data, signal) {
  if (!this.datasetId) {
    throw new Error("datasetId is required");
  }
  return await this.trieve.fetch(
    "/api/topic",
    "put",
    {
      data,
      datasetId: this.datasetId
    },
    signal
  );
}
async function getAllTopics(data, signal) {
  if (!this.datasetId) {
    throw new Error("datasetId is required");
  }
  return await this.trieve.fetch(
    "/api/topic/owner/{owner_id}",
    "get",
    {
      ...data,
      datasetId: this.datasetId
    },
    signal
  );
}
async function deleteTopic(data, signal) {
  if (!this.datasetId) {
    throw new Error("datasetId is required");
  }
  return await this.trieve.fetch(
    "/api/topic/{topic_id}",
    "delete",
    {
      ...data,
      datasetId: this.datasetId
    },
    signal
  );
}

// src/functions/file/index.ts
var file_exports = {};
__export(file_exports, {
  createPresignedUrlForCsvJsonl: () => createPresignedUrlForCsvJsonl,
  deleteFile: () => deleteFile,
  getFile: () => getFile,
  getFilesForDataset: () => getFilesForDataset,
  uploadFile: () => uploadFile
});
async function uploadFile(data, signal) {
  if (!this.datasetId) {
    throw new Error("datasetId is required");
  }
  return await this.trieve.fetch(
    "/api/file",
    "post",
    {
      data,
      datasetId: this.datasetId
    },
    signal
  );
}
async function createPresignedUrlForCsvJsonl(data, signal) {
  if (!this.datasetId) {
    throw new Error("datasetId is required");
  }
  return await this.trieve.fetch(
    "/api/file/csv_or_jsonl",
    "post",
    {
      data,
      datasetId: this.datasetId
    },
    signal
  );
}
async function getFilesForDataset(data, signal) {
  if (!this.datasetId) {
    throw new Error("datasetId is required");
  }
  return await this.trieve.fetch(
    "/api/dataset/files/{dataset_id}/{page}",
    "get",
    {
      ...data,
      datasetId: this.datasetId
    },
    signal
  );
}
async function getFile(data, signal) {
  if (!this.datasetId) {
    throw new Error("datasetId is required");
  }
  return await this.trieve.fetch(
    `/api/file/{file_id}${data.contentType ? `?content_type=${encodeURIComponent(data.contentType)}` : ""}`,
    "get",
    {
      ...data,
      datasetId: this.datasetId
    },
    signal
  );
}
async function deleteFile(data, signal) {
  if (!this.datasetId) {
    throw new Error("datasetId is required");
  }
  return await this.trieve.fetch(
    `/api/file/{file_id}${data.deleteChunks ? `?delete_chunks=${data.deleteChunks}` : ""}`,
    "delete",
    {
      ...data,
      datasetId: this.datasetId
    },
    signal
  );
}

// src/functions/events/index.ts
var events_exports = {};
__export(events_exports, {
  getEventsForDataset: () => getEventsForDataset
});
async function getEventsForDataset(data, signal) {
  if (!this.datasetId) {
    throw new Error("datasetId is required");
  }
  return await this.trieve.fetch(
    "/api/dataset/events",
    "post",
    {
      data,
      datasetId: this.datasetId
    },
    signal
  );
}

// src/functions/datasets/index.ts
var datasets_exports = {};
__export(datasets_exports, {
  batchCreateDatasets: () => batchCreateDatasets,
  clearDataset: () => clearDataset,
  createDataset: () => createDataset,
  deleteDataset: () => deleteDataset,
  getAllDatasetTags: () => getAllDatasetTags,
  getDatasetById: () => getDatasetById,
  getDatasetByTrackingId: () => getDatasetByTrackingId,
  getDatasetEvents: () => getDatasetEvents,
  getDatasetFiles: () => getDatasetFiles,
  getDatasetUsageById: () => getDatasetUsageById,
  getDatasetsFromOrganization: () => getDatasetsFromOrganization,
  getPagefindUrl: () => getPagefindUrl,
  updateDataset: () => updateDataset
});
async function createDataset(props, signal) {
  if (!this.organizationId) {
    throw new Error("Organization ID is required to create a dataset");
  }
  return this.trieve.fetch(
    "/api/dataset",
    "post",
    {
      data: props,
      organizationId: this.organizationId
    },
    signal
  );
}
async function updateDataset(props, signal) {
  if (!this.organizationId) {
    throw new Error("Organization ID is required to update a dataset");
  }
  return this.trieve.fetch(
    "/api/dataset",
    "put",
    {
      data: props,
      organizationId: this.organizationId
    },
    signal
  );
}
async function batchCreateDatasets(props, signal) {
  if (!this.organizationId) {
    throw new Error("Organization ID is required to create a dataset");
  }
  return this.trieve.fetch(
    "/api/dataset/batch_create_datasets",
    "post",
    {
      data: props,
      organizationId: this.organizationId
    },
    signal
  );
}
async function clearDataset(datasetId, signal) {
  return this.trieve.fetch(
    "/api/dataset/clear/{dataset_id}",
    "put",
    {
      datasetId
    },
    signal
  );
}
async function getDatasetEvents(props, datasetId, signal) {
  return this.trieve.fetch(
    "/api/dataset/events",
    "post",
    {
      datasetId,
      data: props
    },
    signal
  );
}
async function getDatasetFiles(datasetId, page, signal) {
  return this.trieve.fetch(
    "/api/dataset/files/{dataset_id}/{page}",
    "get",
    {
      datasetId,
      page
    },
    signal
  );
}
async function getAllDatasetTags(props, datasetId, signal) {
  return this.trieve.fetch(
    "/api/dataset/get_all_tags",
    "post",
    {
      data: props,
      datasetId
    },
    signal
  );
}
async function getDatasetsFromOrganization(organizationId, limit, offset, signal) {
  return this.trieve.fetch(
    "/api/dataset/organization/{organization_id}",
    "get",
    {
      organizationId,
      limit,
      offset
    },
    signal
  );
}
async function getDatasetByTrackingId(trackingId, signal) {
  if (!this.organizationId) {
    throw new Error(
      "Organization ID is required to get a dataset by tracking ID"
    );
  }
  return this.trieve.fetch(
    "/api/dataset/tracking_id/{tracking_id}",
    "get",
    {
      organizationId: this.organizationId,
      trackingId
    },
    signal
  );
}
async function getDatasetUsageById(datasetId, signal) {
  return this.trieve.fetch(
    "/api/dataset/usage/{dataset_id}",
    "get",
    {
      datasetId
    },
    signal
  );
}
async function getDatasetById(datasetId, signal) {
  return this.trieve.fetch(
    "/api/dataset/{dataset_id}",
    "get",
    {
      datasetId
    },
    signal
  );
}
async function deleteDataset(datasetId, signal) {
  return this.trieve.fetch(
    "/api/dataset/{dataset_id}",
    "delete",
    {
      datasetId
    },
    signal
  );
}
async function getPagefindUrl(datasetId, signal) {
  return this.trieve.fetch(
    "/api/dataset/pagefind",
    "get",
    {
      datasetId
    },
    signal
  );
}

// src/functions/user/index.ts
var user_exports = {};
__export(user_exports, {
  updateUserRole: () => updateUserRole
});
async function updateUserRole(props, signal) {
  if (!this.organizationId) {
    throw new Error("Organization ID is required to update user role");
  }
  return this.trieve.fetch(
    "/api/user",
    "put",
    {
      data: props,
      organizationId: this.organizationId
    },
    signal
  );
}

// src/functions/organization/index.ts
var organization_exports = {};
__export(organization_exports, {
  createOrganizationApiKey: () => createOrganizationApiKey,
  deleteOrganizationApiKey: () => deleteOrganizationApiKey
});
async function createOrganizationApiKey(props, signal) {
  if (!this.organizationId) {
    throw new Error(
      "Organization ID is required to create Organization API key"
    );
  }
  return this.trieve.fetch(
    "/api/organization/api_key",
    "post",
    {
      data: props,
      organizationId: this.organizationId
    },
    signal
  );
}
async function deleteOrganizationApiKey(apiKeyId, signal) {
  if (!this.organizationId) {
    throw new Error(
      "Organization ID is required to delete Organization API key"
    );
  }
  return this.trieve.fetch(
    "/api/organization/api_key/{api_key_id}",
    "delete",
    {
      apiKeyId,
      organizationId: this.organizationId
    },
    signal
  );
}

// src/functions/crawl/index.ts
var crawl_exports = {};
__export(crawl_exports, {
  getCrawlsForDataset: () => getCrawlsForDataset
});
async function getCrawlsForDataset(props, signal) {
  if (!this.datasetId) {
    throw new Error("Dataset ID is required to create a crawl");
  }
  return this.trieve.fetch(
    `/api/crawl?limit=${props.limit ?? 10}&page=${props.page ?? 1}`,
    "get",
    {
      data: props,
      datasetId: this.datasetId
    },
    signal
  );
}

// src/functions/index.ts
var functions_default = {
  ...chunks_exports,
  ...groups_exports,
  ...analytics_exports,
  ...topic_exports,
  ...message_exports,
  ...file_exports,
  ...events_exports,
  ...datasets_exports,
  ...user_exports,
  ...organization_exports,
  ...crawl_exports
};

// src/sdk.ts
var TrieveSDK = class {
  trieve;
  datasetId;
  organizationId;
  constructor({
    apiKey,
    baseUrl = "https://api.trieve.ai",
    debug = false,
    datasetId,
    organizationId,
    omitCredentials
  }) {
    this.trieve = new TrieveFetchClient({
      apiKey,
      baseUrl,
      debug,
      organizationId,
      omitCredentials
    });
    this.datasetId = datasetId;
    this.organizationId = organizationId;
  }
};
Object.entries(functions_default).forEach(([name, method]) => {
  TrieveSDK.prototype[name] = method;
});
export {
  TrieveFetchClient,
  TrieveSDK
};
//# sourceMappingURL=index.mjs.map
