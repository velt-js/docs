---
title: "Comments"
description: "Self-host your comments data while using Velt's components. Keep comment storage on your infrastructure with minimal metadata stored on Velt servers."
---

<Warning>
  - This is currently only compatible with `setDocuments` method.
  - Ensure that the data providers are set prior to calling `identify` method.
  - The data provider methods must return the correct status code (e.g. 200 for success, 500 for errors) and success boolean in the response object. This ensures proper error handling and retries.
  - If you are using REST API to add or update comments, ensure that you set `isCommentResolverUsed` and `isCommentTextAvailable` fields in the request object. [Learn more](/api-reference/rest-apis/v2/comments-feature/comment-annotations/add-comment-annotations)
</Warning>

# Overview
Velt supports self-hosting your comments and related data:

- Comments can be stored on your own infrastructure, with only necessary identifiers on Velt servers.
- Velt Components automatically hydrate comment data in the frontend by fetching from your configured data provider.
- This gives you full control over comment data while maintaining all Velt collaboration features.
- This automatically also ensures that the in-app notifications content is not stored on Velt servers. The content is generated using the comments data in the frontend.

<Warning>
Email notifications via Velt's SendGrid integration are not available when you self-host comment content. Since the content lives on your infrastructure, Velt cannot construct and send emails via the sendgrid integration. Instead, use [Webhooks](/webhooks/basic) to receive events (e.g., mentions, replies), fetch the relevant comment/notification content from your database, and send emails from your own email provider.
</Warning>

# How does it work?
- When comments are created, updated, deleted or requested, the SDK uses your configured [`CommentAnnotationDataProvider`](/api-reference/sdk/models/data-models#commentannotationdataprovider) to handle storage and retrieval
- The data provider implements `get`, `save`, and `delete` methods to interact with your database
- Velt handles the data mapping and realtime synchronization while delegating persistence of actual content to your infrastructure
- The data provider works at the Comment Annotation (Thread) level not at the individual Comment (Message) level.
- For write requests (save, delete), the operation is first performed on your database and only if we get a success response, the SDK will perform the operation on the Velt server. If the operation fails on your database, the SDK will not perform the operation on the Velt server.
- You can configure retries, timeouts, etc. for the data provider.

Here are the methods that you need to implement on the data provider:
## get
Method to fetch comments from your database. On error we will retry.
- Param: [`GetCommentResolverRequest`](/api-reference/sdk/models/data-models#getcommentresolverrequest)
- Return: [`Promise<ResolverResponse<Record<string, PartialCommentAnnotation>>>`](/api-reference/sdk/models/data-models#resolverresponse)

<Tabs>
<Tab title="Frontend Example">
```jsx
const fetchCommentsFromDB = async (request) => {
  const response = await fetch('/api/velt/comments/get', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(request)
  });
  const data = await response.json();
  return { data: data.result || {}, success: true, statusCode: 200 };
};

const commentDataProvider = {
  get: fetchCommentsFromDB,
};

<VeltProvider
  apiKey='YOUR_API_KEY'
  dataProviders={{ comment: commentDataProvider }}
>
</VeltProvider>
```
</Tab>
<Tab title="Backend Endpoint Example (MongoDB)">
```javascript
// Build query from request filters
const { filters } = req.body;
const query = {};
if (filters.commentAnnotationIds?.length) {
  query.annotationId = { $in: filters.commentAnnotationIds };
}
if (filters.documentIds?.length) {
  query.documentId = { $in: filters.documentIds };
}
if (filters.organizationId) {
  query.organizationId = filters.organizationId;
}

const annotations = await collection.find(query).toArray();

// Convert to Record<annotationId, annotation>
const result = {};
for (const annotation of annotations) {
  result[annotation.annotationId] = annotation;
}

// Return response in required format
res.json({ data: result, success: true, statusCode: 200 });
```
</Tab>
<Tab title="Backend Endpoint Example (PostgreSQL)">
```javascript
// Build parameterized query from filters
const { filters } = req.body;
const conditions = [];
const values = [];
let paramIndex = 1;

if (filters.commentAnnotationIds?.length) {
  conditions.push(`annotation_id = ANY($${paramIndex++})`);
  values.push(filters.commentAnnotationIds);
}
if (filters.documentIds?.length) {
  conditions.push(`document_id = ANY($${paramIndex++})`);
  values.push(filters.documentIds);
}
if (filters.organizationId) {
  conditions.push(`organization_id = $${paramIndex++}`);
  values.push(filters.organizationId);
}

const whereClause = conditions.length ? `WHERE ${conditions.join(' AND ')}` : '';
const { rows } = await client.query(
  `SELECT annotation_id, data FROM comment_annotations ${whereClause}`,
  values
);

// Convert to Record<annotationId, annotation>
const result = {};
for (const row of rows) {
  result[row.annotation_id] = row.data;
}

// Return response in required format
res.json({ data: result, success: true, statusCode: 200 });
```
</Tab>
</Tabs>

## save
Save comments to your database. Return a success or error response. On error we will retry.
- Param: [`SaveCommentResolverRequest`](/api-reference/sdk/models/data-models#savecommentresolverrequest)
  - Note in the `SaveCommentResolverRequest` object, you will receive [the event name](/api-reference/sdk/models/data-models#resolveractions) that triggered the save.
- Return: [`Promise<ResolverResponse<T>>`](/api-reference/sdk/models/data-models#resolverresponse)

<Warning>
  If you are using REST API to add or update comments, ensure that you set `isCommentResolverUsed` and `isCommentTextAvailable` fields in the request object. [Learn more](/api-reference/rest-apis/v2/comments-feature/comment-annotations/add-comment-annotations)
</Warning>

<Tabs>
<Tab title="Frontend Example">
```jsx
const saveCommentsToDB = async (request) => {
  const response = await fetch('/api/velt/comments/save', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(request)
  });
  return response.ok
    ? { success: true, statusCode: 200 }
    : { success: false, statusCode: response.status };
};

const commentDataProvider = {
  save: saveCommentsToDB,
};

<VeltProvider
  apiKey='YOUR_API_KEY'
  dataProviders={{ comment: commentDataProvider }}
>
</VeltProvider>
```
</Tab>
<Tab title="Backend Endpoint Example (MongoDB)">
```javascript
const { annotations, context } = req.body;

// Bulk upsert annotations
const operations = Object.entries(annotations).map(([id, annotation]) => ({
  updateOne: {
    filter: { annotationId: id },
    update: {
      $set: {
        ...annotation,
        annotationId: id,
        documentId: context?.documentId || annotation.documentId,
        organizationId: context?.organizationId || annotation.organizationId,
      }
    },
    upsert: true
  }
}));

if (operations.length > 0) {
  await collection.bulkWrite(operations);
}

// Return response in required format
res.json({ success: true, statusCode: 200 });
```
</Tab>
<Tab title="Backend Endpoint Example (PostgreSQL)">
```javascript
const { annotations, context } = req.body;

// Transaction-based upsert
await client.query('BEGIN');

for (const [id, annotation] of Object.entries(annotations)) {
  const data = { ...annotation, annotationId: id };

  await client.query(
    `INSERT INTO comment_annotations (annotation_id, document_id, organization_id, data, updated_at)
     VALUES ($1, $2, $3, $4, NOW())
     ON CONFLICT (annotation_id)
     DO UPDATE SET data = EXCLUDED.data, updated_at = NOW()`,
    [id, annotation.documentId, annotation.organizationId, JSON.stringify(data)]
  );
}

await client.query('COMMIT');

// Return response in required format
res.json({ success: true, statusCode: 200 });
```
</Tab>
</Tabs>

## delete
Delete comments from your database. Return a success or error response. On error we will retry.
- Param: [`DeleteCommentResolverRequest`](/api-reference/sdk/models/data-models#deletecommentresolverrequest)
- Return: [`Promise<ResolverResponse<T>>`](/api-reference/sdk/models/data-models#resolverresponse)

<Tabs>
<Tab title="Frontend Example">
```jsx
const deleteCommentsFromDB = async (request) => {
  const response = await fetch('/api/velt/comments/delete', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(request)
  });
  return response.ok
    ? { success: true, statusCode: 200 }
    : { success: false, statusCode: response.status };
};

const commentDataProvider = {
  delete: deleteCommentsFromDB,
};

<VeltProvider
  apiKey='YOUR_API_KEY'
  dataProviders={{ comment: commentDataProvider }}
>
</VeltProvider>
```
</Tab>
<Tab title="Backend Endpoint Example (MongoDB)">
```javascript
const { annotationId } = req.body;

await collection.deleteOne({ annotationId });

// Return response in required format
res.json({ success: true, statusCode: 200 });
```
</Tab>
<Tab title="Backend Endpoint Example (PostgreSQL)">
```javascript
const { annotationId } = req.body;

await client.query(
  'DELETE FROM comment_annotations WHERE annotation_id = $1',
  [annotationId]
);

// Return response in required format
res.json({ success: true, statusCode: 200 });
```
</Tab>
</Tabs>

## config
Configuration for the comment data provider.
- Type: [`ResolverConfig`](/api-reference/sdk/models/data-models#resolverconfig)

```jsx
const commentResolverConfig = {
  resolveTimeout: 2000,
  saveRetryConfig: { retryCount: 3, retryDelay: 2000 },
  deleteRetryConfig: { retryCount: 3, retryDelay: 2000 }
};
```

# Example Implementation

<Tabs>
<Tab title="React / Next.js">
``` jsx
const fetchCommentsFromDB = async (request) => {
  const response = await fetch('/api/velt/comments/get', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(request)
  });
  const data = await response.json();
  return { data: data.result || {}, success: true, statusCode: 200 };
};

const saveCommentsToDB = async (request) => {
  const response = await fetch('/api/velt/comments/save', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(request)
  });
  return response.ok
    ? { success: true, statusCode: 200 }
    : { success: false, statusCode: response.status };
};

const deleteCommentsFromDB = async (request) => {
  const response = await fetch('/api/velt/comments/delete', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(request)
  });
  return response.ok
    ? { success: true, statusCode: 200 }
    : { success: false, statusCode: response.status };
};

const commentResolverConfig = {
  resolveTimeout: 2000,
  saveRetryConfig: { retryCount: 3, retryDelay: 2000 },
  deleteRetryConfig: { retryCount: 3, retryDelay: 2000 }
};

const commentDataProvider = {
  get: fetchCommentsFromDB,
  save: saveCommentsToDB,
  delete: deleteCommentsFromDB,
  config: commentResolverConfig
};

<VeltProvider
  apiKey='YOUR_API_KEY'
  dataProviders={{ comment: commentDataProvider }}
>
</VeltProvider>
```
</Tab>
<Tab title="Other Frameworks">
```js
const fetchCommentsFromDB = async (request) => {
  const response = await fetch('/api/velt/comments/get', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(request)
  });
  const data = await response.json();
  return { data: data.result || {}, success: true, statusCode: 200 };
};

const saveCommentsToDB = async (request) => {
  const response = await fetch('/api/velt/comments/save', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(request)
  });
  return response.ok
    ? { success: true, statusCode: 200 }
    : { success: false, statusCode: response.status };
};

const deleteCommentsFromDB = async (request) => {
  const response = await fetch('/api/velt/comments/delete', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(request)
  });
  return response.ok
    ? { success: true, statusCode: 200 }
    : { success: false, statusCode: response.status };
};

const commentResolverConfig = {
  resolveTimeout: 2000,
  saveRetryConfig: { retryCount: 3, retryDelay: 2000 },
  deleteRetryConfig: { retryCount: 3, retryDelay: 2000 }
};

const commentDataProvider = {
  get: fetchCommentsFromDB,
  save: saveCommentsToDB,
  delete: deleteCommentsFromDB,
  config: commentResolverConfig
};

Velt.setDataProviders({ comment: commentDataProvider });
```
</Tab>
</Tabs>

# Triggering Email Notifications when Self-Hosting

When you self-host content, use Webhooks to trigger emails from your own system:

<Steps>
<Step title="Enable relevant webhooks">
Subscribe to comment-related events (e.g., user mentions, replies). See [Webhooks basics](/webhooks/basic).
</Step>

<Step title="Receive webhook and fetch content from your DB">
Your server receives the webhook event. Use IDs from the payload (e.g., `annotationId`, `commentId`) to query your own comment and notification content from your database via your Data Provider.
</Step>

<Step title="Assemble email content and recipients">
Combine the webhook event context with the self-hosted content to build the subject, body, and list of recipients (e.g., mentioned users).
</Step>

<Step title="Send email via your provider">
Use your own email service (SendGrid under your account, SES, Postmark, etc.) to send the email.
</Step>
</Steps>

**Example:** 

<Tabs>
<Tab title="Example Webhook Payload">
```json cURL
POST /webhooks/velt HTTP/1.1
Content-Type: application/json

{
  "actionType": "newlyAdded",
  "commentAnnotation": { "annotationId": "ANNOTATION_ID", "metadata": { "documentId": "DOC_ID" } },
  "latestComment": { "commentId": 123, "from": { "userId": "USER_1" } },
  "fromUser": { "userId": "USER_1" },
  "documentMetadata": { "url": "https://app.example.com/doc/123" }
}
```
</Tab>
<Tab title="Example Notification Code (Node.js)">
```javascript Node.js
// Pseudocode: handle webhook, fetch content, send email
app.post('/webhooks/velt', async (req, res) => {
  const evt = req.body;
  const annotationId = evt?.commentAnnotation?.annotationId;
  const latestCommentId = evt?.latestComment?.commentId;

  // 1) Fetch self-hosted content
  const annotation = await db.commentAnnotations.get(annotationId);
  const latestComment = annotation?.comments?.[latestCommentId];

  // 2) Resolve recipients (e.g., mentioned users)
  const recipients = await resolveMentionedUsers(annotation, latestComment);

  // 3) Compose email
  const subject = `${evt.fromUser?.userId} mentioned you`;
  const body = latestComment?.commentText || '';
  const pageUrl = evt?.documentMetadata?.url;

  // 4) Send via your provider
  await emailClient.send({ to: recipients, subject, html: renderTemplate({ body, pageUrl }) });

  res.sendStatus(200);
});
```
</Tab>
</Tabs>

# Debugging

You can subscribe to `dataProvider` events to monitor and debug get, save, and delete operations:

<Tabs>
<Tab title="React / Next.js">
```jsx
import { useVeltClient } from '@veltdev/react';

const { client } = useVeltClient();

useEffect(() => {
  if (!client) return;

  const subscription = client.on('dataProvider').subscribe((event) => {
    console.log('Data Provider Event:', event);
  });

  return () => subscription?.unsubscribe();
}, [client]);
```
</Tab>

<Tab title="Other Frameworks">
```javascript
const subscription = Velt.on('dataProvider').subscribe((event) => {
  console.log('Data Provider Event:', event);
});

// Unsubscribe when done
subscription?.unsubscribe();
```
</Tab>
</Tabs>

# Sample Data

<Tabs>
<Tab title="Stored on your database">
```json
{
    "ANNOTATION_ID": {
        "annotationId": "ANNOTATION_ID",
        "metadata": {
            "apiKey": "API_KEY",
            "documentId": "DOCUMENT_ID",
            "organizationId": "ORGANIZATION_ID",
            "folderId": "FOLDER_ID"
        },
        "comments": {
            "COMMENT_ID": {
                "commentId": COMMENT_ID_NUMBER,
                "commentHtml": "<p>Hey @Jane, can you review this?</p>",
                "commentText": "Hey @Jane, can you review this?",
                "from": {
                    "userId": "USER_ID"
                },
                "to": [
                    {
                        "userId": "JANE_USER_ID"
                    }
                ],
                "taggedUserContacts": [
                    {
                        "userId": "JANE_USER_ID",
                        "contact": {
                            "userId": "JANE_USER_ID"
                        },
                        "text": "@Jane"
                    }
                ]
            }
        },
        "from": {
            "userId": "USER_ID"
        }
    }
}
```
</Tab>
<Tab title="Stored on Velt servers">
```json
{
    "comments": [
        {
            "commentId": COMMENT_ID_NUMBER,
            "type": "text",
            "lastUpdated": "2025-07-16T04:00:19.770Z",
            "createdAt": 1752638419744,
            "from": {
                "userId": "USER_ID"
            }
        }
    ],
    "status": {
        "id": "OPEN",
        "name": "Open",
        "color": "var(--velt-accent, #625DF5)",
        "lightColor": "var(--velt-accent-light, #E7E8FA)",
        "type": "default"
    },
    "pageInfo": {
        "url": "PAGE_URL",
        "commentUrl": "COMMENT_URL"
    },
    "from": {
        "userId": "USER_ID"
    },
    "lastUpdated": 1752638419745,
    "createdAt": 1752638412635,
    "annotationId": "ANNOTATION_ID",
    "metadata": {
        "apiKey": "API_KEY",
        "documentId": "DOCUMENT_ID",
        "organizationId": "ORGANIZATION_ID",
        "folderId": "FOLDER_ID"
    }
}

```
</Tab>
</Tabs>