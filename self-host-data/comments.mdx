---
title: "Comments"
description: "Self-host your comments data while using Velt's components. Keep comment storage on your infrastructure with minimal metadata stored on Velt servers."
---

<Warning>
  - This feature is currently in beta and is subject to change.
  - This is currently only compatible with `setDocuments` method.
  - Ensure that the data providers are set prior to calling `identify` method.
  - The data provider methods must return the correct status code (e.g. 200 for success, 500 for errors) and success boolean in the response object. This ensures proper error handling and retries.
  - If you are using REST API to add or update comments, ensure that you set `isCommentResolverUsed` and `isCommentTextAvailable` fields in the request object. [Learn more](/api-reference/rest-apis/v2/comments-feature/comment-annotations/add-comment-annotations)
</Warning>

# Overview
Velt supports self-hosting your comments and related data:

- Comments can be stored on your own infrastructure, with only necessary identifiers on Velt servers.
- Velt Components automatically hydrate comment data in the frontend by fetching from your configured data provider.
- This gives you full control over comment data while maintaining all Velt collaboration features.
- This automatically also ensures that the in-app notifications content is not stored on Velt servers. The content is generated using the comments data in the frontend.

<Warning>
Email notifications via Velt's SendGrid integration are not available when you self-host comment content. Since the content lives on your infrastructure, Velt cannot construct and send emails via the sendgrid integration. Instead, use [Webhooks](/webhooks/basic) to receive events (e.g., mentions, replies), fetch the relevant comment/notification content from your database, and send emails from your own email provider.
</Warning>

# How does it work?
- When comments are created, updated, deleted or requested, the SDK uses your configured [`CommentAnnotationDataProvider`](/api-reference/sdk/models/data-models#commentannotationdataprovider) to handle storage and retrieval
- The data provider implements `get`, `save`, and `delete` methods to interact with your database
- Velt handles the data mapping and realtime synchronization while delegating persistence of actual content to your infrastructure
- The data provider works at the Comment Annotation (Thread) level not at the individual Comment (Message) level.
- For write requests (save, delete), the operation is first performed on your database and only if we get a success response, the SDK will perform the operation on the Velt server. If the operation fails on your database, the SDK will not perform the operation on the Velt server.
- You can configure retries, timeouts, etc. for the data provider.

Here are the methods that you need to implement on the data provider:
## get
Method to fetch comments from your database. On error we will retry.
- Param: [`GetCommentResolverRequest`](/api-reference/sdk/models/data-models#getcommentresolverrequest)
- Return: [`Promise<ResolverResponse<Record<string, PartialCommentAnnotation>>>`](/api-reference/sdk/models/data-models#resolverresponse)

<Tabs>
<Tab title="Sample Request">
```json
{
  "organizationId": "your-org-id",
  "documentIds": ["doc-123", "doc-456"],
  "folderId": "folder-789"
}
```

Or fetch specific annotations:

```json
{
  "organizationId": "your-org-id",
  "commentAnnotationIds": ["annotation-abc", "annotation-xyz"]
}
```
</Tab>

<Tab title="Sample Response">
```json
{
  "success": true,
  "statusCode": 200,
  "data": {
    "annotation-abc": {
      "annotationId": "annotation-abc",
      "metadata": {
        "apiKey": "your-api-key",
        "documentId": "doc-123",
        "organizationId": "your-org-id",
        "folderId": "folder-789"
      },
      "comments": {
        "comment-1": {
          "commentId": 1,
          "commentHtml": "<p>This is a comment</p>",
          "commentText": "This is a comment",
          "from": {
            "userId": "user-1"
          }
        }
      },
      "from": {
        "userId": "user-1"
      }
    }
  }
}
```
</Tab>

<Tab title="Error Response">
```json
{
  "success": false,
  "statusCode": 500,
  "message": "Failed to fetch comments from database"
}
```
</Tab>
</Tabs>

## save
Save comments to your database. Return a success or error response. On error we will retry.
- Param: [`SaveCommentResolverRequest`](/api-reference/sdk/models/data-models#savecommentresolverrequest)
  - Note in the `SaveCommentResolverRequest` object, you will receive [the event name](/api-reference/sdk/models/data-models#resolveractions) that triggered the save.
- Return: [`Promise<ResolverResponse<T>>`](/api-reference/sdk/models/data-models#resolverresponse)

<Warning>
  If you are using REST API to add or update comments, ensure that you set `isCommentResolverUsed` and `isCommentTextAvailable` fields in the request object. [Learn more](/api-reference/rest-apis/v2/comments-feature/comment-annotations/add-comment-annotations)
</Warning>

<Tabs>
<Tab title="Sample Request">
```json
{
  "commentAnnotation": {
    "annotation-abc": {
      "annotationId": "annotation-abc",
      "metadata": {
        "apiKey": "your-api-key",
        "documentId": "doc-123",
        "organizationId": "your-org-id",
        "folderId": "folder-789"
      },
      "comments": {
        "comment-1": {
          "commentId": 1,
          "commentHtml": "<p>Updated comment text</p>",
          "commentText": "Updated comment text",
          "from": {
            "userId": "user-1"
          }
        }
      },
      "from": {
        "userId": "user-1"
      }
    }
  },
  "metadata": {
    "apiKey": "your-api-key",
    "documentId": "doc-123",
    "organizationId": "your-org-id"
  },
  "event": "onCommentAdd",
  "commentId": "comment-1"
}
```
</Tab>

<Tab title="Sample Response">
```json
{
  "success": true,
  "statusCode": 200,
  "message": "Comment saved successfully"
}
```
</Tab>

<Tab title="Error Response">
```json
{
  "success": false,
  "statusCode": 500,
  "message": "Failed to save comment to database"
}
```
</Tab>
</Tabs>

## delete
Delete comments from your database. Return a success or error response. On error we will retry.
- Param: [`DeleteCommentResolverRequest`](/api-reference/sdk/models/data-models#deletecommentresolverrequest)
- Return: [`Promise<ResolverResponse<T>>`](/api-reference/sdk/models/data-models#resolverresponse)

<Tabs>
<Tab title="Sample Request">
```json
{
  "commentAnnotationId": "annotation-abc",
  "metadata": {
    "apiKey": "your-api-key",
    "documentId": "doc-123",
    "organizationId": "your-org-id",
    "folderId": "folder-789"
  },
  "event": "onCommentDelete"
}
```
</Tab>

<Tab title="Sample Response">
```json
{
  "success": true,
  "statusCode": 200,
  "message": "Comment deleted successfully"
}
```
</Tab>

<Tab title="Error Response">
```json
{
  "success": false,
  "statusCode": 500,
  "message": "Failed to delete comment from database"
}
```
</Tab>
</Tabs>

## config
Configuration for the comment data provider.
- Type: [`ResolverConfig`](/api-reference/sdk/models/data-models#resolverconfig)

# MongoDB Backend Implementation Example

Here's how to implement the data provider methods with MongoDB:

<Tabs>
<Tab title="Schema Definition">
```typescript
// MongoDB Schema for Comment Annotations
interface CommentAnnotationDocument {
  annotationId: string;
  metadata: {
    apiKey: string;
    documentId: string;
    organizationId: string;
    folderId?: string;
  };
  comments: {
    [commentId: string]: {
      commentId: number;
      commentHtml: string;
      commentText: string;
      from: {
        userId: string;
      };
    };
  };
  from: {
    userId: string;
  };
  createdAt?: Date;
  updatedAt?: Date;
}
```
</Tab>

<Tab title="Get Method">
```typescript
import { MongoClient, Db } from 'mongodb';

const fetchCommentsFromDB = async (request: GetCommentResolverRequest) => {
  try {
    const db: Db = client.db('your-database');
    const collection = db.collection<CommentAnnotationDocument>('commentAnnotations');
    
    // Build query based on request parameters
    const query: any = {
      'metadata.organizationId': request.organizationId
    };
    
    // Filter by specific annotation IDs
    if (request.commentAnnotationIds?.length) {
      query.annotationId = { $in: request.commentAnnotationIds };
    }
    
    // Filter by document IDs
    if (request.documentIds?.length) {
      query['metadata.documentId'] = { $in: request.documentIds };
    }
    
    // Filter by folder ID
    if (request.folderId) {
      query['metadata.folderId'] = request.folderId;
    }
    
    // Fetch from MongoDB
    const annotations = await collection.find(query).toArray();
    
    // Transform to required format: Record<annotationId, annotation>
    const data: Record<string, PartialCommentAnnotation> = {};
    annotations.forEach(annotation => {
      data[annotation.annotationId] = {
        annotationId: annotation.annotationId,
        metadata: annotation.metadata,
        comments: annotation.comments,
        from: annotation.from
      };
    });
    
    return { 
      data, 
      success: true, 
      statusCode: 200 
    };
  } catch (error) {
    console.error('Error fetching comments:', error);
    return { 
      success: false, 
      statusCode: 500,
      message: 'Failed to fetch comments from database'
    };
  }
};
```
</Tab>

<Tab title="Save Method">
```typescript
const saveCommentsToDB = async (request: SaveCommentResolverRequest) => {
  try {
    const db: Db = client.db('your-database');
    const collection = db.collection<CommentAnnotationDocument>('commentAnnotations');
    
    // Get the annotation data from request
    const annotationData = Object.values(request.commentAnnotation)[0];
    
    if (!annotationData) {
      return { 
        success: false, 
        statusCode: 400,
        message: 'No annotation data provided'
      };
    }
    
    // Upsert the comment annotation
    await collection.updateOne(
      { annotationId: annotationData.annotationId },
      { 
        $set: {
          ...annotationData,
          updatedAt: new Date()
        },
        $setOnInsert: {
          createdAt: new Date()
        }
      },
      { upsert: true }
    );
    
    return { 
      success: true, 
      statusCode: 200,
      message: 'Comment saved successfully'
    };
  } catch (error) {
    console.error('Error saving comment:', error);
    return { 
      success: false, 
      statusCode: 500,
      message: 'Failed to save comment to database'
    };
  }
};
```
</Tab>

<Tab title="Delete Method">
```typescript
const deleteCommentsFromDB = async (request: DeleteCommentResolverRequest) => {
  try {
    const db: Db = client.db('your-database');
    const collection = db.collection<CommentAnnotationDocument>('commentAnnotations');
    
    // Delete the comment annotation
    const result = await collection.deleteOne({
      annotationId: request.commentAnnotationId
    });
    
    if (result.deletedCount === 0) {
      return { 
        success: false, 
        statusCode: 404,
        message: 'Comment annotation not found'
      };
    }
    
    return { 
      success: true, 
      statusCode: 200,
      message: 'Comment deleted successfully'
    };
  } catch (error) {
    console.error('Error deleting comment:', error);
    return { 
      success: false, 
      statusCode: 500,
      message: 'Failed to delete comment from database'
    };
  }
};
```
</Tab>

<Tab title="Complete Setup">
```typescript
import { MongoClient } from 'mongodb';

// Initialize MongoDB connection
const client = new MongoClient('mongodb://localhost:27017');
await client.connect();

// Create indexes for better query performance
const db = client.db('your-database');
const collection = db.collection('commentAnnotations');

await collection.createIndexes([
  { key: { annotationId: 1 }, unique: true },
  { key: { 'metadata.organizationId': 1 } },
  { key: { 'metadata.documentId': 1 } },
  { key: { 'metadata.folderId': 1 } }
]);

// Configure the data provider
const commentResolverConfig: ResolverConfig = {
  resolveTimeout: 2000,
  getRetryConfig: {
    retryCount: 3,
    retryDelay: 2000
  },
  saveRetryConfig: {
    retryCount: 3,
    retryDelay: 2000
  },
  deleteRetryConfig: {
    retryCount: 3,
    retryDelay: 2000
  }
};

const commentAnnotationDataProvider: CommentAnnotationDataProvider = {
  get: fetchCommentsFromDB,
  save: saveCommentsToDB,
  delete: deleteCommentsFromDB,
  config: commentResolverConfig
};
```
</Tab>
</Tabs>

# Example Implementation

<Tabs>
<Tab title="React / Next.js">
``` jsx
const fetchCommentsFromDB = async (request: GetCommentResolverRequest) => {
    // Fetch comment annotations from your DB
    const result = await __getCommentsFromYourDB__(request)
      .then((response) => {
        return { data: response, success: true, statusCode: 200 };
      })
      .catch((error) => {
        return { success: false, statusCode: 500 };
      });

    return result;
};

const saveCommentsToDB = async (request: SaveCommentResolverRequest) => {
    const result = await __saveCommentsToYourDB__(request)
      .then((response) => {
        return { success: true, statusCode: 200 };
      })
      .catch((error) => {
        return { success: false, statusCode: 500 };
    });
    return result;
};

const deleteCommentsFromDB = async (request: DeleteCommentResolverRequest) => {
    const result = await __deleteCommentsFromYourDB__(request)
      .then((response) => {
        return { success: true, statusCode: 200 };
      })
      .catch((error) => {
        return { success: false, statusCode: 500 };
    });
    return result;
};

const commentResolverConfig: ResolverConfig = {
    resolveTimeout: 2000,
    getRetryConfig: {
        retryCount: 3,
        retryDelay: 2000
    },
    saveRetryConfig: {
        retryCount: 3,
        retryDelay: 2000
    },
    deleteRetryConfig: {
        retryCount: 3,
        retryDelay: 2000
    }
};


const commentAnnotationDataProvider: CommentAnnotationDataProvider = {
    get: fetchCommentsFromDB,
    save: saveCommentsToDB,
    delete: deleteCommentsFromDB,
    config: commentResolverConfig
};

<VeltProvider 
    apiKey='YOUR_API_KEY'
    dataProviders={{
        comment: commentAnnotationDataProvider
    }}
>
</VeltProvider>

```
</Tab>
<Tab title="Other Frameworks">
```js
const fetchCommentsFromDB = async (request) => {
    // Fetch comment annotations from your DB
    const result = await __getCommentsFromYourDB__(request)
      .then((response) => {
        return { data: response, success: true, statusCode: 200 };
      })
      .catch((error) => {
        return { success: false, statusCode: 500 };
      });

    return result;
};

const saveCommentsToDB = async (request) => {
    const result = await __saveCommentsToYourDB__(request)
      .then((response) => {
        return { success: true, statusCode: 200 };
      })
      .catch((error) => {
        return { success: false, statusCode: 500 };
    });
    return result;
};

const deleteCommentsFromDB = async (request) => {
    const result = await __deleteCommentsFromYourDB__(request)
      .then((response) => {
        return { success: true, statusCode: 200 };
      })
      .catch((error) => {
        return { success: false, statusCode: 500 };
    });
    return result;
};

const commentResolverConfig = {
    resolveTimeout: 2000,
    saveRetryConfig: {
        retryCount: 3,
        retryDelay: 2000
    },
    deleteRetryConfig: {
        retryCount: 3,
        retryDelay: 2000
    }
};


const commentAnnotationDataProvider = {
    get: fetchCommentsFromDB,
    save: saveCommentsToDB,
    delete: deleteCommentsFromDB,
    config: commentResolverConfig
};

Velt.setDataProviders({
    comment: commentAnnotationDataProvider
});
```


</Tab>
</Tabs>

# Triggering Email Notifications when Self-Hosting

When you self-host content, use Webhooks to trigger emails from your own system:

### Step 1: Enable relevant webhooks

Subscribe to comment-related events (e.g., user mentions, replies). See [Webhooks basics](/webhooks/basic).

### Step 2: Receive webhook and fetch content from your DB

Your server receives the webhook event. Use IDs from the payload (e.g., `annotationId`, `commentId`) to query your own comment and notification content from your database via your Data Provider.

### Step 3: Assemble email content and recipients

Combine the webhook event context with the self-hosted content to build the subject, body, and list of recipients (e.g., mentioned users).

### Step 4: Send email via your provider

Use your own email service (SendGrid under your account, SES, Postmark, etc.) to send the email.

<Tip>
If you previously configured SendGrid in Velt Console, that configuration will not be used for self-hosted content. Use your own SendGrid account or another email provider from your server.
</Tip>

<Tabs>
<Tab title="Webhook Payload">
```json
{
  "actionType": "newlyAdded",
  "commentAnnotation": { 
    "annotationId": "ANNOTATION_ID", 
    "metadata": { "documentId": "DOC_ID" } 
  },
  "latestComment": { 
    "commentId": 123, 
    "from": { "userId": "USER_1" } 
  },
  "fromUser": { "userId": "USER_1" },
  "documentMetadata": { "url": "https://app.example.com/doc/123" }
}
```
</Tab>

<Tab title="Backend Handler">
```javascript
// Pseudocode: handle webhook, fetch content, send email
app.post('/webhooks/velt', async (req, res) => {
  const evt = req.body;
  const annotationId = evt?.commentAnnotation?.annotationId;
  const latestCommentId = evt?.latestComment?.commentId;

  // 1) Fetch self-hosted content
  const annotation = await db.commentAnnotations.get(annotationId);
  const latestComment = annotation?.comments?.[latestCommentId];

  // 2) Resolve recipients (e.g., mentioned users)
  const recipients = await resolveMentionedUsers(annotation, latestComment);

  // 3) Compose email
  const subject = `${evt.fromUser?.userId} mentioned you`;
  const body = latestComment?.commentText || '';
  const pageUrl = evt?.documentMetadata?.url;

  // 4) Send via your provider
  await emailClient.send({ 
    to: recipients, 
    subject, 
    html: renderTemplate({ body, pageUrl }) 
  });

  res.sendStatus(200);
});
```
</Tab>
</Tabs>

<Check>
You now send email notifications from your own infrastructure while keeping content self-hosted.
</Check>

# Sample Data

<Tabs>
<Tab title="Stored on your database">
```json
{
    "ANNOTATION_ID": {
        "annotationId": "ANNOTATION_ID",
        "metadata": {
            "apiKey": "API_KEY",
            "documentId": "DOCUMENT_ID",
            "organizationId": "ORGANIZATION_ID",
            "folderId": "FOLDER_ID"
        },
        "comments": {
            "COMMENT_ID": {
                "commentId": COMMENT_ID_NUMBER,
                "commentHtml": "<p>Comment Text</p>",
                "commentText": "Comment Text",
                "from": {
                    "userId": "USER_ID"
                }
            }
        },
        "from": {
            "userId": "1.1"
        }
    }
}
```
</Tab>
<Tab title="Stored on Velt servers">
```json
{
    "comments": [
        {
            "commentId": COMMENT_ID_NUMBER,
            "type": "text",
            "lastUpdated": "2025-07-16T04:00:19.770Z",
            "createdAt": 1752638419744,
            "from": {
                "userId": "USER_ID"
            }
        }
    ],
    "status": {
        "id": "OPEN",
        "name": "Open",
        "color": "var(--velt-accent, #625DF5)",
        "lightColor": "var(--velt-accent-light, #E7E8FA)",
        "type": "default"
    },
    "pageInfo": {
        "url": "PAGE_URL",
        "commentUrl": "COMMENT_URL"
    },
    "from": {
        "userId": "USER_ID"
    },
    "lastUpdated": 1752638419745,
    "createdAt": 1752638412635,
    "annotationId": "ANNOTATION_ID",
    "metadata": {
        "apiKey": "API_KEY",
        "documentId": "DOCUMENT_ID",
        "organizationId": "ORGANIZATION_ID",
        "folderId": "FOLDER_ID"
    }
}

```
</Tab>
</Tabs>