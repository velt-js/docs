---
title: "Comments"
description: "Self-host your comments data while using Velt's components. Keep comment storage on your infrastructure with minimal metadata stored on Velt servers."
---

<Warning>
  - This is currently only compatible with `setDocuments` method.
  - Ensure that the data providers are set prior to calling `identify` method.
  - The data provider methods must return the correct status code (e.g. 200 for success, 500 for errors) and success boolean in the response object. This ensures proper error handling and retries.
  - If you are using REST API to add or update comments, ensure that you set `isCommentResolverUsed` and `isCommentTextAvailable` fields in the request object. [Learn more](/api-reference/rest-apis/v2/comments-feature/comment-annotations/add-comment-annotations)
</Warning>

# Overview
Velt supports self-hosting your comments and related data:

- Comments can be stored on your own infrastructure, with only necessary identifiers on Velt servers.
- Velt Components automatically hydrate comment data in the frontend by fetching from your configured data provider.
- This gives you full control over comment data while maintaining all Velt collaboration features.
- This automatically also ensures that the in-app notifications content is not stored on Velt servers. The content is generated using the comments data in the frontend.

<Warning>
Email notifications via Velt's SendGrid integration are not available when you self-host comment content. Since the content lives on your infrastructure, Velt cannot construct and send emails via the sendgrid integration. Instead, use [Webhooks](/webhooks/basic) to receive events (e.g., mentions, replies), fetch the relevant comment/notification content from your database, and send emails from your own email provider.
</Warning>

# How does it work?
- When comments are created, updated, deleted or requested, the SDK uses your configured [`CommentAnnotationDataProvider`](/api-reference/sdk/models/data-models#commentannotationdataprovider) to handle storage and retrieval
- The data provider implements `get`, `save`, and `delete` methods to interact with your database
- Velt handles the data mapping and realtime synchronization while delegating persistence of actual content to your infrastructure
- The data provider works at the Comment Annotation (Thread) level not at the individual Comment (Message) level.
- For write requests (save, delete), the operation is first performed on your database and only if we get a success response, the SDK will perform the operation on the Velt server. If the operation fails on your database, the SDK will not perform the operation on the Velt server.
- You can configure retries, timeouts, etc. for the data provider.

Here are the methods that you need to implement on the data provider:
## get
Method to fetch comments from your database. On error we will retry.
- Param: [`GetCommentResolverRequest`](/api-reference/sdk/models/data-models#getcommentresolverrequest)
- Return: [`Promise<ResolverResponse<Record<string, PartialCommentAnnotation>>>`](/api-reference/sdk/models/data-models#resolverresponse)

## save
Save comments to your database. Return a success or error response. On error we will retry.
- Param: [`SaveCommentResolverRequest`](/api-reference/sdk/models/data-models#savecommentresolverrequest)
  - Note in the `SaveCommentResolverRequest` object, you will receive [the event name](/api-reference/sdk/models/data-models#resolveractions) that triggered the save.
- Return: [`Promise<ResolverResponse<T>>`](/api-reference/sdk/models/data-models#resolverresponse)

<Warning>
  If you are using REST API to add or update comments, ensure that you set `isCommentResolverUsed` and `isCommentTextAvailable` fields in the request object. [Learn more](/api-reference/rest-apis/v2/comments-feature/comment-annotations/add-comment-annotations)
</Warning>

## delete
Delete comments from your database. Return a success or error response. On error we will retry.
- Param: [`DeleteCommentResolverRequest`](/api-reference/sdk/models/data-models#deletecommentresolverrequest)
- Return: [`Promise<ResolverResponse<T>>`](/api-reference/sdk/models/data-models#resolverresponse)

## config
Configuration for the comment data provider.
- Type: [`ResolverConfig`](/api-reference/sdk/models/data-models#resolverconfig)

# Example Implementation

<Tabs>
<Tab title="React / Next.js">
``` jsx
const fetchCommentsFromDB = async (request: GetCommentResolverRequest) => {
    // Fetch comment annotations from your DB
    const result = await __getCommentsFromYourDB__(request)
      .then((response) => {
        return { data: response, success: true, statusCode: 200 };
      })
      .catch((error) => {
        return { success: false, statusCode: 500 };
      });

    return result;
};

const saveCommentsToDB = async (request: SaveCommentResolverRequest) => {
    const result = await __saveCommentsToYourDB__(request)
      .then((response) => {
        return { success: true, statusCode: 200 };
      })
      .catch((error) => {
        return { success: false, statusCode: 500 };
    });
    return result;
};

const deleteCommentsFromDB = async (request: DeleteCommentResolverRequest) => {
    const result = await __deleteCommentsFromYourDB__(request)
      .then((response) => {
        return { success: true, statusCode: 200 };
      })
      .catch((error) => {
        return { success: false, statusCode: 500 };
    });
    return result;
};

const commentResolverConfig: ResolverConfig = {
    resolveTimeout: 2000,
    getRetryConfig: {
        retryCount: 3,
        retryDelay: 2000
    },
    saveRetryConfig: {
        retryCount: 3,
        retryDelay: 2000
    },
    deleteRetryConfig: {
        retryCount: 3,
        retryDelay: 2000
    }
};


const commentAnnotationDataProvider: CommentAnnotationDataProvider = {
    get: fetchCommentsFromDB,
    save: saveCommentsToDB,
    delete: deleteCommentsFromDB,
    config: commentResolverConfig
};

<VeltProvider 
    apiKey='YOUR_API_KEY'
    dataProviders={{
        comment: commentAnnotationDataProvider
    }}
>
</VeltProvider>

```
</Tab>
<Tab title="Other Frameworks">
```js
const fetchCommentsFromDB = async (request) => {
    // Fetch comment annotations from your DB
    const result = await __getCommentsFromYourDB__(request)
      .then((response) => {
        return { data: response, success: true, statusCode: 200 };
      })
      .catch((error) => {
        return { success: false, statusCode: 500 };
      });

    return result;
};

const saveCommentsToDB = async (request) => {
    const result = await __saveCommentsToYourDB__(request)
      .then((response) => {
        return { success: true, statusCode: 200 };
      })
      .catch((error) => {
        return { success: false, statusCode: 500 };
    });
    return result;
};

const deleteCommentsFromDB = async (request) => {
    const result = await __deleteCommentsFromYourDB__(request)
      .then((response) => {
        return { success: true, statusCode: 200 };
      })
      .catch((error) => {
        return { success: false, statusCode: 500 };
    });
    return result;
};

const commentResolverConfig = {
    resolveTimeout: 2000,
    saveRetryConfig: {
        retryCount: 3,
        retryDelay: 2000
    },
    deleteRetryConfig: {
        retryCount: 3,
        retryDelay: 2000
    }
};


const commentAnnotationDataProvider = {
    get: fetchCommentsFromDB,
    save: saveCommentsToDB,
    delete: deleteCommentsFromDB,
    config: commentResolverConfig
};

Velt.setDataProviders({
    comment: commentAnnotationDataProvider
});
```


</Tab>
</Tabs>

# Triggering Email Notifications when Self-Hosting

When you self-host content, use Webhooks to trigger emails from your own system:

<Steps>
<Step title="Enable relevant webhooks">
Subscribe to comment-related events (e.g., user mentions, replies). See [Webhooks basics](/webhooks/basic).
</Step>

<Step title="Receive webhook and fetch content from your DB">
Your server receives the webhook event. Use IDs from the payload (e.g., `annotationId`, `commentId`) to query your own comment and notification content from your database via your Data Provider.
</Step>

<Step title="Assemble email content and recipients">
Combine the webhook event context with the self-hosted content to build the subject, body, and list of recipients (e.g., mentioned users).
</Step>

<Step title="Send email via your provider">
Use your own email service (SendGrid under your account, SES, Postmark, etc.) to send the email.
</Step>
</Steps>

**Example:** 

<Tabs>
<Tab title="Example Webhook Payload">
```json cURL
POST /webhooks/velt HTTP/1.1
Content-Type: application/json

{
  "actionType": "newlyAdded",
  "commentAnnotation": { "annotationId": "ANNOTATION_ID", "metadata": { "documentId": "DOC_ID" } },
  "latestComment": { "commentId": 123, "from": { "userId": "USER_1" } },
  "fromUser": { "userId": "USER_1" },
  "documentMetadata": { "url": "https://app.example.com/doc/123" }
}
```
</Tab>
<Tab title="Example Notification Code (Node.js)">
```javascript Node.js
// Pseudocode: handle webhook, fetch content, send email
app.post('/webhooks/velt', async (req, res) => {
  const evt = req.body;
  const annotationId = evt?.commentAnnotation?.annotationId;
  const latestCommentId = evt?.latestComment?.commentId;

  // 1) Fetch self-hosted content
  const annotation = await db.commentAnnotations.get(annotationId);
  const latestComment = annotation?.comments?.[latestCommentId];

  // 2) Resolve recipients (e.g., mentioned users)
  const recipients = await resolveMentionedUsers(annotation, latestComment);

  // 3) Compose email
  const subject = `${evt.fromUser?.userId} mentioned you`;
  const body = latestComment?.commentText || '';
  const pageUrl = evt?.documentMetadata?.url;

  // 4) Send via your provider
  await emailClient.send({ to: recipients, subject, html: renderTemplate({ body, pageUrl }) });

  res.sendStatus(200);
});
```
</Tab>
</Tabs>

# Sample Data

<Tabs>
<Tab title="Stored on your database">
```json
{
    "ANNOTATION_ID": {
        "annotationId": "ANNOTATION_ID",
        "metadata": {
            "apiKey": "API_KEY",
            "documentId": "DOCUMENT_ID",
            "organizationId": "ORGANIZATION_ID",
            "folderId": "FOLDER_ID"
        },
        "comments": {
            "COMMENT_ID": {
                "commentId": COMMENT_ID_NUMBER,
                "commentHtml": "<p>Comment Text</p>",
                "commentText": "Comment Text",
                "from": {
                    "userId": "USER_ID"
                }
            }
        },
        "from": {
            "userId": "1.1"
        }
    }
}
```
</Tab>
<Tab title="Stored on Velt servers">
```json
{
    "comments": [
        {
            "commentId": COMMENT_ID_NUMBER,
            "type": "text",
            "lastUpdated": "2025-07-16T04:00:19.770Z",
            "createdAt": 1752638419744,
            "from": {
                "userId": "USER_ID"
            }
        }
    ],
    "status": {
        "id": "OPEN",
        "name": "Open",
        "color": "var(--velt-accent, #625DF5)",
        "lightColor": "var(--velt-accent-light, #E7E8FA)",
        "type": "default"
    },
    "pageInfo": {
        "url": "PAGE_URL",
        "commentUrl": "COMMENT_URL"
    },
    "from": {
        "userId": "USER_ID"
    },
    "lastUpdated": 1752638419745,
    "createdAt": 1752638412635,
    "annotationId": "ANNOTATION_ID",
    "metadata": {
        "apiKey": "API_KEY",
        "documentId": "DOCUMENT_ID",
        "organizationId": "ORGANIZATION_ID",
        "folderId": "FOLDER_ID"
    }
}

```
</Tab>
</Tabs>