---
title: "Reactions"
description: "Self-host your reactions data while using Velt's components. Keep reaction storage on your infrastructure with minimal metadata stored on Velt servers."
---

<Warning>
  - This is currently only compatible with `setDocuments` method.
  - Ensure that the data providers are set prior to calling `identify` method.
  - The data provider methods must return the correct status code (e.g. 200 for success, 500 for errors) and success boolean in the response object. This ensures proper error handling and retries.
</Warning>

# Overview
Velt supports self-hosting your reactions and related data:

- Reactions can be stored on your own infrastructure, with only necessary identifiers on Velt servers.
- Velt Components automatically hydrate reaction data in the frontend by fetching from your configured data provider.
- This gives you full control over reaction data while maintaining all Velt collaboration features.
- This automatically also ensures that the in-app notifications content related to reactions is not stored on Velt servers. The content is generated using the reactions data in the frontend.

# How does it work?
- When reactions are created, updated, deleted or requested, the SDK uses your configured [`ReactionAnnotationDataProvider`](/api-reference/sdk/models/data-models#reactionannotationdataprovider) to handle storage and retrieval
- The data provider implements `get`, `save`, and `delete` methods to interact with your database
- Velt handles the data mapping and realtime synchronization while delegating persistence of actual content to your infrastructure
- For write requests (save, delete), the operation is first performed on your database and only if we get a success response, the SDK will perform the operation on the Velt server. If the operation fails on your database, the SDK will not perform the operation on the Velt server.
- You can configure retries, timeouts, etc. for the data provider.


Here are the methods that you need to implement on the data provider:
## get
Method to fetch reactions from your database. On error we will retry.
- Param: [`GetReactionResolverRequest`](/api-reference/sdk/models/data-models#getreactionresolverrequest)
- Return: [`Promise<ResolverResponse<Record<string, PartialReactionAnnotation>>>`](/api-reference/sdk/models/data-models#resolverresponse)

<Tabs>
<Tab title="Frontend">
```jsx
const fetchReactionsFromDB = async (request) => {
  const response = await fetch('/api/velt/reactions/get', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(request)
  });
  const data = await response.json();
  return { data: data.result || {}, success: true, statusCode: 200 };
};
```
</Tab>
<Tab title="Backend (MongoDB)">
```javascript
// Build query from request filters
const query = {};
if (filters.reactionAnnotationIds?.length) {
  query.annotationId = { $in: filters.reactionAnnotationIds };
}
if (filters.documentIds?.length) {
  query.documentId = { $in: filters.documentIds };
}
if (filters.organizationId) {
  query.organizationId = filters.organizationId;
}

const annotations = await collection.find(query).toArray();

// Convert to Record<annotationId, annotation>
const result = {};
for (const annotation of annotations) {
  result[annotation.annotationId] = annotation;
}
return result;
```
</Tab>
<Tab title="Backend (PostgreSQL)">
```javascript
// Build parameterized query from filters
const conditions = [];
const values = [];
let paramIndex = 1;

if (filters.reactionAnnotationIds?.length) {
  conditions.push(`annotation_id = ANY($${paramIndex++})`);
  values.push(filters.reactionAnnotationIds);
}
if (filters.documentIds?.length) {
  conditions.push(`document_id = ANY($${paramIndex++})`);
  values.push(filters.documentIds);
}
if (filters.organizationId) {
  conditions.push(`organization_id = $${paramIndex++}`);
  values.push(filters.organizationId);
}

const whereClause = conditions.length ? `WHERE ${conditions.join(' AND ')}` : '';
const { rows } = await client.query(
  `SELECT annotation_id, data FROM reaction_annotations ${whereClause}`,
  values
);

// Convert to Record<annotationId, annotation>
const result = {};
for (const row of rows) {
  result[row.annotation_id] = row.data;
}
return result;
```
</Tab>
</Tabs>

## save
Save reactions to your database. Return a success or error response. On error we will retry.
- Param: [`SaveReactionResolverRequest`](/api-reference/sdk/models/data-models#savereactionresolverrequest)
- Return: [`Promise<ResolverResponse<T>>`](/api-reference/sdk/models/data-models#resolverresponse)

<Tabs>
<Tab title="Frontend">
```jsx
const saveReactionsToDB = async (request) => {
  const response = await fetch('/api/velt/reactions/save', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(request)
  });
  return response.ok
    ? { success: true, statusCode: 200 }
    : { success: false, statusCode: response.status };
};
```
</Tab>
<Tab title="Backend (MongoDB)">
```javascript
// Bulk upsert annotations
const operations = Object.entries(annotations).map(([id, annotation]) => ({
  updateOne: {
    filter: { annotationId: id },
    update: {
      $set: {
        ...annotation,
        annotationId: id,
        documentId: context?.documentId || annotation.documentId,
        organizationId: context?.organizationId || annotation.organizationId,
      }
    },
    upsert: true
  }
}));

if (operations.length > 0) {
  await collection.bulkWrite(operations);
}
```
</Tab>
<Tab title="Backend (PostgreSQL)">
```javascript
// Transaction-based upsert
await client.query('BEGIN');

for (const [id, annotation] of Object.entries(annotations)) {
  const data = { ...annotation, annotationId: id };

  await client.query(
    `INSERT INTO reaction_annotations (annotation_id, document_id, organization_id, data, updated_at)
     VALUES ($1, $2, $3, $4, NOW())
     ON CONFLICT (annotation_id)
     DO UPDATE SET data = EXCLUDED.data, updated_at = NOW()`,
    [id, annotation.documentId, annotation.organizationId, JSON.stringify(data)]
  );
}

await client.query('COMMIT');
```
</Tab>
</Tabs>

## delete
Delete reactions from your database. Return a success or error response. On error we will retry.
- Param: [`DeleteReactionResolverRequest`](/api-reference/sdk/models/data-models#deletereactionresolverrequest)
- Return: [`Promise<ResolverResponse<T>>`](/api-reference/sdk/models/data-models#resolverresponse)

<Tabs>
<Tab title="Frontend">
```jsx
const deleteReactionsFromDB = async (request) => {
  const response = await fetch('/api/velt/reactions/delete', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(request)
  });
  return response.ok
    ? { success: true, statusCode: 200 }
    : { success: false, statusCode: response.status };
};
```
</Tab>
<Tab title="Backend (MongoDB)">
```javascript
await collection.deleteOne({ annotationId });
```
</Tab>
<Tab title="Backend (PostgreSQL)">
```javascript
await client.query(
  'DELETE FROM reaction_annotations WHERE annotation_id = $1',
  [annotationId]
);
```
</Tab>
</Tabs>

## config
Configuration for the reaction data provider.
- Type: [`ResolverConfig`](/api-reference/sdk/models/data-models#resolverconfig)

```jsx
const reactionResolverConfig = {
  resolveTimeout: 2000,
  saveRetryConfig: { retryCount: 3, retryDelay: 2000 },
  deleteRetryConfig: { retryCount: 3, retryDelay: 2000 }
};
```

# Example Implementation

<Tabs>
<Tab title="React / Next.js">
``` jsx
const fetchReactionsFromDB = async (request) => {
  const response = await fetch('/api/velt/reactions/get', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(request)
  });
  const data = await response.json();
  return { data: data.result || {}, success: true, statusCode: 200 };
};

const saveReactionsToDB = async (request) => {
  const response = await fetch('/api/velt/reactions/save', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(request)
  });
  return response.ok
    ? { success: true, statusCode: 200 }
    : { success: false, statusCode: response.status };
};

const deleteReactionsFromDB = async (request) => {
  const response = await fetch('/api/velt/reactions/delete', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(request)
  });
  return response.ok
    ? { success: true, statusCode: 200 }
    : { success: false, statusCode: response.status };
};

const reactionResolverConfig = {
  resolveTimeout: 2000,
  saveRetryConfig: { retryCount: 3, retryDelay: 2000 },
  deleteRetryConfig: { retryCount: 3, retryDelay: 2000 }
};

const reactionDataProvider = {
  get: fetchReactionsFromDB,
  save: saveReactionsToDB,
  delete: deleteReactionsFromDB,
  config: reactionResolverConfig
};

<VeltProvider
  apiKey='YOUR_API_KEY'
  dataProviders={{ reaction: reactionDataProvider }}
>
</VeltProvider>
```
</Tab>
<Tab title="Other Frameworks">
``` jsx
const fetchReactionsFromDB = async (request) => {
  const response = await fetch('/api/velt/reactions/get', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(request)
  });
  const data = await response.json();
  return { data: data.result || {}, success: true, statusCode: 200 };
};

const saveReactionsToDB = async (request) => {
  const response = await fetch('/api/velt/reactions/save', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(request)
  });
  return response.ok
    ? { success: true, statusCode: 200 }
    : { success: false, statusCode: response.status };
};

const deleteReactionsFromDB = async (request) => {
  const response = await fetch('/api/velt/reactions/delete', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(request)
  });
  return response.ok
    ? { success: true, statusCode: 200 }
    : { success: false, statusCode: response.status };
};

const reactionResolverConfig = {
  resolveTimeout: 2000,
  saveRetryConfig: { retryCount: 3, retryDelay: 2000 },
  deleteRetryConfig: { retryCount: 3, retryDelay: 2000 }
};

const reactionDataProvider = {
  get: fetchReactionsFromDB,
  save: saveReactionsToDB,
  delete: deleteReactionsFromDB,
  config: reactionResolverConfig
};

Velt.setDataProviders({ reaction: reactionDataProvider });
```
</Tab>
</Tabs>

# Sample Data

<Tabs>
<Tab title="Stored on your database">
```json
{
    "ANNOTATION_ID": {
        "annotationId": "ANNOTATION_ID",
        "metadata": {
            "apiKey": "API_KEY",
            "documentId": "DOCUMENT_ID",
            "organizationId": "ORGANIZATION_ID",
            "folderId": "FOLDER_ID"
        },
        "reactions": {
            "REACTION_ID": {
                "reactionId": "REACTION_ID",
                "emoji": "thumbsup",
                "from": {
                    "userId": "USER_ID"
                },
                "createdAt": 1752638419744
            }
        },
        "from": {
            "userId": "USER_ID"
        }
    }
}
```
</Tab>
<Tab title="Stored on Velt servers">
```json
{
    "reactions": [
        {
            "reactionId": "REACTION_ID",
            "type": "emoji",
            "lastUpdated": "2025-07-16T04:00:19.770Z",
            "createdAt": 1752638419744,
            "from": {
                "userId": "USER_ID"
            }
        }
    ],
    "from": {
        "userId": "USER_ID"
    },
    "lastUpdated": 1752638419745,
    "createdAt": 1752638412635,
    "annotationId": "ANNOTATION_ID",
    "metadata": {
        "apiKey": "API_KEY",
        "documentId": "DOCUMENT_ID",
        "organizationId": "ORGANIZATION_ID",
        "folderId": "FOLDER_ID"
    }
}
```
</Tab>
</Tabs>

# Debugging

You can subscribe to `dataProvider` events to monitor and debug get, save, and delete operations:

<Tabs>
<Tab title="React / Next.js">
```jsx
import { useVeltClient } from '@veltdev/react';

const { client } = useVeltClient();

useEffect(() => {
  if (!client) return;

  const subscription = client.on('dataProvider').subscribe((event) => {
    console.log('Data Provider Event:', event);
  });

  return () => subscription?.unsubscribe();
}, [client]);
```
</Tab>

<Tab title="Other Frameworks">
```javascript
const subscription = Velt.on('dataProvider').subscribe((event) => {
  console.log('Data Provider Event:', event);
});

// Unsubscribe when done
subscription?.unsubscribe();
```
</Tab>
</Tabs>